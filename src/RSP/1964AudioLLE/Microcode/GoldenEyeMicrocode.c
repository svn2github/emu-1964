//RSP microcode

#include "../../Shared/rsp_prefix.h"
#include "../../Shared/rsp_macros.h"
#include "Microcode.h"
#include "TestMacros.h"

void _GoldenEyeData(_u32 StartAddress);

void GoldenEye1800_184C(void);
void GoldenEye1CF4_1D04(void);
void GoldenEye1D08_1D2C(void);
void GoldenEye1D60_1D8C(void);

void _GoldenEyeBootCode(_u32 StartAddress)
{
	static _u32	JumpTable[(0x1000 >> 2)];
	static _u32	BuildJumpTable = 0;

	if (!BuildJumpTable)
	{
		BuildJumpTable = 1;
		goto _BuildJumpTable;
	}

	_Label:
	StartAddress = JumpTable[(StartAddress & 0x0FFF) >> 2];
	__asm mov eax, StartAddress
	__asm jmp eax


_04001000:	// 4001000: <09000419>	J         04001064
	state.r[AT] = 0 + 0x0FC0;
	goto _04001064;


_04001004:	// 4001004: <20010fc0>	ADDI      AT = R0 + 0fc0
	state.r[AT] = 0 + 0x0FC0;


_04001008:	// 4001008: <8c220010>	LW        V0 = [AT+0010]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000010) & 0xfff);


_0400100C:	// 400100c: <20030f7f>	ADDI      V1 = R0 + 0f7f
	state.r[V1] = 0 + 0x0F7F;


_04001010:	// 4001010: <20071080>	ADDI      A3 = R0 + 1080
	state.r[A3] = 0 + 0x1080;


_04001014:	// 4001014: <40870000>	MTC0      SP memory address = A3
	DMEM_Address = state.r[A3];


_04001018:	// 4001018: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_0400101C:	// 400101c: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x04001020;
	_GoldenEyeData(0x04001020);
	return;


_04001020:	// 4001020: <40043000>	MFC0      A2 = SP status
	state.r[A0] = 0;


_04001024:	// 4001024: <1480fffe>	BNE       (R0!=A0) --> 1020
	sp_reg_pc = 0x04001024;
	if (state.r[A0] != 0)
	{
		goto _04001020;
	}


_04001028:	// 4001028: <00000000>	NOP       


_0400102C:	// 400102c: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x0400102C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_04001030:	// 4001030: <00000000>	NOP       


_04001034:	// 4001034: <00e00008>	JR        A3
	{
		_u32	temp = ((state.r[A3] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001038:	// 4001038: <40803800>	MTC0      SP semaphore = R0


_0400103C:	// 400103c: <40082000>	MFC0      A0 = DP CMD DMA start
	state.r[T0] = 0;


_04001040:	// 4001040: <31080080>	ANDI      T0 = T0 & 0080
	state.r[T0] = (state.r[T0] & 0x00000080);


_04001044:	// 4001044: <15000002>	BNE       (R0!=T0) --> 1050
	sp_reg_pc = 0x04001044;
	if (state.r[T0] != 0)
	{
		goto _04001050;
	}


_04001048:	// 4001048: <00000000>	NOP       


_0400104C:	// 400104c: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001050:	// 4001050: <40803800>	MTC0      SP semaphore = R0


_04001054:	// 4001054: <34085200>	ORI       T0 = R0 | 0x5200
	state.r[T0] = (0 | 0x00005200);


_04001058:	// 4001058: <40882000>	MTC0      SP status = T0


_0400105C:	// 400105c: <0000000d>	BREAK
	state.halt = 1;
	return;


_04001060:	// 4001060: <00000000>	NOP       


_04001064:	// 4001064: <8c220004>	LW        V0 = [AT+0004]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000004) & 0xfff);


_04001068:	// 4001068: <30420002>	ANDI      V0 = V0 & 0002
	state.r[V0] = (state.r[V0] & 0x00000002);


_0400106C:	// 400106c: <10400007>	BEQ       (R0==V0) --> 108c
	sp_reg_pc = 0x0400106C;
	if (state.r[V0] == 0)
	{
		goto _0400108C;
	}


_04001070:	// 4001070: <00000000>	NOP       


_04001074:	// 4001074: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x04001074;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_04001078:	// 4001078: <00000000>	NOP       


_0400107C:	// 400107c: <40025800>	MFC0      T3 = SP read DMA length
	state.r[V0] = 0;


_04001080:	// 4001080: <30420100>	ANDI      V0 = V0 & 0100
	state.r[V0] = (state.r[V0] & 0x00000100);


_04001084:	// 4001084: <1c40ffed>	BGTZ      (R0>0) --> 103c
	sp_reg_pc = 0x04001084;
	if((_s32)state.r[V0] > 0)
	{
		goto _0400103C;
	}


_04001088:	// 4001088: <00000000>	NOP       


_0400108C:	// 400108c: <8c220018>	LW        V0 = [AT+0018]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000018) & 0xfff);


_04001090:	// 4001090: <8c23001c>	LW        V1 = [AT+001c]
	state.r[V1] = (_s32)Load32_DMEM((state.r[AT] + 0x0000001C) & 0xfff);


_04001094:	// 4001094: <2063ffff>	ADDI      V1 = V1 + ffff
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;


_04001098:	// 4001098: <401e2800>	MFC0      A1 = unknown
	state.r[S8] = 0;


_0400109C:	// 400109c: <17c0fffe>	BNE       (R0!=S8) --> 1098
	sp_reg_pc = 0x0400109C;
	if (state.r[S8] != 0)
	{
		goto _04001098;
	}


_040010A0:	// 40010a0: <00000000>	NOP       


_040010A4:	// 40010a4: <40800000>	MTC0      SP memory address = R0
	DMEM_Address = 0;


_040010A8:	// 40010a8: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_040010AC:	// 40010ac: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x040010AC;
	DMARead(state.r[V1]);


_040010B0:	// 40010b0: <40043000>	MFC0      A2 = SP status
	state.r[A0] = 0;


_040010B4:	// 40010b4: <1480fffe>	BNE       (R0!=A0) --> 10b0
	sp_reg_pc = 0x040010B4;
	if (state.r[A0] != 0)
	{
		goto _040010B0;
	}


_040010B8:	// 40010b8: <00000000>	NOP       


_040010BC:	// 40010bc: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x040010BC;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_040010C0:	// 40010c0: <00000000>	NOP       


_040010C4:	// 40010c4: <09000402>	J         04001008
	goto _04001008;


_040010C8:	// 40010c8: <00000000>	NOP       

_040010CC:
_040010D0:
_040010D4:
_040010D8:
_040010DC:
_040010E0:
_040010E4:
_040010E8:
_040010EC:
_040010F0:
_040010F4:
_040010F8:
_040010FC:
_04001100:
_04001104:
_04001108:
_0400110C:
_04001110:
_04001114:
_04001118:
_0400111C:
_04001120:
_04001124:
_04001128:
_0400112C:
_04001130:
_04001134:
_04001138:
_0400113C:
_04001140:
_04001144:
_04001148:
_0400114C:
_04001150:
_04001154:
_04001158:
_0400115C:
_04001160:
_04001164:
_04001168:
_0400116C:
_04001170:
_04001174:
_04001178:
_0400117C:
_04001180:
_04001184:
_04001188:
_0400118C:
_04001190:
_04001194:
_04001198:
_0400119C:
_040011A0:
_040011A4:
_040011A8:
_040011AC:
_040011B0:
_040011B4:
_040011B8:
_040011BC:
_040011C0:
_040011C4:
_040011C8:
_040011CC:
_040011D0:
_040011D4:
_040011D8:
_040011DC:
_040011E0:
_040011E4:
_040011E8:
_040011EC:
_040011F0:
_040011F4:
_040011F8:
_040011FC:
_04001200:
_04001204:
_04001208:
_0400120C:
_04001210:
_04001214:
_04001218:
_0400121C:
_04001220:
_04001224:
_04001228:
_0400122C:
_04001230:
_04001234:
_04001238:
_0400123C:
_04001240:
_04001244:
_04001248:
_0400124C:
_04001250:
_04001254:
_04001258:
_0400125C:
_04001260:
_04001264:
_04001268:
_0400126C:
_04001270:
_04001274:
_04001278:
_0400127C:
_04001280:
_04001284:
_04001288:
_0400128C:
_04001290:
_04001294:
_04001298:
_0400129C:
_040012A0:
_040012A4:
_040012A8:
_040012AC:
_040012B0:
_040012B4:
_040012B8:
_040012BC:
_040012C0:
_040012C4:
_040012C8:
_040012CC:
_040012D0:
_040012D4:
_040012D8:
_040012DC:
_040012E0:
_040012E4:
_040012E8:
_040012EC:
_040012F0:
_040012F4:
_040012F8:
_040012FC:
_04001300:
_04001304:
_04001308:
_0400130C:
_04001310:
_04001314:
_04001318:
_0400131C:
_04001320:
_04001324:
_04001328:
_0400132C:
_04001330:
_04001334:
_04001338:
_0400133C:
_04001340:
_04001344:
_04001348:
_0400134C:
_04001350:
_04001354:
_04001358:
_0400135C:
_04001360:
_04001364:
_04001368:
_0400136C:
_04001370:
_04001374:
_04001378:
_0400137C:
_04001380:
_04001384:
_04001388:
_0400138C:
_04001390:
_04001394:
_04001398:
_0400139C:
_040013A0:
_040013A4:
_040013A8:
_040013AC:
_040013B0:
_040013B4:
_040013B8:
_040013BC:
_040013C0:
_040013C4:
_040013C8:
_040013CC:
_040013D0:
_040013D4:
_040013D8:
_040013DC:
_040013E0:
_040013E4:
_040013E8:
_040013EC:
_040013F0:
_040013F4:
_040013F8:
_040013FC:
_04001400:
_04001404:
_04001408:
_0400140C:
_04001410:
_04001414:
_04001418:
_0400141C:
_04001420:
_04001424:
_04001428:
_0400142C:
_04001430:
_04001434:
_04001438:
_0400143C:
_04001440:
_04001444:
_04001448:
_0400144C:
_04001450:
_04001454:
_04001458:
_0400145C:
_04001460:
_04001464:
_04001468:
_0400146C:
_04001470:
_04001474:
_04001478:
_0400147C:
_04001480:
_04001484:
_04001488:
_0400148C:
_04001490:
_04001494:
_04001498:
_0400149C:
_040014A0:
_040014A4:
_040014A8:
_040014AC:
_040014B0:
_040014B4:
_040014B8:
_040014BC:
_040014C0:
_040014C4:
_040014C8:
_040014CC:
_040014D0:
_040014D4:
_040014D8:
_040014DC:
_040014E0:
_040014E4:
_040014E8:
_040014EC:
_040014F0:
_040014F4:
_040014F8:
_040014FC:
_04001500:
_04001504:
_04001508:
_0400150C:
_04001510:
_04001514:
_04001518:
_0400151C:
_04001520:
_04001524:
_04001528:
_0400152C:
_04001530:
_04001534:
_04001538:
_0400153C:
_04001540:
_04001544:
_04001548:
_0400154C:
_04001550:
_04001554:
_04001558:
_0400155C:
_04001560:
_04001564:
_04001568:
_0400156C:
_04001570:
_04001574:
_04001578:
_0400157C:
_04001580:
_04001584:
_04001588:
_0400158C:
_04001590:
_04001594:
_04001598:
_0400159C:
_040015A0:
_040015A4:
_040015A8:
_040015AC:
_040015B0:
_040015B4:
_040015B8:
_040015BC:
_040015C0:
_040015C4:
_040015C8:
_040015CC:
_040015D0:
_040015D4:
_040015D8:
_040015DC:
_040015E0:
_040015E4:
_040015E8:
_040015EC:
_040015F0:
_040015F4:
_040015F8:
_040015FC:
_04001600:
_04001604:
_04001608:
_0400160C:
_04001610:
_04001614:
_04001618:
_0400161C:
_04001620:
_04001624:
_04001628:
_0400162C:
_04001630:
_04001634:
_04001638:
_0400163C:
_04001640:
_04001644:
_04001648:
_0400164C:
_04001650:
_04001654:
_04001658:
_0400165C:
_04001660:
_04001664:
_04001668:
_0400166C:
_04001670:
_04001674:
_04001678:
_0400167C:
_04001680:
_04001684:
_04001688:
_0400168C:
_04001690:
_04001694:
_04001698:
_0400169C:
_040016A0:
_040016A4:
_040016A8:
_040016AC:
_040016B0:
_040016B4:
_040016B8:
_040016BC:
_040016C0:
_040016C4:
_040016C8:
_040016CC:
_040016D0:
_040016D4:
_040016D8:
_040016DC:
_040016E0:
_040016E4:
_040016E8:
_040016EC:
_040016F0:
_040016F4:
_040016F8:
_040016FC:
_04001700:
_04001704:
_04001708:
_0400170C:
_04001710:
_04001714:
_04001718:
_0400171C:
_04001720:
_04001724:
_04001728:
_0400172C:
_04001730:
_04001734:
_04001738:
_0400173C:
_04001740:
_04001744:
_04001748:
_0400174C:
_04001750:
_04001754:
_04001758:
_0400175C:
_04001760:
_04001764:
_04001768:
_0400176C:
_04001770:
_04001774:
_04001778:
_0400177C:
_04001780:
_04001784:
_04001788:
_0400178C:
_04001790:
_04001794:
_04001798:
_0400179C:
_040017A0:
_040017A4:
_040017A8:
_040017AC:
_040017B0:
_040017B4:
_040017B8:
_040017BC:
_040017C0:
_040017C4:
_040017C8:
_040017CC:
_040017D0:
_040017D4:
_040017D8:
_040017DC:
_040017E0:
_040017E4:
_040017E8:
_040017EC:
_040017F0:
_040017F4:
_040017F8:
_040017FC:
_04001800:
_04001804:
_04001808:
_0400180C:
_04001810:
_04001814:
_04001818:
_0400181C:
_04001820:
_04001824:
_04001828:
_0400182C:
_04001830:
_04001834:
_04001838:
_0400183C:
_04001840:
_04001844:
_04001848:
_0400184C:
_04001850:
_04001854:
_04001858:
_0400185C:
_04001860:
_04001864:
_04001868:
_0400186C:
_04001870:
_04001874:
_04001878:
_0400187C:
_04001880:
_04001884:
_04001888:
_0400188C:
_04001890:
_04001894:
_04001898:
_0400189C:
_040018A0:
_040018A4:
_040018A8:
_040018AC:
_040018B0:
_040018B4:
_040018B8:
_040018BC:
_040018C0:
_040018C4:
_040018C8:
_040018CC:
_040018D0:
_040018D4:
_040018D8:
_040018DC:
_040018E0:
_040018E4:
_040018E8:
_040018EC:
_040018F0:
_040018F4:
_040018F8:
_040018FC:
_04001900:
_04001904:
_04001908:
_0400190C:
_04001910:
_04001914:
_04001918:
_0400191C:
_04001920:
_04001924:
_04001928:
_0400192C:
_04001930:
_04001934:
_04001938:
_0400193C:
_04001940:
_04001944:
_04001948:
_0400194C:
_04001950:
_04001954:
_04001958:
_0400195C:
_04001960:
_04001964:
_04001968:
_0400196C:
_04001970:
_04001974:
_04001978:
_0400197C:
_04001980:
_04001984:
_04001988:
_0400198C:
_04001990:
_04001994:
_04001998:
_0400199C:
_040019A0:
_040019A4:
_040019A8:
_040019AC:
_040019B0:
_040019B4:
_040019B8:
_040019BC:
_040019C0:
_040019C4:
_040019C8:
_040019CC:
_040019D0:
_040019D4:
_040019D8:
_040019DC:
_040019E0:
_040019E4:
_040019E8:
_040019EC:
_040019F0:
_040019F4:
_040019F8:
_040019FC:
_04001A00:
_04001A04:
_04001A08:
_04001A0C:
_04001A10:
_04001A14:
_04001A18:
_04001A1C:
_04001A20:
_04001A24:
_04001A28:
_04001A2C:
_04001A30:
_04001A34:
_04001A38:
_04001A3C:
_04001A40:
_04001A44:
_04001A48:
_04001A4C:
_04001A50:
_04001A54:
_04001A58:
_04001A5C:
_04001A60:
_04001A64:
_04001A68:
_04001A6C:
_04001A70:
_04001A74:
_04001A78:
_04001A7C:
_04001A80:
_04001A84:
_04001A88:
_04001A8C:
_04001A90:
_04001A94:
_04001A98:
_04001A9C:
_04001AA0:
_04001AA4:
_04001AA8:
_04001AAC:
_04001AB0:
_04001AB4:
_04001AB8:
_04001ABC:
_04001AC0:
_04001AC4:
_04001AC8:
_04001ACC:
_04001AD0:
_04001AD4:
_04001AD8:
_04001ADC:
_04001AE0:
_04001AE4:
_04001AE8:
_04001AEC:
_04001AF0:
_04001AF4:
_04001AF8:
_04001AFC:
_04001B00:
_04001B04:
_04001B08:
_04001B0C:
_04001B10:
_04001B14:
_04001B18:
_04001B1C:
_04001B20:
_04001B24:
_04001B28:
_04001B2C:
_04001B30:
_04001B34:
_04001B38:
_04001B3C:
_04001B40:
_04001B44:
_04001B48:
_04001B4C:
_04001B50:
_04001B54:
_04001B58:
_04001B5C:
_04001B60:
_04001B64:
_04001B68:
_04001B6C:
_04001B70:
_04001B74:
_04001B78:
_04001B7C:
_04001B80:
_04001B84:
_04001B88:
_04001B8C:
_04001B90:
_04001B94:
_04001B98:
_04001B9C:
_04001BA0:
_04001BA4:
_04001BA8:
_04001BAC:
_04001BB0:
_04001BB4:
_04001BB8:
_04001BBC:
_04001BC0:
_04001BC4:
_04001BC8:
_04001BCC:
_04001BD0:
_04001BD4:
_04001BD8:
_04001BDC:
_04001BE0:
_04001BE4:
_04001BE8:
_04001BEC:
_04001BF0:
_04001BF4:
_04001BF8:
_04001BFC:
_04001C00:
_04001C04:
_04001C08:
_04001C0C:
_04001C10:
_04001C14:
_04001C18:
_04001C1C:
_04001C20:
_04001C24:
_04001C28:
_04001C2C:
_04001C30:
_04001C34:
_04001C38:
_04001C3C:
_04001C40:
_04001C44:
_04001C48:
_04001C4C:
_04001C50:
_04001C54:
_04001C58:
_04001C5C:
_04001C60:
_04001C64:
_04001C68:
_04001C6C:
_04001C70:
_04001C74:
_04001C78:
_04001C7C:
_04001C80:
_04001C84:
_04001C88:
_04001C8C:
_04001C90:
_04001C94:
_04001C98:
_04001C9C:
_04001CA0:
_04001CA4:
_04001CA8:
_04001CAC:
_04001CB0:
_04001CB4:
_04001CB8:
_04001CBC:
_04001CC0:
_04001CC4:
_04001CC8:
_04001CCC:
_04001CD0:
_04001CD4:
_04001CD8:
_04001CDC:
_04001CE0:
_04001CE4:
_04001CE8:
_04001CEC:
_04001CF0:
_04001CF4:
_04001CF8:
_04001CFC:
_04001D00:
_04001D04:
_04001D08:
_04001D0C:
_04001D10:
_04001D14:
_04001D18:
_04001D1C:
_04001D20:
_04001D24:
_04001D28:
_04001D2C:
_04001D30:
_04001D34:
_04001D38:
_04001D3C:
_04001D40:
_04001D44:
_04001D48:
_04001D4C:
_04001D50:
_04001D54:
_04001D58:
_04001D5C:
_04001D60:
_04001D64:
_04001D68:
_04001D6C:
_04001D70:
_04001D74:
_04001D78:
_04001D7C:
_04001D80:
_04001D84:
_04001D88:
_04001D8C:
_04001D90:
_04001D94:
_04001D98:
_04001D9C:
_04001DA0:
_04001DA4:
_04001DA8:
_04001DAC:
_04001DB0:
_04001DB4:
_04001DB8:
_04001DBC:
_04001DC0:
_04001DC4:
_04001DC8:
_04001DCC:
_04001DD0:
_04001DD4:
_04001DD8:
_04001DDC:
_04001DE0:
_04001DE4:
_04001DE8:
_04001DEC:
_04001DF0:
_04001DF4:
_04001DF8:
_04001DFC:
_04001E00:
_04001E04:
_04001E08:
_04001E0C:
_04001E10:
_04001E14:
_04001E18:
_04001E1C:
_04001E20:
_04001E24:
_04001E28:
_04001E2C:
_04001E30:
_04001E34:
_04001E38:
_04001E3C:
_04001E40:
_04001E44:
_04001E48:
_04001E4C:
_04001E50:
_04001E54:
_04001E58:
_04001E5C:
_04001E60:
_04001E64:
_04001E68:
_04001E6C:
_04001E70:
_04001E74:
_04001E78:
_04001E7C:
_04001E80:
_04001E84:
_04001E88:
_04001E8C:
_04001E90:
_04001E94:
_04001E98:
_04001E9C:
_04001EA0:
_04001EA4:
_04001EA8:
_04001EAC:
_04001EB0:
_04001EB4:
_04001EB8:
_04001EBC:
_04001EC0:
_04001EC4:
_04001EC8:
_04001ECC:
_04001ED0:
_04001ED4:
_04001ED8:
_04001EDC:
_04001EE0:
_04001EE4:
_04001EE8:
_04001EEC:
_04001EF0:
_04001EF4:
_04001EF8:
_04001EFC:
_04001F00:
_04001F04:
_04001F08:
_04001F0C:
_04001F10:
_04001F14:
_04001F18:
_04001F1C:
_04001F20:
_04001F24:
_04001F28:
_04001F2C:
_04001F30:
_04001F34:
_04001F38:
_04001F3C:
_04001F40:
_04001F44:
_04001F48:
_04001F4C:
_04001F50:
_04001F54:
_04001F58:
_04001F5C:
_04001F60:
_04001F64:
_04001F68:
_04001F6C:
_04001F70:
_04001F74:
_04001F78:
_04001F7C:
_04001F80:
_04001F84:
_04001F88:
_04001F8C:
_04001F90:
_04001F94:
_04001F98:
_04001F9C:
_04001FA0:
_04001FA4:
_04001FA8:
_04001FAC:
_04001FB0:
_04001FB4:
_04001FB8:
_04001FBC:
_04001FC0:
_04001FC4:
_04001FC8:
_04001FCC:
_04001FD0:
_04001FD4:
_04001FD8:
_04001FDC:
_04001FE0:
_04001FE4:
_04001FE8:
_04001FEC:
_04001FF0:
_04001FF4:
_04001FF8:
_04001FFC:
	state.halt = 1;
	return;

	_BuildJumpTable:
	#include "jumptable.h"
	goto _Label;
}

void _GoldenEyeData(_u32 StartAddress)
{
	static _u32	JumpTable[(0x1000 >> 2)];
	static _u32	BuildJumpTable = 0;

	if (!BuildJumpTable)
	{
		BuildJumpTable = 1;
		goto _BuildJumpTable;
	}

	_Label:
	StartAddress = JumpTable[(StartAddress & 0x0FFF) >> 2];
	__asm mov eax, StartAddress
	__asm jmp eax


_04001000:	// 4001000: <09000419>	J         04001064
	state.r[AT] = 0 + 0x0FC0;
	goto _04001064;


_04001004:	// 4001004: <20010fc0>	ADDI      AT = R0 + 0fc0
	state.r[AT] = 0 + 0x0FC0;


_04001008:	// 4001008: <8c220010>	LW        V0 = [AT+0010]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000010) & 0xfff);


_0400100C:	// 400100c: <20030f7f>	ADDI      V1 = R0 + 0f7f
	state.r[V1] = 0 + 0x0F7F;


_04001010:	// 4001010: <20071080>	ADDI      A3 = R0 + 1080
	state.r[A3] = 0 + 0x1080;


_04001014:	// 4001014: <40870000>	MTC0      SP memory address = A3
	DMEM_Address = state.r[A3];


_04001018:	// 4001018: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_0400101C:	// 400101c: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x04001020;
	_GoldenEyeData(0x04001020);
	return;


_04001020:	// 4001020: <40043000>	MFC0      A2 = SP status
	state.r[A0] = 0;


_04001024:	// 4001024: <1480fffe>	BNE       (R0!=A0) --> 1020
	sp_reg_pc = 0x04001024;
	if (state.r[A0] != 0)
	{
		goto _04001020;
	}


_04001028:	// 4001028: <00000000>	NOP       


_0400102C:	// 400102c: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x0400102C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_04001030:	// 4001030: <00000000>	NOP       


_04001034:	// 4001034: <00e00008>	JR        A3
	{
		_u32	temp = ((state.r[A3] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001038:	// 4001038: <40803800>	MTC0      SP semaphore = R0


_0400103C:	// 400103c: <40082000>	MFC0      A0 = DP CMD DMA start
	state.r[T0] = 0;


_04001040:	// 4001040: <31080080>	ANDI      T0 = T0 & 0080
	state.r[T0] = (state.r[T0] & 0x00000080);


_04001044:	// 4001044: <15000002>	BNE       (R0!=T0) --> 1050
	sp_reg_pc = 0x04001044;
	if (state.r[T0] != 0)
	{
		goto _04001050;
	}


_04001048:	// 4001048: <00000000>	NOP       


_0400104C:	// 400104c: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001050:	// 4001050: <40803800>	MTC0      SP semaphore = R0


_04001054:	// 4001054: <34085200>	ORI       T0 = R0 | 0x5200
	state.r[T0] = (0 | 0x00005200);


_04001058:	// 4001058: <40882000>	MTC0      SP status = T0


_0400105C:	// 400105c: <0000000d>	BREAK
	state.halt = 1;
	return;


_04001060:	// 4001060: <00000000>	NOP       


_04001064:	// 4001064: <8c220004>	LW        V0 = [AT+0004]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000004) & 0xfff);


_04001068:	// 4001068: <30420002>	ANDI      V0 = V0 & 0002
	state.r[V0] = (state.r[V0] & 0x00000002);


_0400106C:	// 400106c: <10400007>	BEQ       (R0==V0) --> 108c
	sp_reg_pc = 0x0400106C;
	if (state.r[V0] == 0)
	{
		goto _0400108C;
	}


_04001070:	// 4001070: <00000000>	NOP       


_04001074:	// 4001074: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x04001074;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_04001078:	// 4001078: <00000000>	NOP       


_0400107C:	// 400107c: <40025800>	MFC0      T3 = SP read DMA length
	state.r[V0] = 0;


_04001080:	// 4001080: <20180360>	ADDI      T8 = R0 + 0360
	state.r[T8] = 0 + 0x0360;


_04001084:	// 4001084: <20170f90>	ADDI      S7 = R0 + 0f90
	state.r[S7] = 0 + 0x0F90;


_04001088:	// 4001088: <8c3c0030>	LW        GP = [AT+0030]
	state.r[GP] = (_s32)Load32_DMEM((state.r[AT] + 0x00000030) & 0xfff);


_0400108C:	// 400108c: <8c3b0034>	LW        K1 = [AT+0034]
	state.r[K1] = (_s32)Load32_DMEM((state.r[AT] + 0x00000034) & 0xfff);


_04001090:	// 4001090: <40055800>	MFC0      T3 = SP DMA full
	state.r[A1] = 0;


_04001094:	// 4001094: <30a40001>	ANDI      A0 = A1 & 0001
	state.r[A0] = (state.r[A1] & 0x00000001);


_04001098:	// 4001098: <10800006>	BEQ       (R0==A0) --> 10b4
	sp_reg_pc = 0x04001098;
	if (state.r[A0] == 0)
	{
		state.r[A0] = (state.r[A1] & 0x00000100);
		goto _040010B4;
	}


_0400109C:	// 400109c: <30a40100>	ANDI      A0 = A1 & 0100
	state.r[A0] = (state.r[A1] & 0x00000100);


_040010A0:	// 40010a0: <10800004>	BEQ       (R0==A0) --> 10b4
	sp_reg_pc = 0x040010A0;
	if (state.r[A0] == 0)
	{
		goto _040010B4;
	}


_040010A4:	// 40010a4: <00000000>	NOP       


_040010A8:	// 40010a8: <40045800>	MFC0      T3 = SP status
	state.r[A0] = 0;


_040010AC:	// 40010ac: <30840100>	ANDI      A0 = A0 & 0100
	state.r[A0] = (state.r[A0] & 0x00000100);


_040010B0:	// 40010b0: <1c80fffd>	BGTZ      (R0>0) --> 10a8
	sp_reg_pc = 0x040010B0;
	if((_s32)state.r[A0] > 0)
	{
		goto _040010A8;
	}


_040010B4:	// 40010b4: <00000000>	NOP       


_040010B8:	// 40010b8: <0d000454>	JAL	    04001150
	sp_reg_pc = 0x040010B8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001150;


_040010BC:	// 40010bc: <00000000>	NOP       


_040010C0:	// 40010c0: <2002000f>	ADDI      V0 = R0 + 000f
	state.r[V0] = 0 + 0x000F;


_040010C4:	// 40010c4: <20010320>	ADDI      AT = R0 + 0320
	state.r[AT] = 0 + 0x0320;


_040010C8:	// 40010c8: <ac200000>	SW        [AT+0000] = R0
	Save32_DMEM((_u32)0, (state.r[AT] + 0x00000000) & 0xfff);


_040010CC:	// 40010cc: <1c40fffe>	BGTZ      (R0>0) --> 10c8
	sp_reg_pc = 0x040010CC;
	if((_s32)state.r[V0] > 0)
	{
		state.r[V0] = state.r[V0] + 0xFFFFFFFF;
		goto _040010C8;
	}


_040010D0:	// 40010d0: <2042ffff>	ADDI      V0 = V0 + ffff
	state.r[V0] = state.r[V0] + 0xFFFFFFFF;


_040010D4:	// 40010d4: <40023000>	MFC0      A2 = SP read DMA length
	state.r[V0] = 0;


_040010D8:	// 40010d8: <1440fffe>	BNE       (R0!=V0) --> 10d4
	sp_reg_pc = 0x040010D8;
	if (state.r[V0] != 0)
	{
		state.r[SP] = 0 + 0x0380;
		goto _040010D4;
	}


_040010DC:	// 40010dc: <201d0380>	ADDI      SP = R0 + 0380
	state.r[SP] = 0 + 0x0380;


_040010E0:	// 40010e0: <40803800>	MTC0      SP semaphore = R0


_040010E4:	// 40010e4: <8fba0000>	LW        K0 = [SP+0000]
	// In function: Main_Parser
	//Call the function: Main_Parser
	Main_Parser();
	goto _0400110C;

_040010E8:	// 40010e8: <8fb90004>	LW        T9 = [SP+0004]
	ErrorToCallFunction(0x040010E8);

_040010EC:	// 40010ec: <001a0dc2>	SRL       AT = K0 >> 23
	ErrorToCallFunction(0x040010EC);

_040010F0:	// 40010f0: <302100fe>	ANDI      AT = AT & 00fe
	ErrorToCallFunction(0x040010F0);

_040010F4:	// 40010f4: <239c0008>	ADDI      GP = GP + 0008
	ErrorToCallFunction(0x040010F4);

_040010F8:	// 40010f8: <237bfff8>	ADDI      K1 = K1 + fff8
	ErrorToCallFunction(0x040010F8);

_040010FC:	// 40010fc: <23bd0008>	ADDI      SP = SP + 0008
	ErrorToCallFunction(0x040010FC);

_04001100:	// 4001100: <23defff8>	ADDI      S8 = S8 + fff8
	ErrorToCallFunction(0x04001100);

_04001104:	// 4001104: <00011020>	ADD       V0 = R0+AT
	ErrorToCallFunction(0x04001104);

_04001108:	// 4001108: <84420010>	LH        V0 = [V0+0010]
	ErrorToCallFunction(0x04001108);

_0400110C:	// 400110c: <00400008>	JR        V0
	{
		_u32	temp = ((state.r[V0] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001110:	// 4001110: <00000000>	NOP       


_04001114:	// 4001114: <0000000d>	BREAK
	state.halt = 1;
	return;


_04001118:	// 4001118: <1fc0fff2>	BGTZ      (R0>0) --> 10e4
	sp_reg_pc = 0x04001118;
	if((_s32)state.r[S8] > 0)
	{
		goto _040010E4;
	}


_0400111C:	// 400111c: <00000000>	NOP       


_04001120:	// 4001120: <1b600005>	BLEZ      (R0<=0) --> 1138
	sp_reg_pc = 0x04001120;
	if ((_s32)state.r[K1] <= 0)
	{
		goto _04001138;
	}


_04001124:	// 4001124: <00000000>	NOP       


_04001128:	// 4001128: <0d000454>	JAL	    04001150
	sp_reg_pc = 0x04001128;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001150;


_0400112C:	// 400112c: <00000000>	NOP       


_04001130:	// 4001130: <09000435>	J         040010d4
	goto _040010D4;


_04001134:	// 4001134: <00000000>	NOP       


_04001138:	// 4001138: <34014000>	ORI       AT = R0 | 0x4000
	state.r[AT] = (0 | 0x00004000);


_0400113C:	// 400113c: <40812000>	MTC0      SP status = AT


_04001140:	// 4001140: <0000000d>	BREAK
	state.halt = 1;
	return;


_04001144:	// 4001144: <00000000>	NOP       


_04001148:	// 4001148: <1000ffff>	BEQ       (R0==R0) --> 1148
	sp_reg_pc = 0x04001148;
	if (0 == 0)
	{
		goto _04001148;
	}


_0400114C:	// 400114c: <00000000>	NOP       


_04001150:	// 4001150: <23e50000>	ADDI      A1 = RA + 0000
	state.r[A1] = state.r[RA] + 0x0000;


_04001154:	// 4001154: <001c1020>	ADD       V0 = R0+GP
	state.r[V0] = (0 + state.r[GP]);


_04001158:	// 4001158: <23630000>	ADDI      V1 = K1 + 0000
	state.r[V1] = state.r[K1] + 0x0000;


_0400115C:	// 400115c: <2064fec0>	ADDI      A0 = V1 + fec0
	state.r[A0] = state.r[V1] + 0xFFFFFEC0;


_04001160:	// 4001160: <18800002>	BLEZ      (R0<=0) --> 116c
	sp_reg_pc = 0x04001160;
	if ((_s32)state.r[A0] <= 0)
	{
		state.r[AT] = 0 + 0x0380;
		goto _0400116C;
	}


_04001164:	// 4001164: <20010380>	ADDI      AT = R0 + 0380
	state.r[AT] = 0 + 0x0380;


_04001168:	// 4001168: <20030140>	ADDI      V1 = R0 + 0140
	state.r[V1] = 0 + 0x0140;


_0400116C:	// 400116c: <207e0000>	ADDI      S8 = V1 + 0000
	state.r[S8] = state.r[V1] + 0x0000;


_04001170:	// 4001170: <0d000461>	JAL	    04001184
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;
	sp_reg_pc = 0x04001170;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001184;


_04001174:	// 4001174: <2063ffff>	ADDI      V1 = V1 + ffff
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;


_04001178:	// 4001178: <201d0380>	ADDI      SP = R0 + 0380
	state.r[SP] = 0 + 0x0380;


_0400117C:	// 400117c: <00a00008>	JR        A1
	{
		_u32	temp = ((state.r[A1] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001180:	// 4001180: <00000000>	NOP       


_04001184:	// 4001184: <40043800>	MFC0      A3 = SP status
	state.r[A0] = 0;


_04001188:	// 4001188: <1480fffe>	BNE       (R0!=A0) --> 1184
	sp_reg_pc = 0x04001188;
	if (state.r[A0] != 0)
	{
		goto _04001184;
	}


_0400118C:	// 400118c: <00000000>	NOP       


_04001190:	// 4001190: <40042800>	MFC0      A1 = SP status
	state.r[A0] = 0;


_04001194:	// 4001194: <1480fffe>	BNE       (R0!=A0) --> 1190
	sp_reg_pc = 0x04001194;
	if (state.r[A0] != 0)
	{
		goto _04001190;
	}


_04001198:	// 4001198: <00000000>	NOP       


_0400119C:	// 400119c: <40810000>	MTC0      SP memory address = AT
	DMEM_Address = state.r[AT];


_040011A0:	// 40011a0: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_040011A4:	// 40011a4: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x040011A4;
	DMARead(state.r[V1]);


_040011A8:	// 40011a8: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_040011AC:	// 40011ac: <00000000>	NOP       


_040011B0:	// 40011b0: <40043800>	MFC0      A3 = SP status
	state.r[A0] = 0;


_040011B4:	// 40011b4: <1480fffe>	BNE       (R0!=A0) --> 11b0
	sp_reg_pc = 0x040011B4;
	if (state.r[A0] != 0)
	{
		goto _040011B0;
	}


_040011B8:	// 40011b8: <00000000>	NOP       


_040011BC:	// 40011bc: <40042800>	MFC0      A1 = SP status
	state.r[A0] = 0;


_040011C0:	// 40011c0: <1480fffe>	BNE       (R0!=A0) --> 11bc
	sp_reg_pc = 0x040011C0;
	if (state.r[A0] != 0)
	{
		goto _040011BC;
	}


_040011C4:	// 40011c4: <00000000>	NOP       


_040011C8:	// 40011c8: <40810000>	MTC0      SP memory address = AT
	DMEM_Address = state.r[AT];


_040011CC:	// 40011cc: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_040011D0:	// 40011d0: <40831800>	MTC0      SP write DMA length = V1
	DMAWrite(state.r[V1]);


_040011D4:	// 40011d4: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_040011D8:	// 40011d8: <00000000>	NOP       


_040011DC:	// 40011dc: <3323ffff>	ANDI      V1 = T9 & ffff
	state.r[V1] = (state.r[T9] & 0x0000FFFF);


_040011E0:	// 40011e0: <1060ffcd>	BEQ       (R0==V1) --> 1118
	sp_reg_pc = 0x040011E0;
	if (state.r[V1] == 0)
	{
		state.r[A0] = 0 + 0x05C0;
		goto _04001118;
	}


_040011E4:	// 40011e4: <200405c0>	ADDI      A0 = R0 + 05c0
	state.r[A0] = 0 + 0x05C0;


_040011E8:	// 40011e8: <3342ffff>	ANDI      V0 = K0 & ffff
	state.r[V0] = (state.r[K0] & 0x0000FFFF);


_040011EC:	// 40011ec: <00441020>	ADD       V0 = V0+A0
	state.r[V0] = (state.r[V0] + state.r[A0]);


_040011F0:	// 40011f0: <4a01086c>	VXOR      vec01 = vec01 xor vec01[<none>]
	rsp_cop2_vxor(&state.v[1], &state.v[1], &state.v[1]);


_040011F4:	// 40011f4: <2063fff0>	ADDI      V1 = V1 + fff0
	state.r[V1] = state.r[V1] + 0xFFFFFFF0;


_040011F8:	// 40011f8: <e8411800>	SDV       [V0 + 0x00] = vec01 <00>
	{
		_u32	addr = (0x00000000 + state.r[V0]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[1].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[1].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[1].U32[0x00000003];
		}
	}


_040011FC:	// 40011fc: <e8411801>	SDV       [V0 + 0x04] = vec01 <00>
	{
		_u32	addr = (0x00000008 + state.r[V0]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[1].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[1].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[1].U32[0x00000003];
		}
	}


_04001200:	// 4001200: <20420010>	ADDI      V0 = V0 + 0010
	state.r[V0] = state.r[V0] + 0x0010;


_04001204:	// 4001204: <1c60fffc>	BGTZ      (R0>0) --> 11f8
	sp_reg_pc = 0x04001204;
	if((_s32)state.r[V1] > 0)
	{
		state.r[V1] = state.r[V1] + 0xFFFFFFF0;
		goto _040011F8;
	}


_04001208:	// 4001208: <2063fff0>	ADDI      V1 = V1 + fff0
	state.r[V1] = state.r[V1] + 0xFFFFFFF0;


_0400120C:	// 400120c: <09000446>	J         04001118
	goto _04001118;


_04001210:	// 4001210: <00000000>	NOP       


_04001214:	// 4001214: <97030004>	LHU       V1 = [T8+0004]
	state.r[V1] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000004) & 0xfff);


_04001218:	// 4001218: <1060ffbf>	BEQ       (R0==V1) --> 1118
	sp_reg_pc = 0x04001218;
	if (state.r[V1] == 0)
	{
		state.r[V0] = ((_u32)state.r[T9] << 8);
		goto _04001118;
	}


_0400121C:	// 400121c: <00191200>	SLL       V0 = T9 << 8
	state.r[V0] = ((_u32)state.r[T9] << 8);


_04001220:	// 4001220: <00021202>	SRL       V0 = V0 >> 8
	state.r[V0] = ((_u32)state.r[V0] >> 8);


_04001224:	// 4001224: <00192602>	SRL       A0 = T9 >> 24
	state.r[A0] = ((_u32)state.r[T9] >> 24);


_04001228:	// 4001228: <00042080>	SLL       A0 = A0 << 2
	state.r[A0] = ((_u32)state.r[A0] << 2);


_0400122C:	// 400122c: <8c850320>	LW        A1 = [A0+0320]
	state.r[A1] = (_s32)Load32_DMEM((state.r[A0] + 0x00000320) & 0xfff);


_04001230:	// 4001230: <00451020>	ADD       V0 = V0+A1
	state.r[V0] = (state.r[V0] + state.r[A1]);


_04001234:	// 4001234: <97010000>	LHU       AT = [T8+0000]
	state.r[AT] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000000) & 0xfff);


_04001238:	// 4001238: <0d000461>	JAL	    04001184
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;
	sp_reg_pc = 0x04001238;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001184;


_0400123C:	// 400123c: <2063ffff>	ADDI      V1 = V1 + ffff
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;


_04001240:	// 4001240: <40013000>	MFC0      A2 = SP DRAM DMA address
	state.r[AT] = 0;


_04001244:	// 4001244: <1420fffe>	BNE       (R0!=AT) --> 1240
	sp_reg_pc = 0x04001244;
	if (state.r[AT] != 0)
	{
		goto _04001240;
	}


_04001248:	// 4001248: <00000000>	NOP       


_0400124C:	// 400124c: <09000446>	J         04001118
	goto _04001118;


_04001250:	// 4001250: <40803800>	MTC0      SP semaphore = R0


_04001254:	// 4001254: <97030004>	LHU       V1 = [T8+0004]
	state.r[V1] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000004) & 0xfff);


_04001258:	// 4001258: <1060ffaf>	BEQ       (R0==V1) --> 1118
	sp_reg_pc = 0x04001258;
	if (state.r[V1] == 0)
	{
		state.r[V0] = ((_u32)state.r[T9] << 8);
		goto _04001118;
	}


_0400125C:	// 400125c: <00191200>	SLL       V0 = T9 << 8
	state.r[V0] = ((_u32)state.r[T9] << 8);


_04001260:	// 4001260: <00021202>	SRL       V0 = V0 >> 8
	state.r[V0] = ((_u32)state.r[V0] >> 8);


_04001264:	// 4001264: <00192602>	SRL       A0 = T9 >> 24
	state.r[A0] = ((_u32)state.r[T9] >> 24);


_04001268:	// 4001268: <00042080>	SLL       A0 = A0 << 2
	state.r[A0] = ((_u32)state.r[A0] << 2);


_0400126C:	// 400126c: <8c850320>	LW        A1 = [A0+0320]
	state.r[A1] = (_s32)Load32_DMEM((state.r[A0] + 0x00000320) & 0xfff);


_04001270:	// 4001270: <00451020>	ADD       V0 = V0+A1
	state.r[V0] = (state.r[V0] + state.r[A1]);


_04001274:	// 4001274: <97010002>	LHU       AT = [T8+0002]
	state.r[AT] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000002) & 0xfff);


_04001278:	// 4001278: <0d00046c>	JAL	    040011b0
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;
	sp_reg_pc = 0x04001278;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040011B0;


_0400127C:	// 400127c: <2063ffff>	ADDI      V1 = V1 + ffff
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;


_04001280:	// 4001280: <40013000>	MFC0      A2 = SP DRAM DMA address
	state.r[AT] = 0;


_04001284:	// 4001284: <1420fffe>	BNE       (R0!=AT) --> 1280
	sp_reg_pc = 0x04001284;
	if (state.r[AT] != 0)
	{
		goto _04001280;
	}


_04001288:	// 4001288: <00000000>	NOP       


_0400128C:	// 400128c: <09000446>	J         04001118
	goto _04001118;


_04001290:	// 4001290: <40803800>	MTC0      SP semaphore = R0


_04001294:	// 4001294: <00191200>	SLL       V0 = T9 << 8
	state.r[V0] = ((_u32)state.r[T9] << 8);


_04001298:	// 4001298: <00021202>	SRL       V0 = V0 >> 8
	state.r[V0] = ((_u32)state.r[V0] >> 8);


_0400129C:	// 400129c: <00192602>	SRL       A0 = T9 >> 24
	state.r[A0] = ((_u32)state.r[T9] >> 24);


_040012A0:	// 40012a0: <00042080>	SLL       A0 = A0 << 2
	state.r[A0] = ((_u32)state.r[A0] << 2);


_040012A4:	// 40012a4: <8c850320>	LW        A1 = [A0+0320]
	state.r[A1] = (_s32)Load32_DMEM((state.r[A0] + 0x00000320) & 0xfff);


_040012A8:	// 40012a8: <00451020>	ADD       V0 = V0+A1
	state.r[V0] = (state.r[V0] + state.r[A1]);


_040012AC:	// 40012ac: <200104c0>	ADDI      AT = R0 + 04c0
	state.r[AT] = 0 + 0x04C0;


_040012B0:	// 40012b0: <3343ffff>	ANDI      V1 = K0 & ffff
	state.r[V1] = (state.r[K0] & 0x0000FFFF);


_040012B4:	// 40012b4: <0d000461>	JAL	    04001184
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;
	sp_reg_pc = 0x040012B4;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001184;


_040012B8:	// 40012b8: <2063ffff>	ADDI      V1 = V1 + ffff
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;


_040012BC:	// 40012bc: <40013000>	MFC0      A2 = SP DRAM DMA address
	state.r[AT] = 0;


_040012C0:	// 40012c0: <1420fffe>	BNE       (R0!=AT) --> 12bc
	sp_reg_pc = 0x040012C0;
	if (state.r[AT] != 0)
	{
		goto _040012BC;
	}


_040012C4:	// 40012c4: <00000000>	NOP       


_040012C8:	// 40012c8: <09000446>	J         04001118
	goto _04001118;


_040012CC:	// 40012cc: <40803800>	MTC0      SP semaphore = R0


_040012D0:	// 40012d0: <00191a00>	SLL       V1 = T9 << 8
	state.r[V1] = ((_u32)state.r[T9] << 8);


_040012D4:	// 40012d4: <00031a02>	SRL       V1 = V1 >> 8
	state.r[V1] = ((_u32)state.r[V1] >> 8);


_040012D8:	// 40012d8: <00191602>	SRL       V0 = T9 >> 24
	state.r[V0] = ((_u32)state.r[T9] >> 24);


_040012DC:	// 40012dc: <00021080>	SLL       V0 = V0 << 2
	state.r[V0] = ((_u32)state.r[V0] << 2);


_040012E0:	// 40012e0: <00022020>	ADD       A0 = R0+V0
	state.r[A0] = (0 + state.r[V0]);


_040012E4:	// 40012e4: <09000446>	J         04001118
	Save32_DMEM((_u32)state.r[V1], (state.r[A0] + 0x00000320) & 0xfff);
	goto _04001118;


_040012E8:	// 40012e8: <ac830320>	SW        [A0+0320] = V1
	Save32_DMEM((_u32)state.r[V1], (state.r[A0] + 0x00000320) & 0xfff);


_040012EC:	// 40012ec: <234105c0>	ADDI      AT = K0 + 05c0
	state.r[AT] = state.r[K0] + 0x05C0;


_040012F0:	// 40012f0: <00191402>	SRL       V0 = T9 >> 16
	state.r[V0] = ((_u32)state.r[T9] >> 16);


_040012F4:	// 40012f4: <204205c0>	ADDI      V0 = V0 + 05c0
	state.r[V0] = state.r[V0] + 0x05C0;


_040012F8:	// 40012f8: <001a2402>	SRL       A0 = K0 >> 16
	state.r[A0] = ((_u32)state.r[K0] >> 16);


_040012FC:	// 40012fc: <30840008>	ANDI      A0 = A0 & 0008
	state.r[A0] = (state.r[A0] & 0x00000008);


_04001300:	// 4001300: <1c800005>	BGTZ      (R0>0) --> 1318
	sp_reg_pc = 0x04001300;
	if((_s32)state.r[A0] > 0)
	{
		state.r[V1] = state.r[T9] + 0x05C0;
		goto _04001318;
	}


_04001304:	// 4001304: <232305c0>	ADDI      V1 = T9 + 05c0
	state.r[V1] = state.r[T9] + 0x05C0;


_04001308:	// 4001308: <a7010000>	SH        [T8+0000] = AT
	Save16_DMEM((_u16)state.r[AT], (state.r[T8] + 0x00000000) & 0xfff);


_0400130C:	// 400130c: <a7020002>	SH        [T8+0002] = V0
	Save16_DMEM((_u16)state.r[V0], (state.r[T8] + 0x00000002) & 0xfff);


_04001310:	// 4001310: <09000446>	J         04001118
	Save16_DMEM((_u16)state.r[T9], (state.r[T8] + 0x00000004) & 0xfff);
	goto _04001118;


_04001314:	// 4001314: <a7190004>	SH        [T8+0004] = T9
	Save16_DMEM((_u16)state.r[T9], (state.r[T8] + 0x00000004) & 0xfff);


_04001318:	// 4001318: <a703000e>	SH        [T8+000e] = V1
	Save16_DMEM((_u16)state.r[V1], (state.r[T8] + 0x0000000E) & 0xfff);


_0400131C:	// 400131c: <a701000a>	SH        [T8+000a] = AT
	Save16_DMEM((_u16)state.r[AT], (state.r[T8] + 0x0000000A) & 0xfff);


_04001320:	// 4001320: <09000446>	J         04001118
	Save16_DMEM((_u16)state.r[V0], (state.r[T8] + 0x0000000C) & 0xfff);
	goto _04001118;


_04001324:	// 4001324: <a702000c>	SH        [T8+000c] = V0
	Save16_DMEM((_u16)state.r[V0], (state.r[T8] + 0x0000000C) & 0xfff);


_04001328:	// 4001328: <001a1402>	SRL       V0 = K0 >> 16
	state.r[V0] = ((_u32)state.r[K0] >> 16);


_0400132C:	// 400132c: <30410008>	ANDI      AT = V0 & 0008
	state.r[AT] = (state.r[V0] & 0x00000008);


_04001330:	// 4001330: <10200004>	BEQ       (R0==AT) --> 1344
	sp_reg_pc = 0x04001330;
	if (state.r[AT] == 0)
	{
		state.r[AT] = (state.r[V0] & 0x00000004);
		goto _04001344;
	}


_04001334:	// 4001334: <30410004>	ANDI      AT = V0 & 0004
	state.r[AT] = (state.r[V0] & 0x00000004);


_04001338:	// 4001338: <a71a001c>	SH        [T8+001c] = K0
	Save16_DMEM((_u16)state.r[K0], (state.r[T8] + 0x0000001C) & 0xfff);


_0400133C:	// 400133c: <09000446>	J         04001118
	Save16_DMEM((_u16)state.r[T9], (state.r[T8] + 0x0000001E) & 0xfff);
	goto _04001118;


_04001340:	// 4001340: <a719001e>	SH        [T8+001e] = T9
	Save16_DMEM((_u16)state.r[T9], (state.r[T8] + 0x0000001E) & 0xfff);


_04001344:	// 4001344: <10200007>	BEQ       (R0==AT) --> 1364
	sp_reg_pc = 0x04001344;
	if (state.r[AT] == 0)
	{
		state.r[AT] = (state.r[V0] & 0x00000002);
		goto _04001364;
	}


_04001348:	// 4001348: <30410002>	ANDI      AT = V0 & 0002
	state.r[AT] = (state.r[V0] & 0x00000002);


_0400134C:	// 400134c: <10200003>	BEQ       (R0==AT) --> 135c
	sp_reg_pc = 0x0400134C;
	if (state.r[AT] == 0)
	{
		goto _0400135C;
	}


_04001350:	// 4001350: <00000000>	NOP       


_04001354:	// 4001354: <09000446>	J         04001118
	Save16_DMEM((_u16)state.r[K0], (state.r[T8] + 0x00000006) & 0xfff);
	goto _04001118;


_04001358:	// 4001358: <a71a0006>	SH        [T8+0006] = K0
	Save16_DMEM((_u16)state.r[K0], (state.r[T8] + 0x00000006) & 0xfff);


_0400135C:	// 400135c: <09000446>	J         04001118
	Save16_DMEM((_u16)state.r[K0], (state.r[T8] + 0x00000008) & 0xfff);
	goto _04001118;


_04001360:	// 4001360: <a71a0008>	SH        [T8+0008] = K0
	Save16_DMEM((_u16)state.r[K0], (state.r[T8] + 0x00000008) & 0xfff);


_04001364:	// 4001364: <10200005>	BEQ       (R0==AT) --> 137c
	sp_reg_pc = 0x04001364;
	if (state.r[AT] == 0)
	{
		state.r[AT] = ((_u32)state.r[T9] >> 16);
		goto _0400137C;
	}


_04001368:	// 4001368: <00190c02>	SRL       AT = T9 >> 16
	state.r[AT] = ((_u32)state.r[T9] >> 16);


_0400136C:	// 400136c: <a71a0010>	SH        [T8+0010] = K0
	Save16_DMEM((_u16)state.r[K0], (state.r[T8] + 0x00000010) & 0xfff);


_04001370:	// 4001370: <a7010012>	SH        [T8+0012] = AT
	Save16_DMEM((_u16)state.r[AT], (state.r[T8] + 0x00000012) & 0xfff);


_04001374:	// 4001374: <09000446>	J         04001118
	Save16_DMEM((_u16)state.r[T9], (state.r[T8] + 0x00000014) & 0xfff);
	goto _04001118;


_04001378:	// 4001378: <a7190014>	SH        [T8+0014] = T9
	Save16_DMEM((_u16)state.r[T9], (state.r[T8] + 0x00000014) & 0xfff);


_0400137C:	// 400137c: <a71a0016>	SH        [T8+0016] = K0
	Save16_DMEM((_u16)state.r[K0], (state.r[T8] + 0x00000016) & 0xfff);


_04001380:	// 4001380: <a7010018>	SH        [T8+0018] = AT
	Save16_DMEM((_u16)state.r[AT], (state.r[T8] + 0x00000018) & 0xfff);


_04001384:	// 4001384: <09000446>	J         04001118
	Save16_DMEM((_u16)state.r[T9], (state.r[T8] + 0x0000001A) & 0xfff);
	goto _04001118;


_04001388:	// 4001388: <a719001a>	SH        [T8+001a] = T9
	Save16_DMEM((_u16)state.r[T9], (state.r[T8] + 0x0000001A) & 0xfff);


_0400138C:	// 400138c: <97010004>	LHU       AT = [T8+0004]
	state.r[AT] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000004) & 0xfff);


_04001390:	// 4001390: <97040002>	LHU       A0 = [T8+0002]
	state.r[A0] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000002) & 0xfff);


_04001394:	// 4001394: <1020ff60>	BEQ       (R0==AT) --> 1118
	sp_reg_pc = 0x04001394;
	if (state.r[AT] == 0)
	{
		state.r[V1] = (state.r[T9] & 0x0000FFFF);
		goto _04001118;
	}


_04001398:	// 4001398: <3323ffff>	ANDI      V1 = T9 & ffff
	state.r[V1] = (state.r[T9] & 0x0000FFFF);


_0400139C:	// 400139c: <206305c0>	ADDI      V1 = V1 + 05c0
	state.r[V1] = state.r[V1] + 0x05C0;


_040013A0:	// 40013a0: <00191402>	SRL       V0 = T9 >> 16
	state.r[V0] = ((_u32)state.r[T9] >> 16);


_040013A4:	// 40013a4: <204205c0>	ADDI      V0 = V0 + 05c0
	state.r[V0] = state.r[V0] + 0x05C0;


_040013A8:	// 40013a8: <c8412000>	LQV       vec01 <00> = [V0 + 0x00]
	// In function: Mario13A8_13F4
	//Call the function: Mario13A8_13F4
	Mario13A8_13F4();
	goto _040013F8;

_040013AC:	// 40013ac: <c8622000>	LQV       vec02 <00> = [V1 + 0x00]
	ErrorToCallFunction(0x040013AC);

_040013B0:	// 40013b0: <e8810800>	SSV       [A0 + 0x00] = vec01 <00>
	ErrorToCallFunction(0x040013B0);

_040013B4:	// 40013b4: <e8820801>	SSV       [A0 + 0x02] = vec02 <00>
	ErrorToCallFunction(0x040013B4);

_040013B8:	// 40013b8: <e8810902>	SSV       [A0 + 0x04] = vec01 <02>
	ErrorToCallFunction(0x040013B8);

_040013BC:	// 40013bc: <e8820903>	SSV       [A0 + 0x06] = vec02 <02>
	ErrorToCallFunction(0x040013BC);

_040013C0:	// 40013c0: <e8810a04>	SSV       [A0 + 0x08] = vec01 <04>
	ErrorToCallFunction(0x040013C0);

_040013C4:	// 40013c4: <e8820a05>	SSV       [A0 + 0x0a] = vec02 <04>
	ErrorToCallFunction(0x040013C4);

_040013C8:	// 40013c8: <e8810b06>	SSV       [A0 + 0x0c] = vec01 <06>
	ErrorToCallFunction(0x040013C8);

_040013CC:	// 40013cc: <e8820b07>	SSV       [A0 + 0x0e] = vec02 <06>
	ErrorToCallFunction(0x040013CC);

_040013D0:	// 40013d0: <e8810c08>	SSV       [A0 + 0x10] = vec01 <08>
	ErrorToCallFunction(0x040013D0);

_040013D4:	// 40013d4: <e8820c09>	SSV       [A0 + 0x12] = vec02 <08>
	ErrorToCallFunction(0x040013D4);

_040013D8:	// 40013d8: <e8810d0a>	SSV       [A0 + 0x14] = vec01 <10>
	ErrorToCallFunction(0x040013D8);

_040013DC:	// 40013dc: <e8820d0b>	SSV       [A0 + 0x16] = vec02 <10>
	ErrorToCallFunction(0x040013DC);

_040013E0:	// 40013e0: <e8810e0c>	SSV       [A0 + 0x18] = vec01 <12>
	ErrorToCallFunction(0x040013E0);

_040013E4:	// 40013e4: <e8820e0d>	SSV       [A0 + 0x1a] = vec02 <12>
	ErrorToCallFunction(0x040013E4);

_040013E8:	// 40013e8: <e8810f0e>	SSV       [A0 + 0x1c] = vec01 <14>
	ErrorToCallFunction(0x040013E8);

_040013EC:	// 40013ec: <e8820f0f>	SSV       [A0 + 0x1e] = vec02 <14>
	ErrorToCallFunction(0x040013EC);

_040013F0:	// 40013f0: <2021fff0>	ADDI      AT = AT + fff0
	ErrorToCallFunction(0x040013F0);

_040013F4:	// 40013f4: <20420010>	ADDI      V0 = V0 + 0010
	ErrorToCallFunction(0x040013F4);

_040013F8:	// 40013f8: <20630010>	ADDI      V1 = V1 + 0010
	state.r[V1] = state.r[V1] + 0x0010;


_040013FC:	// 40013fc: <1c20ffea>	BGTZ      (R0>0) --> 13a8
	sp_reg_pc = 0x040013FC;
	if((_s32)state.r[AT] > 0)
	{
		state.r[A0] = state.r[A0] + 0x0020;
		goto _040013A8;
	}


_04001400:	// 4001400: <20840020>	ADDI      A0 = A0 + 0020
	state.r[A0] = state.r[A0] + 0x0020;


_04001404:	// 4001404: <09000446>	J         04001118
	goto _04001118;


_04001408:	// 4001408: <00000000>	NOP       


_0400140C:	// 400140c: <3321ffff>	ANDI      AT = T9 & ffff
	state.r[AT] = (state.r[T9] & 0x0000FFFF);


_04001410:	// 4001410: <1020ff41>	BEQ       (R0==AT) --> 1118
	sp_reg_pc = 0x04001410;
	if (state.r[AT] == 0)
	{
		state.r[V0] = (state.r[K0] & 0x0000FFFF);
		goto _04001118;
	}


_04001414:	// 4001414: <3342ffff>	ANDI      V0 = K0 & ffff
	state.r[V0] = (state.r[K0] & 0x0000FFFF);


_04001418:	// 4001418: <204205c0>	ADDI      V0 = V0 + 05c0
	state.r[V0] = state.r[V0] + 0x05C0;


_0400141C:	// 400141c: <00191c02>	SRL       V1 = T9 >> 16
	state.r[V1] = ((_u32)state.r[T9] >> 16);


_04001420:	// 4001420: <206305c0>	ADDI      V1 = V1 + 05c0
	state.r[V1] = state.r[V1] + 0x05C0;


_04001424:	// 4001424: <c8411800>	LDV       vec01 <00> = [V0 + 0x00]
	// In function: Mario1424_1438
	//Call the function: Mario1424_1438
	Mario1424_1438();
	goto _0400143C;

_04001428:	// 4001428: <c8421801>	LDV       vec02 <00> = [V0 + 0x08]
	ErrorToCallFunction(0x04001428);

_0400142C:	// 400142c: <2021fff0>	ADDI      AT = AT + fff0
	ErrorToCallFunction(0x0400142C);

_04001430:	// 4001430: <20420010>	ADDI      V0 = V0 + 0010
	ErrorToCallFunction(0x04001430);

_04001434:	// 4001434: <e8611800>	SDV       [V1 + 0x00] = vec01 <00>
	ErrorToCallFunction(0x04001434);

_04001438:	// 4001438: <e8621801>	SDV       [V1 + 0x04] = vec02 <00>
	ErrorToCallFunction(0x04001438);

_0400143C:	// 400143c: <1c20fff9>	BGTZ      (R0>0) --> 1424
	sp_reg_pc = 0x0400143C;
	if((_s32)state.r[AT] > 0)
	{
		state.r[V1] = state.r[V1] + 0x0010;
		goto _04001424;
	}


_04001440:	// 4001440: <20630010>	ADDI      V1 = V1 + 0010
	state.r[V1] = state.r[V1] + 0x0010;


_04001444:	// 4001444: <09000446>	J         04001118
	goto _04001118;


_04001448:	// 4001448: <00000000>	NOP       


_0400144C:	// 400144c: <00190a00>	SLL       AT = T9 << 8
	state.r[AT] = ((_u32)state.r[T9] << 8);


_04001450:	// 4001450: <00010a02>	SRL       AT = AT >> 8
	state.r[AT] = ((_u32)state.r[AT] >> 8);


_04001454:	// 4001454: <00191e02>	SRL       V1 = T9 >> 24
	state.r[V1] = ((_u32)state.r[T9] >> 24);


_04001458:	// 4001458: <00031880>	SLL       V1 = V1 << 2
	state.r[V1] = ((_u32)state.r[V1] << 2);


_0400145C:	// 400145c: <8c620320>	LW        V0 = [V1+0320]
	state.r[V0] = (_s32)Load32_DMEM((state.r[V1] + 0x00000320) & 0xfff);


_04001460:	// 4001460: <00220820>	ADD       AT = AT+V0
	state.r[AT] = (state.r[AT] + state.r[V0]);


_04001464:	// 4001464: <af010010>	SW        [T8+0010] = AT
	Save32_DMEM((_u32)state.r[AT], (state.r[T8] + 0x00000010) & 0xfff);


_04001468:	// 4001468: <09000446>	J         04001118
	goto _04001118;


_0400146C:	// 400146c: <00000000>	NOP       


_04001470:	// 4001470: <c81f2000>	LQV       vec31 <00> = [R0 + 0x00]
	{
		_u32 addr = (0x00000000 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[31].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[31].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[31].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[31].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[31].U64[0] = state.v[31].U64[0] & ~temp1;
			state.v[31].U64[1] = state.v[31].U64[1] & ~temp2;
			state.v[31].U64[0] = state.v[31].U64[0] | value1;
			state.v[31].U64[1] = state.v[31].U64[1] | value2;
		}
	}


_04001474:	// 4001474: <4a1bdeec>	VXOR      vec27 = vec27 xor vec27[<none>]
	rsp_cop2_vxor(&state.v[27], &state.v[27], &state.v[27]);


_04001478:	// 4001478: <97150000>	LHU       S5 = [T8+0000]
	state.r[S5] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000000) & 0xfff);


_0400147C:	// 400147c: <4a19ce6c>	VXOR      vec25 = vec25 xor vec25[<none>]
	rsp_cop2_vxor(&state.v[25], &state.v[25], &state.v[25]);


_04001480:	// 4001480: <4a18c62c>	VXOR      vec24 = vec24 xor vec24[<none>]
	rsp_cop2_vxor(&state.v[24], &state.v[24], &state.v[24]);


_04001484:	// 4001484: <22b40001>	ADDI      S4 = S5 + 0001
	state.r[S4] = state.r[S5] + 0x0001;


_04001488:	// 4001488: <97130002>	LHU       S3 = [T8+0002]
	state.r[S3] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000002) & 0xfff);


_0400148C:	// 400148c: <4a0d6b6c>	VXOR      vec13 = vec13 xor vec13[<none>]
	rsp_cop2_vxor(&state.v[13], &state.v[13], &state.v[13]);


_04001490:	// 4001490: <4a0e73ac>	VXOR      vec14 = vec14 xor vec14[<none>]
	rsp_cop2_vxor(&state.v[14], &state.v[14], &state.v[14]);


_04001494:	// 4001494: <97120004>	LHU       S2 = [T8+0004]
	state.r[S2] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000004) & 0xfff);


_04001498:	// 4001498: <4a0f7bec>	VXOR      vec15 = vec15 xor vec15[<none>]
	rsp_cop2_vxor(&state.v[15], &state.v[15], &state.v[15]);


_0400149C:	// 400149c: <3c0100ff>	LUI       AT = 0x00ff0000
	state.r[AT] = 0x00FF0000;


_040014A0:	// 40014a0: <4a10842c>	VXOR      vec16 = vec16 xor vec16[<none>]
	rsp_cop2_vxor(&state.v[16], &state.v[16], &state.v[16]);


_040014A4:	// 40014a4: <3421ffff>	ORI       AT = AT | 0xffff
	state.r[AT] = (state.r[AT] | 0x0000FFFF);


_040014A8:	// 40014a8: <4a118c6c>	VXOR      vec17 = vec17 xor vec17[<none>]
	rsp_cop2_vxor(&state.v[17], &state.v[17], &state.v[17]);


_040014AC:	// 40014ac: <03218824>	AND       S1 = T9 & AT
	state.r[S1] = (state.r[T9] & state.r[AT]);


_040014B0:	// 40014b0: <4a1294ac>	VXOR      vec18 = vec18 xor vec18[<none>]
	rsp_cop2_vxor(&state.v[18], &state.v[18], &state.v[18]);


_040014B4:	// 40014b4: <00191602>	SRL       V0 = T9 >> 24
	state.r[V0] = ((_u32)state.r[T9] >> 24);


_040014B8:	// 40014b8: <4a139cec>	VXOR      vec19 = vec19 xor vec19[<none>]
	rsp_cop2_vxor(&state.v[19], &state.v[19], &state.v[19]);


_040014BC:	// 40014bc: <00021080>	SLL       V0 = V0 << 2
	state.r[V0] = ((_u32)state.r[V0] << 2);


_040014C0:	// 40014c0: <8c430320>	LW        V1 = [V0+0320]
	state.r[V1] = (_s32)Load32_DMEM((state.r[V0] + 0x00000320) & 0xfff);


_040014C4:	// 40014c4: <02238820>	ADD       S1 = S1+V1
	state.r[S1] = (state.r[S1] + state.r[V1]);


_040014C8:	// 40014c8: <ea7b2000>	SQV       [S3 + 0x00] = vec27 <00>
	{
		_u32    addr = (0x00000000 + state.r[S3]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[27].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[27].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[27].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[27].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[27].U64[0] & temp1);
			value2 |= (state.v[27].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_040014CC:	// 40014cc: <ea7b2001>	SQV       [S3 + 0x10] = vec27 <00>
	{
		_u32    addr = (0x00000010 + state.r[S3]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[27].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[27].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[27].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[27].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[27].U64[0] & temp1);
			value2 |= (state.v[27].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_040014D0:	// 40014d0: <001a0c02>	SRL       AT = K0 >> 16
	state.r[AT] = ((_u32)state.r[K0] >> 16);


_040014D4:	// 40014d4: <30210001>	ANDI      AT = AT & 0001
	state.r[AT] = (state.r[AT] & 0x00000001);


_040014D8:	// 40014d8: <1c20000c>	BGTZ      (R0>0) --> 150c
	sp_reg_pc = 0x040014D8;
	if((_s32)state.r[AT] > 0)
	{
		state.r[AT] = ((_u32)state.r[K0] >> 16);
		goto _0400150C;
	}


_040014DC:	// 40014dc: <001a0c02>	SRL       AT = K0 >> 16
	state.r[AT] = ((_u32)state.r[K0] >> 16);


_040014E0:	// 40014e0: <30210002>	ANDI      AT = AT & 0002
	state.r[AT] = (state.r[AT] & 0x00000002);


_040014E4:	// 40014e4: <10010002>	BEQ       (AT==R0) --> 14f0
	sp_reg_pc = 0x040014E4;
	if (0 == state.r[AT])
	{
		state.r[V0] = state.r[S1] + 0x0000;
		goto _040014F0;
	}


_040014E8:	// 40014e8: <22220000>	ADDI      V0 = S1 + 0000
	state.r[V0] = state.r[S1] + 0x0000;


_040014EC:	// 40014ec: <8f020010>	LW        V0 = [T8+0010]
	state.r[V0] = (_s32)Load32_DMEM((state.r[T8] + 0x00000010) & 0xfff);


_040014F0:	// 40014f0: <22610000>	ADDI      AT = S3 + 0000
	state.r[AT] = state.r[S3] + 0x0000;


_040014F4:	// 40014f4: <0d000461>	JAL	    04001184
	state.r[V1] = 0 + 0x001F;
	sp_reg_pc = 0x040014F4;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001184;


_040014F8:	// 40014f8: <2003001f>	ADDI      V1 = R0 + 001f
	state.r[V1] = 0 + 0x001F;


_040014FC:	// 40014fc: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001500:	// 4001500: <14a0fffe>	BNE       (R0!=A1) --> 14fc
	sp_reg_pc = 0x04001500;
	if (state.r[A1] != 0)
	{
		goto _040014FC;
	}


_04001504:	// 4001504: <00000000>	NOP       


_04001508:	// 4001508: <40803800>	MTC0      SP semaphore = R0


_0400150C:	// 400150c: <20100030>	ADDI      S0 = R0 + 0030
	state.r[S0] = 0 + 0x0030;


_04001510:	// 4001510: <200f04c0>	ADDI      T7 = R0 + 04c0
	state.r[T7] = 0 + 0x04C0;


_04001514:	// 4001514: <ca191800>	LDV       vec25 <00> = [S0 + 0x00]
	rsp_ldv_compiler((state.r[S0] & 0xFFF), 25, 8);


_04001518:	// 4001518: <ca181c00>	LDV       vec24 <08> = [S0 + 0x00]
	rsp_ldv_compiler((state.r[S0] & 0xFFF), 24, 0);


_0400151C:	// 400151c: <ca171801>	LDV       vec23 <00> = [S0 + 0x08]
	rsp_ldv_compiler((state.r[S0] + 0x00000008) & 0xFFF, 23, 8);


_04001520:	// 4001520: <ca171c01>	LDV       vec23 <08> = [S0 + 0x08]
	rsp_ldv_compiler((state.r[S0] + 0x00000008) & 0xFFF, 23, 0);


_04001524:	// 4001524: <ca7b2001>	LQV       vec27 <00> = [S3 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[S3]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
			state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
			state.v[27].U64[0] = state.v[27].U64[0] | value1;
			state.v[27].U64[1] = state.v[27].U64[1] | value2;
		}
	}


_04001528:	// 4001528: <22730020>	ADDI      S3 = S3 + 0020
	state.r[S3] = state.r[S3] + 0x0020;


_0400152C:	// 400152c: <1240006e>	BEQ       (R0==S2) --> 16e8
	sp_reg_pc = 0x0400152C;
	if (state.r[S2] == 0)
	{
		rsp_ldv_compiler((state.r[S4] & 0xFFF), 1, 8);
		goto _040016E8;
	}


_04001530:	// 4001530: <ca811800>	LDV       vec01 <00> = [S4 + 0x00]
	rsp_ldv_compiler((state.r[S4] & 0xFFF), 1, 8);


_04001534:	// 4001534: <92a10000>	LBU       AT = [S5+0000]
	state.r[AT] = (_s32)(_u8)pDMEM[((state.r[S5] + 0x00000000) & 0xfff) ^ 3];


_04001538:	// 4001538: <302b000f>	ANDI      T3 = AT & 000f
	state.r[T3] = (state.r[AT] & 0x0000000F);


_0400153C:	// 400153c: <000b5940>	SLL       T3 = T3 << 5
	state.r[T3] = ((_u32)state.r[T3] << 5);


_04001540:	// 4001540: <4b01c8e8>	VAND      vec03 = vec25 and vec01[0]
	rsp_cop2_vand_element(&state.v[3], &state.v[25], &state.v[1].U16[7]);


_04001544:	// 4001544: <016f6820>	ADD       T5 = T3+T7
	state.r[T5] = (state.r[T3] + state.r[T7]);


_04001548:	// 4001548: <4b21c128>	VAND      vec04 = vec24 and vec01[1]
	rsp_cop2_vand_element(&state.v[4], &state.v[24], &state.v[1].U16[6]);


_0400154C:	// 400154c: <00017102>	SRL       T6 = AT >> 4
	state.r[T6] = ((_u32)state.r[AT] >> 4);


_04001550:	// 4001550: <4b41c968>	VAND      vec05 = vec25 and vec01[2]
	rsp_cop2_vand_element(&state.v[5], &state.v[25], &state.v[1].U16[5]);


_04001554:	// 4001554: <2002000c>	ADDI      V0 = R0 + 000c
	state.r[V0] = 0 + 0x000C;


_04001558:	// 4001558: <4b61c1a8>	VAND      vec06 = vec24 and vec01[3]
	rsp_cop2_vand_element(&state.v[6], &state.v[24], &state.v[1].U16[4]);


_0400155C:	// 400155c: <004e7022>	SUB       T6 = V0-T6
	state.r[T6] = (state.r[V0] - state.r[T6]);


_04001560:	// 4001560: <21c2ffff>	ADDI      V0 = T6 + ffff
	state.r[V0] = state.r[T6] + 0xFFFFFFFF;


_04001564:	// 4001564: <20030001>	ADDI      V1 = R0 + 0001
	state.r[V1] = 0 + 0x0001;


_04001568:	// 4001568: <00031bc0>	SLL       V1 = V1 << 15
	state.r[V1] = ((_u32)state.r[V1] << 15);


_0400156C:	// 400156c: <00432006>	SRLV      V1 = A0 >> V0
	state.r[A0] = ((_u32)state.r[V1] >> (state.r[V0] & 0x1F));


_04001570:	// 4001570: <4884b000>	MTC2      vec22 <00> = A0
	state.v[22].U16[7] = (_u16)state.r[A0];


_04001574:	// 4001574: <c9b52000>	LQV       vec21 <00> = [T5 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[T5]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[21].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[21].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[21].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[21].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[21].U64[0] = state.v[21].U64[0] & ~temp1;
			state.v[21].U64[1] = state.v[21].U64[1] & ~temp2;
			state.v[21].U64[0] = state.v[21].U64[0] | value1;
			state.v[21].U64[1] = state.v[21].U64[1] | value2;
		}
	}


_04001578:	// 4001578: <c9b42001>	LQV       vec20 <00> = [T5 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[T5]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[20].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[20].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[20].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[20].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[20].U64[0] = state.v[20].U64[0] & ~temp1;
			state.v[20].U64[1] = state.v[20].U64[1] & ~temp2;
			state.v[20].U64[0] = state.v[20].U64[0] | value1;
			state.v[20].U64[1] = state.v[20].U64[1] | value2;
		}
	}


_0400157C:	// 400157c: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_04001580:	// 4001580: <c9b32802>	LRV       vec19 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[19].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001584:	// 4001584: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_04001588:	// 4001588: <c9b22802>	LRV       vec18 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[18].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_0400158C:	// 400158c: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_04001590:	// 4001590: <c9b12802>	LRV       vec17 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[17].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001594:	// 4001594: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_04001598:	// 4001598: <c9b02802>	LRV       vec16 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[16].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_0400159C:	// 400159c: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_040015A0:	// 40015a0: <c9af2802>	LRV       vec15 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[15].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040015A4:	// 40015a4: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_040015A8:	// 40015a8: <c9ae2802>	LRV       vec14 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[14].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040015AC:	// 40015ac: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_040015B0:	// 40015b0: <c9ad2802>	LRV       vec13 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[13].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040015B4:	// 40015b4: <22940009>	ADDI      S4 = S4 + 0009
	state.r[S4] = state.r[S4] + 0x0009;


_040015B8:	// 40015b8: <4a171f86>	VMUDN     vec30 = ( acc = vec03 * vec23[<none>]      ) >> 16
	// In function: Mario15B8_16DC
	//Call the function: Mario15B8_16DC
	Mario15B8_16DC();
	goto _040016E0;

_040015BC:	// 40015bc: <22b50009>	ADDI      S5 = S5 + 0009
	ErrorToCallFunction(0x040015BC);

_040015C0:	// 40015c0: <4a17278e>	VMADN     vec30 = ( acc+= vec04 * vec23[<none>] )
	ErrorToCallFunction(0x040015C0);

_040015C4:	// 40015c4: <ca811800>	LDV       vec01 <00> = [S4 + 0x00]
	ErrorToCallFunction(0x040015C4);

_040015C8:	// 40015c8: <4a172f46>	VMUDN     vec29 = ( acc = vec05 * vec23[<none>]      ) >> 16
	ErrorToCallFunction(0x040015C8);

_040015CC:	// 40015cc: <92a10000>	LBU       AT = [S5+0000]
	ErrorToCallFunction(0x040015CC);

_040015D0:	// 40015d0: <4a17374e>	VMADN     vec29 = ( acc+= vec06 * vec23[<none>] )
	ErrorToCallFunction(0x040015D0);

_040015D4:	// 40015d4: <19c00003>	BLEZ      (R0<=0) --> 15e4
	ErrorToCallFunction(0x040015D4);

_040015D8:	// 40015d8: <302b000f>	ANDI      T3 = AT & 000f
	ErrorToCallFunction(0x040015D8);

_040015DC:	// 40015dc: <4b16f785>	VMUDM     vec30 = ( acc = vec30 * vec22[0] ) >> 16
	ErrorToCallFunction(0x040015DC);

_040015E0:	// 40015e0: <4b16ef45>	VMUDM     vec29 = ( acc = vec29 * vec22[0] ) >> 16
	ErrorToCallFunction(0x040015E0);

_040015E4:	// 40015e4: <000b5940>	SLL       T3 = T3 << 5
	ErrorToCallFunction(0x040015E4);

_040015E8:	// 40015e8: <4b01c8e8>	VAND      vec03 = vec25 and vec01[0]
	ErrorToCallFunction(0x040015E8);

_040015EC:	// 40015ec: <016f6820>	ADD       T5 = T3+T7
	ErrorToCallFunction(0x040015EC);

_040015F0:	// 40015f0: <4b21c128>	VAND      vec04 = vec24 and vec01[1]
	ErrorToCallFunction(0x040015F0);

_040015F4:	// 40015f4: <4b41c968>	VAND      vec05 = vec25 and vec01[2]
	ErrorToCallFunction(0x040015F4);

_040015F8:	// 40015f8: <4b61c1a8>	VAND      vec06 = vec24 and vec01[3]
	ErrorToCallFunction(0x040015F8);

_040015FC:	// 40015fc: <00017102>	SRL       T6 = AT >> 4
	ErrorToCallFunction(0x040015FC);

_04001600:	// 4001600: <4bdba887>	VMUDH     vec02 = ( acc = (vec21 * vec27[6]) << 16) >> 16
	ErrorToCallFunction(0x04001600);

_04001604:	// 4001604: <2002000c>	ADDI      V0 = R0 + 000c
	ErrorToCallFunction(0x04001604);

_04001608:	// 4001608: <4bfba08f>	VMADH     vec02 = ( acc+= (vec20 * vec27[7]) << 16) >> 16
	ErrorToCallFunction(0x04001608);

_0400160C:	// 400160c: <004e7022>	SUB       T6 = V0-T6
	ErrorToCallFunction(0x0400160C);

_04001610:	// 4001610: <4b1e988f>	VMADH     vec02 = ( acc+= (vec19 * vec30[0]) << 16) >> 16
	ErrorToCallFunction(0x04001610);

_04001614:	// 4001614: <21c2ffff>	ADDI      V0 = T6 + ffff
	ErrorToCallFunction(0x04001614);

_04001618:	// 4001618: <4b3e908f>	VMADH     vec02 = ( acc+= (vec18 * vec30[1]) << 16) >> 16
	ErrorToCallFunction(0x04001618);

_0400161C:	// 400161c: <20030001>	ADDI      V1 = R0 + 0001
	ErrorToCallFunction(0x0400161C);

_04001620:	// 4001620: <4b5e888f>	VMADH     vec02 = ( acc+= (vec17 * vec30[2]) << 16) >> 16
	ErrorToCallFunction(0x04001620);

_04001624:	// 4001624: <00031bc0>	SLL       V1 = V1 << 15
	ErrorToCallFunction(0x04001624);

_04001628:	// 4001628: <4b7e808f>	VMADH     vec02 = ( acc+= (vec16 * vec30[3]) << 16) >> 16
	ErrorToCallFunction(0x04001628);

_0400162C:	// 400162c: <00432006>	SRLV      V1 = A0 >> V0
	ErrorToCallFunction(0x0400162C);

_04001630:	// 4001630: <4b9e7f0f>	VMADH     vec28 = ( acc+= (vec15 * vec30[4]) << 16) >> 16
	ErrorToCallFunction(0x04001630);

_04001634:	// 4001634: <4884b000>	MTC2      vec22 <00> = A0
	ErrorToCallFunction(0x04001634);

_04001638:	// 4001638: <4bbe708f>	VMADH     vec02 = ( acc+= (vec14 * vec30[5]) << 16) >> 16
	ErrorToCallFunction(0x04001638);

_0400163C:	// 400163c: <4bde688f>	VMADH     vec02 = ( acc+= (vec13 * vec30[6]) << 16) >> 16
	ErrorToCallFunction(0x0400163C);

_04001640:	// 4001640: <4bbff08f>	VMADH     vec02 = ( acc+= (vec30 * vec31[5]) << 16) >> 16
	ErrorToCallFunction(0x04001640);

_04001644:	// 4001644: <4b3c3e9d>	VSAW $v26, $v7, $v28[[1]]
	ErrorToCallFunction(0x04001644);

_04001648:	// 4001648: <4b1c3f1d>	VSAW $v28, $v7, $v28[[0]]
	ErrorToCallFunction(0x04001648);

_0400164C:	// 400164c: <4b9fd086>	VMUDN     vec02 = ( acc = vec26 * vec31[4]      ) >> 16
	ErrorToCallFunction(0x0400164C);

_04001650:	// 4001650: <4b9fe70f>	VMADH     vec28 = ( acc+= (vec28 * vec31[4]) << 16) >> 16
	ErrorToCallFunction(0x04001650);

_04001654:	// 4001654: <4b1d9887>	VMUDH     vec02 = ( acc = (vec19 * vec29[0]) << 16) >> 16
	ErrorToCallFunction(0x04001654);

_04001658:	// 4001658: <21acfffe>	ADDI      T4 = T5 + fffe
	ErrorToCallFunction(0x04001658);

_0400165C:	// 400165c: <4b3d908f>	VMADH     vec02 = ( acc+= (vec18 * vec29[1]) << 16) >> 16
	ErrorToCallFunction(0x0400165C);

_04001660:	// 4001660: <c9932802>	LRV       vec19 <00> = [T4 + 0x20]
	ErrorToCallFunction(0x04001660);

_04001664:	// 4001664: <4b5d888f>	VMADH     vec02 = ( acc+= (vec17 * vec29[2]) << 16) >> 16
	ErrorToCallFunction(0x04001664);

_04001668:	// 4001668: <218cfffe>	ADDI      T4 = T4 + fffe
	ErrorToCallFunction(0x04001668);

_0400166C:	// 400166c: <4b7d808f>	VMADH     vec02 = ( acc+= (vec16 * vec29[3]) << 16) >> 16
	ErrorToCallFunction(0x0400166C);

_04001670:	// 4001670: <c9922802>	LRV       vec18 <00> = [T4 + 0x20]
	ErrorToCallFunction(0x04001670);

_04001674:	// 4001674: <4b9d788f>	VMADH     vec02 = ( acc+= (vec15 * vec29[4]) << 16) >> 16
	ErrorToCallFunction(0x04001674);

_04001678:	// 4001678: <218cfffe>	ADDI      T4 = T4 + fffe
	ErrorToCallFunction(0x04001678);

_0400167C:	// 400167c: <4bbd708f>	VMADH     vec02 = ( acc+= (vec14 * vec29[5]) << 16) >> 16
	ErrorToCallFunction(0x0400167C);

_04001680:	// 4001680: <c9912802>	LRV       vec17 <00> = [T4 + 0x20]
	ErrorToCallFunction(0x04001680);

_04001684:	// 4001684: <4bdd688f>	VMADH     vec02 = ( acc+= (vec13 * vec29[6]) << 16) >> 16
	ErrorToCallFunction(0x04001684);

_04001688:	// 4001688: <218cfffe>	ADDI      T4 = T4 + fffe
	ErrorToCallFunction(0x04001688);

_0400168C:	// 400168c: <4bbfe88f>	VMADH     vec02 = ( acc+= (vec29 * vec31[5]) << 16) >> 16
	ErrorToCallFunction(0x0400168C);

_04001690:	// 4001690: <c9902802>	LRV       vec16 <00> = [T4 + 0x20]
	ErrorToCallFunction(0x04001690);

_04001694:	// 4001694: <4bdca88f>	VMADH     vec02 = ( acc+= (vec21 * vec28[6]) << 16) >> 16
	ErrorToCallFunction(0x04001694);

_04001698:	// 4001698: <218cfffe>	ADDI      T4 = T4 + fffe
	ErrorToCallFunction(0x04001698);

_0400169C:	// 400169c: <4bfca08f>	VMADH     vec02 = ( acc+= (vec20 * vec28[7]) << 16) >> 16
	ErrorToCallFunction(0x0400169C);

_040016A0:	// 40016a0: <c98f2802>	LRV       vec15 <00> = [T4 + 0x20]
	ErrorToCallFunction(0x040016A0);

_040016A4:	// 40016a4: <4b3b3e9d>	VSAW $v26, $v7, $v27[[1]]
	ErrorToCallFunction(0x040016A4);

_040016A8:	// 40016a8: <218cfffe>	ADDI      T4 = T4 + fffe
	ErrorToCallFunction(0x040016A8);

_040016AC:	// 40016ac: <4b1b3edd>	VSAW $v27, $v7, $v27[[0]]
	ErrorToCallFunction(0x040016AC);

_040016B0:	// 40016b0: <c98e2802>	LRV       vec14 <00> = [T4 + 0x20]
	ErrorToCallFunction(0x040016B0);

_040016B4:	// 40016b4: <218cfffe>	ADDI      T4 = T4 + fffe
	ErrorToCallFunction(0x040016B4);

_040016B8:	// 40016b8: <c98d2802>	LRV       vec13 <00> = [T4 + 0x20]
	ErrorToCallFunction(0x040016B8);

_040016BC:	// 40016bc: <c9b52000>	LQV       vec21 <00> = [T5 + 0x00]
	ErrorToCallFunction(0x040016BC);

_040016C0:	// 40016c0: <4b9fd086>	VMUDN     vec02 = ( acc = vec26 * vec31[4]      ) >> 16
	ErrorToCallFunction(0x040016C0);

_040016C4:	// 40016c4: <c9b42001>	LQV       vec20 <00> = [T5 + 0x10]
	ErrorToCallFunction(0x040016C4);

_040016C8:	// 40016c8: <4b9fdecf>	VMADH     vec27 = ( acc+= (vec27 * vec31[4]) << 16) >> 16
	ErrorToCallFunction(0x040016C8);

_040016CC:	// 40016cc: <2252ffe0>	ADDI      S2 = S2 + ffe0
	ErrorToCallFunction(0x040016CC);

_040016D0:	// 40016d0: <ea7c1800>	SDV       [S3 + 0x00] = vec28 <00>
	ErrorToCallFunction(0x040016D0);

_040016D4:	// 40016d4: <ea7c1c01>	SDV       [S3 + 0x04] = vec28 <08>
	ErrorToCallFunction(0x040016D4);

_040016D8:	// 40016d8: <ea7b1802>	SDV       [S3 + 0x08] = vec27 <00>
	ErrorToCallFunction(0x040016D8);

_040016DC:	// 40016dc: <ea7b1c03>	SDV       [S3 + 0x0c] = vec27 <08>
	ErrorToCallFunction(0x040016DC);

_040016E0:	// 40016e0: <1e40ffb4>	BGTZ      (R0>0) --> 15b4
	sp_reg_pc = 0x040016E0;
	if((_s32)state.r[S2] > 0)
	{
		state.r[S3] = state.r[S3] + 0x0020;
		goto _040015B4;
	}


_040016E4:	// 40016e4: <22730020>	ADDI      S3 = S3 + 0020
	state.r[S3] = state.r[S3] + 0x0020;


_040016E8:	// 40016e8: <2261ffe0>	ADDI      AT = S3 + ffe0
	state.r[AT] = state.r[S3] + 0xFFFFFFE0;


_040016EC:	// 40016ec: <22220000>	ADDI      V0 = S1 + 0000
	state.r[V0] = state.r[S1] + 0x0000;


_040016F0:	// 40016f0: <0d00046c>	JAL	    040011b0
	state.r[V1] = 0 + 0x001F;
	sp_reg_pc = 0x040016F0;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040011B0;


_040016F4:	// 40016f4: <2003001f>	ADDI      V1 = R0 + 001f
	state.r[V1] = 0 + 0x001F;


_040016F8:	// 40016f8: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_040016FC:	// 40016fc: <14a0fffe>	BNE       (R0!=A1) --> 16f8
	sp_reg_pc = 0x040016FC;
	if (state.r[A1] != 0)
	{
		goto _040016F8;
	}


_04001700:	// 4001700: <00000000>	NOP       


_04001704:	// 4001704: <09000446>	J         04001118
	goto _04001118;


_04001708:	// 4001708: <40803800>	MTC0      SP semaphore = R0


_0400170C:	// 400170c: <c81f2000>	LQV       vec31 <00> = [R0 + 0x00]
	{
		_u32 addr = (0x00000000 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[31].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[31].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[31].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[31].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[31].U64[0] = state.v[31].U64[0] & ~temp1;
			state.v[31].U64[1] = state.v[31].U64[1] & ~temp2;
			state.v[31].U64[0] = state.v[31].U64[0] | value1;
			state.v[31].U64[1] = state.v[31].U64[1] | value2;
		}
	}


_04001710:	// 4001710: <4a1ce72c>	VXOR      vec28 = vec28 xor vec28[<none>]
	rsp_cop2_vxor(&state.v[28], &state.v[28], &state.v[28]);


_04001714:	// 4001714: <97150000>	LHU       S5 = [T8+0000]
	state.r[S5] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000000) & 0xfff);


_04001718:	// 4001718: <4a118c6c>	VXOR      vec17 = vec17 xor vec17[<none>]
	rsp_cop2_vxor(&state.v[17], &state.v[17], &state.v[17]);


_0400171C:	// 400171c: <97140002>	LHU       S4 = [T8+0002]
	state.r[S4] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000002) & 0xfff);


_04001720:	// 4001720: <4a1294ac>	VXOR      vec18 = vec18 xor vec18[<none>]
	rsp_cop2_vxor(&state.v[18], &state.v[18], &state.v[18]);


_04001724:	// 4001724: <97130004>	LHU       S3 = [T8+0004]
	state.r[S3] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000004) & 0xfff);


_04001728:	// 4001728: <4a139cec>	VXOR      vec19 = vec19 xor vec19[<none>]
	rsp_cop2_vxor(&state.v[19], &state.v[19], &state.v[19]);


_0400172C:	// 400172c: <12600051>	BEQ       (R0==S3) --> 1874
	sp_reg_pc = 0x0400172C;
	if (state.r[S3] == 0)
	{
		state.r[T6] = (state.r[K0] & 0x0000FFFF);
		goto _04001874;
	}


_04001730:	// 4001730: <334effff>	ANDI      T6 = K0 & ffff
	state.r[T6] = (state.r[K0] & 0x0000FFFF);


_04001734:	// 4001734: <488efd00>	MTC2      vec31 <10> = T6
	state.v[31].U16[2] = (_u16)state.r[T6];


_04001738:	// 4001738: <000e7080>	SLL       T6 = T6 << 2
	state.r[T6] = ((_u32)state.r[T6] << 2);


_0400173C:	// 400173c: <488e8000>	MTC2      vec16 <00> = T6
	state.v[16].U16[7] = (_u16)state.r[T6];


_04001740:	// 4001740: <3c0100ff>	LUI       AT = 0x00ff0000
	state.r[AT] = 0x00FF0000;


_04001744:	// 4001744: <4a14a52c>	VXOR      vec20 = vec20 xor vec20[<none>]
	rsp_cop2_vxor(&state.v[20], &state.v[20], &state.v[20]);


_04001748:	// 4001748: <3421ffff>	ORI       AT = AT | 0xffff
	state.r[AT] = (state.r[AT] | 0x0000FFFF);


_0400174C:	// 400174c: <4a15ad6c>	VXOR      vec21 = vec21 xor vec21[<none>]
	rsp_cop2_vxor(&state.v[21], &state.v[21], &state.v[21]);


_04001750:	// 4001750: <03219024>	AND       S2 = T9 & AT
	state.r[S2] = (state.r[T9] & state.r[AT]);


_04001754:	// 4001754: <4a16b5ac>	VXOR      vec22 = vec22 xor vec22[<none>]
	rsp_cop2_vxor(&state.v[22], &state.v[22], &state.v[22]);


_04001758:	// 4001758: <00191602>	SRL       V0 = T9 >> 24
	state.r[V0] = ((_u32)state.r[T9] >> 24);


_0400175C:	// 400175c: <4a17bdec>	VXOR      vec23 = vec23 xor vec23[<none>]
	rsp_cop2_vxor(&state.v[23], &state.v[23], &state.v[23]);


_04001760:	// 4001760: <00021080>	SLL       V0 = V0 << 2
	state.r[V0] = ((_u32)state.r[V0] << 2);


_04001764:	// 4001764: <8c430320>	LW        V1 = [V0+0320]
	state.r[V1] = (_s32)Load32_DMEM((state.r[V0] + 0x00000320) & 0xfff);


_04001768:	// 4001768: <02439020>	ADD       S2 = S2+V1
	state.r[S2] = (state.r[S2] + state.r[V1]);


_0400176C:	// 400176c: <eafc1000>	SLV       [S7 + 0x00] = vec28 <00>
	Save32_DMEM (state.v[28].U32[3], 0x00000000 + state.r[S7]);


_04001770:	// 4001770: <001a0c02>	SRL       AT = K0 >> 16
	state.r[AT] = ((_u32)state.r[K0] >> 16);


_04001774:	// 4001774: <30210001>	ANDI      AT = AT & 0001
	state.r[AT] = (state.r[AT] & 0x00000001);


_04001778:	// 4001778: <1c200009>	BGTZ      (R0>0) --> 17a0
	sp_reg_pc = 0x04001778;
	if((_s32)state.r[AT] > 0)
	{
		goto _040017A0;
	}


_0400177C:	// 400177c: <00000000>	NOP       


_04001780:	// 4001780: <22e10000>	ADDI      AT = S7 + 0000
	state.r[AT] = state.r[S7] + 0x0000;


_04001784:	// 4001784: <22420000>	ADDI      V0 = S2 + 0000
	state.r[V0] = state.r[S2] + 0x0000;


_04001788:	// 4001788: <0d000461>	JAL	    04001184
	state.r[V1] = 0 + 0x0007;
	sp_reg_pc = 0x04001788;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001184;


_0400178C:	// 400178c: <20030007>	ADDI      V1 = R0 + 0007
	state.r[V1] = 0 + 0x0007;


_04001790:	// 4001790: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001794:	// 4001794: <14a0fffe>	BNE       (R0!=A1) --> 1790
	sp_reg_pc = 0x04001794;
	if (state.r[A1] != 0)
	{
		goto _04001790;
	}


_04001798:	// 4001798: <00000000>	NOP       


_0400179C:	// 400179c: <40803800>	MTC0      SP semaphore = R0


_040017A0:	// 40017a0: <200d04c0>	ADDI      T5 = R0 + 04c0
	state.r[T5] = 0 + 0x04C0;


_040017A4:	// 40017a4: <20010004>	ADDI      AT = R0 + 0004
	state.r[AT] = 0 + 0x0004;


_040017A8:	// 40017a8: <48817000>	MTC2      vec14 <00> = AT
	state.v[14].U16[7] = (_u16)state.r[AT];


_040017AC:	// 40017ac: <c9b82001>	LQV       vec24 <00> = [T5 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[T5]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[24].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[24].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[24].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[24].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[24].U64[0] = state.v[24].U64[0] & ~temp1;
			state.v[24].U64[1] = state.v[24].U64[1] & ~temp2;
			state.v[24].U64[0] = state.v[24].U64[0] | value1;
			state.v[24].U64[1] = state.v[24].U64[1] | value2;
		}
	}


_040017B0:	// 40017b0: <4b10c405>	VMUDM     vec16 = ( acc = vec24 * vec16[0] ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[24*16].U16[0]
			MOVQ mm1, state.v[24*16].U16[4*2]
			PSHUFW mm4, state.v[16*16].U16[7*2], 0
			MOVQ mm2, mm0
			MOVQ mm3, mm1
			PMULHUW mm0, mm4
			PMULHUW mm1, mm4
			PSRAW mm2, 15
			PSRAW mm3, 15
			PMULLW mm2, mm4
			PMULLW mm3, mm4
			PADDW mm0, mm2
			PADDW mm1, mm3
			MOVQ state.v[16*16].U16[0], mm0
			MOVQ state.v[16*16].U16[4*2], mm1
		}
	}


_040017B4:	// 40017b4: <cafc1c00>	LDV       vec28 <08> = [S7 + 0x00]
	rsp_ldv_compiler((state.r[S7] & 0xFFF), 28, 0);


_040017B8:	// 40017b8: <e9b02001>	SQV       [T5 + 0x10] = vec16 <00>
	{
		_u32    addr = (0x00000010 + state.r[T5]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[16].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[16].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[16].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[16].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[16].U64[0] & temp1);
			value2 |= (state.v[16].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_040017BC:	// 40017bc: <c9b92000>	LQV       vec25 <00> = [T5 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[T5]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[25].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[25].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[25].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[25].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[25].U64[0] = state.v[25].U64[0] & ~temp1;
			state.v[25].U64[1] = state.v[25].U64[1] & ~temp2;
			state.v[25].U64[0] = state.v[25].U64[0] | value1;
			state.v[25].U64[1] = state.v[25].U64[1] | value2;
		}
	}


_040017C0:	// 40017c0: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_040017C4:	// 40017c4: <c9b72802>	LRV       vec23 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[23].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040017C8:	// 40017c8: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_040017CC:	// 40017cc: <c9b62802>	LRV       vec22 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[22].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040017D0:	// 40017d0: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_040017D4:	// 40017d4: <c9b52802>	LRV       vec21 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[21].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040017D8:	// 40017d8: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_040017DC:	// 40017dc: <c9b42802>	LRV       vec20 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[20].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040017E0:	// 40017e0: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_040017E4:	// 40017e4: <c9b32802>	LRV       vec19 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[19].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040017E8:	// 40017e8: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_040017EC:	// 40017ec: <c9b22802>	LRV       vec18 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[18].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040017F0:	// 40017f0: <21adfffe>	ADDI      T5 = T5 + fffe
	state.r[T5] = state.r[T5] + 0xFFFFFFFE;


_040017F4:	// 40017f4: <c9b12802>	LRV       vec17 <00> = [T5 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[T5]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[17].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040017F8:	// 40017f8: <cabe1800>	LDV       vec30 <00> = [S5 + 0x00]
	rsp_ldv_compiler((state.r[S5] & 0xFFF), 30, 8);


_040017FC:	// 40017fc: <cabe1c01>	LDV       vec30 <08> = [S5 + 0x08]
	rsp_ldv_compiler((state.r[S5] + 0x00000008) & 0xFFF, 30, 0);


_04001800:	// 4001800: <4bdccc07>	VMUDH     vec16 = ( acc = (vec25 * vec28[6]) << 16) >> 16

	// [start function: GoldenEye1800_184C]

	GoldenEye1800_184C();
	goto _04001850;

_04001804:	// 4001804: <22b50010>	ADDI      S5 = S5 + 0010

_04001808:	// 4001808: <4bfcc40f>	VMADH     vec16 = ( acc+= (vec24 * vec28[7]) << 16) >> 16

_0400180C:	// 400180c: <2273fff0>	ADDI      S3 = S3 + fff0

_04001810:	// 4001810: <4b1ebc0f>	VMADH     vec16 = ( acc+= (vec23 * vec30[0]) << 16) >> 16

_04001814:	// 4001814: <4b3eb40f>	VMADH     vec16 = ( acc+= (vec22 * vec30[1]) << 16) >> 16

_04001818:	// 4001818: <4b5eac0f>	VMADH     vec16 = ( acc+= (vec21 * vec30[2]) << 16) >> 16

_0400181C:	// 400181c: <4b7ea40f>	VMADH     vec16 = ( acc+= (vec20 * vec30[3]) << 16) >> 16

_04001820:	// 4001820: <4b9e9f0f>	VMADH     vec28 = ( acc+= (vec19 * vec30[4]) << 16) >> 16

_04001824:	// 4001824: <4bbe940f>	VMADH     vec16 = ( acc+= (vec18 * vec30[5]) << 16) >> 16

_04001828:	// 4001828: <4bde8c0f>	VMADH     vec16 = ( acc+= (vec17 * vec30[6]) << 16) >> 16

_0400182C:	// 400182c: <4bbff40f>	VMADH     vec16 = ( acc+= (vec30 * vec31[5]) << 16) >> 16

_04001830:	// 4001830: <cabe1800>	LDV       vec30 <00> = [S5 + 0x00]

_04001834:	// 4001834: <4b3c7e9d>	VSAW $v26, $v15, $v28[[1]]

_04001838:	// 4001838: <cabe1c01>	LDV       vec30 <08> = [S5 + 0x08]

_0400183C:	// 400183c: <4b1c7f1d>	VSAW $v28, $v15, $v28[[0]]

_04001840:	// 4001840: <4b0ed406>	VMUDN     vec16 = ( acc = vec26 * vec14[0]      ) >> 16

_04001844:	// 4001844: <4b0ee70f>	VMADH     vec28 = ( acc+= (vec28 * vec14[0]) << 16) >> 16

_04001848:	// 4001848: <ea9c1800>	SDV       [S4 + 0x00] = vec28 <00>

_0400184C:	// 400184c: <ea9c1c01>	SDV       [S4 + 0x04] = vec28 <08>
	ErrorToCallFunction(0x0400184C);

	// [end of function: GoldenEye1800_184C]

_04001850:	// 4001850: <1e60ffeb>	BGTZ      (R0>0) --> 1800
	sp_reg_pc = 0x04001850;
	if((_s32)state.r[S3] > 0)
	{
		state.r[S4] = state.r[S4] + 0x0010;
		goto _04001800;
	}


_04001854:	// 4001854: <22940010>	ADDI      S4 = S4 + 0010
	state.r[S4] = state.r[S4] + 0x0010;


_04001858:	// 4001858: <2281fff8>	ADDI      AT = S4 + fff8
	state.r[AT] = state.r[S4] + 0xFFFFFFF8;


_0400185C:	// 400185c: <22420000>	ADDI      V0 = S2 + 0000
	state.r[V0] = state.r[S2] + 0x0000;


_04001860:	// 4001860: <0d00046c>	JAL	    040011b0
	state.r[V1] = 0 + 0x0007;
	sp_reg_pc = 0x04001860;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040011B0;


_04001864:	// 4001864: <20030007>	ADDI      V1 = R0 + 0007
	state.r[V1] = 0 + 0x0007;


_04001868:	// 4001868: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_0400186C:	// 400186c: <14a0fffe>	BNE       (R0!=A1) --> 1868
	sp_reg_pc = 0x0400186C;
	if (state.r[A1] != 0)
	{
		goto _04001868;
	}


_04001870:	// 4001870: <00000000>	NOP       


_04001874:	// 4001874: <09000446>	J         04001118
	goto _04001118;


_04001878:	// 4001878: <40803800>	MTC0      SP semaphore = R0


_0400187C:	// 400187c: <87080000>	LH        T0 = [T8+0000]
	state.r[T0] = (_s32)(_s16)Load16_DMEM((state.r[T8] + 0x00000000) & 0xfff);


_04001880:	// 4001880: <87130002>	LH        S3 = [T8+0002]
	state.r[S3] = (_s32)(_s16)Load16_DMEM((state.r[T8] + 0x00000002) & 0xfff);


_04001884:	// 4001884: <87120004>	LH        S2 = [T8+0004]
	state.r[S2] = (_s32)(_s16)Load16_DMEM((state.r[T8] + 0x00000004) & 0xfff);


_04001888:	// 4001888: <3c0400ff>	LUI       A0 = 0x00ff0000
	state.r[A0] = 0x00FF0000;


_0400188C:	// 400188c: <3484ffff>	ORI       A0 = A0 | 0xffff
	state.r[A0] = (state.r[A0] | 0x0000FFFF);


_04001890:	// 4001890: <03241024>	AND       V0 = T9 & A0
	state.r[V0] = (state.r[T9] & state.r[A0]);


_04001894:	// 4001894: <00192e02>	SRL       A1 = T9 >> 24
	state.r[A1] = ((_u32)state.r[T9] >> 24);


_04001898:	// 4001898: <00052880>	SLL       A1 = A1 << 2
	state.r[A1] = ((_u32)state.r[A1] << 2);


_0400189C:	// 400189c: <8ca60320>	LW        A2 = [A1+0320]
	state.r[A2] = (_s32)Load32_DMEM((state.r[A1] + 0x00000320) & 0xfff);


_040018A0:	// 40018a0: <00461020>	ADD       V0 = V0+A2
	state.r[V0] = (state.r[V0] + state.r[A2]);


_040018A4:	// 40018a4: <22e10000>	ADDI      AT = S7 + 0000
	state.r[AT] = state.r[S7] + 0x0000;


_040018A8:	// 40018a8: <aee20040>	SW        [S7+0040] = V0
	Save32_DMEM((_u32)state.r[V0], (state.r[S7] + 0x00000040) & 0xfff);


_040018AC:	// 40018ac: <2003001f>	ADDI      V1 = R0 + 001f
	state.r[V1] = 0 + 0x001F;


_040018B0:	// 40018b0: <001a3c02>	SRL       A3 = K0 >> 16
	state.r[A3] = ((_u32)state.r[K0] >> 16);


_040018B4:	// 40018b4: <30ea0001>	ANDI      T2 = A3 & 0001
	state.r[T2] = (state.r[A3] & 0x00000001);


_040018B8:	// 40018b8: <1d400008>	BGTZ      (R0>0) --> 18dc
	sp_reg_pc = 0x040018B8;
	if((_s32)state.r[T2] > 0)
	{
		goto _040018DC;
	}


_040018BC:	// 40018bc: <00000000>	NOP       


_040018C0:	// 40018c0: <0d000461>	JAL	    04001184
	sp_reg_pc = 0x040018C0;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001184;


_040018C4:	// 40018c4: <00000000>	NOP       


_040018C8:	// 40018c8: <40013000>	MFC0      A2 = SP DRAM DMA address
	state.r[AT] = 0;


_040018CC:	// 40018cc: <1420fffe>	BNE       (R0!=AT) --> 18c8
	sp_reg_pc = 0x040018CC;
	if (state.r[AT] != 0)
	{
		goto _040018C8;
	}


_040018D0:	// 40018d0: <00000000>	NOP       


_040018D4:	// 40018d4: <0900063a>	J         040018e8
	goto _040018E8;


_040018D8:	// 40018d8: <40803800>	MTC0      SP semaphore = R0


_040018DC:	// 40018dc: <a6e00008>	SH        [S7+0008] = R0
	Save16_DMEM((_u16)0, (state.r[S7] + 0x00000008) & 0xfff);


_040018E0:	// 40018e0: <4a10842c>	VXOR      vec16 = vec16 xor vec16[<none>]
	rsp_cop2_vxor(&state.v[16], &state.v[16], &state.v[16]);


_040018E4:	// 40018e4: <eaf01800>	SDV       [S7 + 0x00] = vec16 <00>
	{
		_u32	addr = (0x00000000 + state.r[S7]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[16].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[16].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[16].U32[0x00000003];
		}
	}


_040018E8:	// 40018e8: <30ea0002>	ANDI      T2 = A3 & 0002
	state.r[T2] = (state.r[A3] & 0x00000002);


_040018EC:	// 40018ec: <11400006>	BEQ       (R0==T2) --> 1908
	sp_reg_pc = 0x040018EC;
	if (state.r[T2] == 0)
	{
		goto _04001908;
	}


_040018F0:	// 40018f0: <00000000>	NOP       


_040018F4:	// 40018f4: <86eb000a>	LH        T3 = [S7+000a]
	state.r[T3] = (_s32)(_s16)Load16_DMEM((state.r[S7] + 0x0000000A) & 0xfff);


_040018F8:	// 40018f8: <cae32001>	LQV       vec03 <00> = [S7 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[S7]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[3].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[3].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[3].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[3].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[3].U64[0] = state.v[3].U64[0] & ~temp1;
			state.v[3].U64[1] = state.v[3].U64[1] & ~temp2;
			state.v[3].U64[0] = state.v[3].U64[0] | value1;
			state.v[3].U64[1] = state.v[3].U64[1] | value2;
		}
	}


_040018FC:	// 40018fc: <e903187e>	SDV       [T0 + 0x38] = vec03 <00>
	{
		_u32	addr = (0xFFFFFFF0 + state.r[T0]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[3].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[3].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[3].U32[0x00000003];
		}
	}


_04001900:	// 4001900: <e9031c7f>	SDV       [T0 + 0x3c] = vec03 <08>
	{
		_u32	addr = (0xFFFFFFF8 + state.r[T0]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[3].U64[0x00000000], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[3].U32[0x00000000];
			*(_u32 *)&pDMEM[addr  ] = state.v[3].U32[0x00000001];
		}
	}


_04001904:	// 4001904: <010b4022>	SUB       T0 = T0-T3
	state.r[T0] = (state.r[T0] - state.r[T3]);


_04001908:	// 4001908: <2108fff8>	ADDI      T0 = T0 + fff8
	state.r[T0] = state.r[T0] + 0xFFFFFFF8;


_0400190C:	// 400190c: <caf70f04>	LSV       vec23 <14> = [S7 + 0x08]
	state.v[23].U16[0] = Load16_DMEM(0x00000008 + state.r[S7]);


_04001910:	// 4001910: <caf01800>	LDV       vec16 <00> = [S7 + 0x00]
	rsp_ldv_compiler((state.r[S7] & 0xFFF), 16, 8);


_04001914:	// 4001914: <e9101800>	SDV       [T0 + 0x00] = vec16 <00>
	{
		_u32	addr = (0x00000000 + state.r[T0]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[16].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[16].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[16].U32[0x00000003];
		}
	}


_04001918:	// 4001918: <48889200>	MTC2      vec18 <04> = T0
	state.v[18].U16[5] = (_u16)state.r[T0];


_0400191C:	// 400191c: <200a00c0>	ADDI      T2 = R0 + 00c0
	state.r[T2] = 0 + 0x00C0;


_04001920:	// 4001920: <488a9300>	MTC2      vec18 <06> = T2
	state.v[18].U16[4] = (_u16)state.r[T2];


_04001924:	// 4001924: <489a9400>	MTC2      vec18 <08> = K0
	state.v[18].U16[3] = (_u16)state.r[K0];


_04001928:	// 4001928: <200a0040>	ADDI      T2 = R0 + 0040
	state.r[T2] = 0 + 0x0040;


_0400192C:	// 400192c: <488a9500>	MTC2      vec18 <10> = T2
	state.v[18].U16[2] = (_u16)state.r[T2];


_04001930:	// 4001930: <20090040>	ADDI      T1 = R0 + 0040
	state.r[T1] = 0 + 0x0040;


_04001934:	// 4001934: <c93f2001>	LQV       vec31 <00> = [T1 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[T1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[31].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[31].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[31].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[31].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[31].U64[0] = state.v[31].U64[0] & ~temp1;
			state.v[31].U64[1] = state.v[31].U64[1] & ~temp2;
			state.v[31].U64[0] = state.v[31].U64[0] | value1;
			state.v[31].U64[1] = state.v[31].U64[1] | value2;
		}
	}


_04001938:	// 4001938: <c9392000>	LQV       vec25 <00> = [T1 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[T1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[25].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[25].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[25].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[25].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[25].U64[0] = state.v[25].U64[0] & ~temp1;
			state.v[25].U64[1] = state.v[25].U64[1] & ~temp2;
			state.v[25].U64[0] = state.v[25].U64[0] | value1;
			state.v[25].U64[1] = state.v[25].U64[1] | value2;
		}
	}


_0400193C:	// 400193c: <4a1fce51>	VSUB      vec25 = vec25 - vec31[<none>]
	{
		_u16		flag0 = state.flag[0];
		VSUB_operation(0, state.v[25].U16[0], state.v[25].U16[0], state.v[31].U16[0], 1, 0, 0, 1)
		VSUB_operation(1, state.v[25].U16[1], state.v[25].U16[1], state.v[31].U16[1], 1, 0, 0, 1)
		VSUB_operation(2, state.v[25].U16[2], state.v[25].U16[2], state.v[31].U16[2], 1, 0, 0, 1)
		VSUB_operation(3, state.v[25].U16[3], state.v[25].U16[3], state.v[31].U16[3], 1, 0, 0, 1)
		VSUB_operation(4, state.v[25].U16[4], state.v[25].U16[4], state.v[31].U16[4], 1, 0, 0, 1)
		VSUB_operation(5, state.v[25].U16[5], state.v[25].U16[5], state.v[31].U16[5], 1, 0, 0, 1)
		VSUB_operation(6, state.v[25].U16[6], state.v[25].U16[6], state.v[31].U16[6], 1, 0, 0, 1)
		VSUB_operation(7, state.v[25].U16[7], state.v[25].U16[7], state.v[31].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001940:	// 4001940: <c93e2002>	LQV       vec30 <00> = [T1 + 0x20]
	{
		_u32 addr = (0x00000020 + state.r[T1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[30].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[30].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[30].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[30].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[30].U64[0] = state.v[30].U64[0] & ~temp1;
			state.v[30].U64[1] = state.v[30].U64[1] & ~temp2;
			state.v[30].U64[0] = state.v[30].U64[0] | value1;
			state.v[30].U64[1] = state.v[30].U64[1] | value2;
		}
	}


_04001944:	// 4001944: <c93d2003>	LQV       vec29 <00> = [T1 + 0x30]
	{
		_u32 addr = (0x00000030 + state.r[T1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[29].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[29].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[29].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[29].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[29].U64[0] = state.v[29].U64[0] & ~temp1;
			state.v[29].U64[1] = state.v[29].U64[1] & ~temp2;
			state.v[29].U64[0] = state.v[29].U64[0] | value1;
			state.v[29].U64[1] = state.v[29].U64[1] | value2;
		}
	}


_04001948:	// 4001948: <c93c2004>	LQV       vec28 <00> = [T1 + 0x40]
	{
		_u32 addr = (0x00000040 + state.r[T1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[28].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[28].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[28].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[28].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[28].U64[0] = state.v[28].U64[0] & ~temp1;
			state.v[28].U64[1] = state.v[28].U64[1] & ~temp2;
			state.v[28].U64[0] = state.v[28].U64[0] | value1;
			state.v[28].U64[1] = state.v[28].U64[1] | value2;
		}
	}


_0400194C:	// 400194c: <c93b2005>	LQV       vec27 <00> = [T1 + 0x50]
	{
		_u32 addr = (0x00000050 + state.r[T1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
			state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
			state.v[27].U64[0] = state.v[27].U64[0] | value1;
			state.v[27].U64[1] = state.v[27].U64[1] | value2;
		}
	}


_04001950:	// 4001950: <c93a2006>	LQV       vec26 <00> = [T1 + 0x60]
	{
		_u32 addr = (0x00000060 + state.r[T1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[26].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[26].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[26].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[26].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[26].U64[0] = state.v[26].U64[0] & ~temp1;
			state.v[26].U64[1] = state.v[26].U64[1] & ~temp2;
			state.v[26].U64[0] = state.v[26].U64[0] | value1;
			state.v[26].U64[1] = state.v[26].U64[1] | value2;
		}
	}


_04001954:	// 4001954: <4a1fce51>	VSUB      vec25 = vec25 - vec31[<none>]
	{
		_u16		flag0 = state.flag[0];
		VSUB_operation(0, state.v[25].U16[0], state.v[25].U16[0], state.v[31].U16[0], 1, 0, 0, 1)
		VSUB_operation(1, state.v[25].U16[1], state.v[25].U16[1], state.v[31].U16[1], 1, 0, 0, 1)
		VSUB_operation(2, state.v[25].U16[2], state.v[25].U16[2], state.v[31].U16[2], 1, 0, 0, 1)
		VSUB_operation(3, state.v[25].U16[3], state.v[25].U16[3], state.v[31].U16[3], 1, 0, 0, 1)
		VSUB_operation(4, state.v[25].U16[4], state.v[25].U16[4], state.v[31].U16[4], 1, 0, 0, 1)
		VSUB_operation(5, state.v[25].U16[5], state.v[25].U16[5], state.v[31].U16[5], 1, 0, 0, 1)
		VSUB_operation(6, state.v[25].U16[6], state.v[25].U16[6], state.v[31].U16[6], 1, 0, 0, 1)
		VSUB_operation(7, state.v[25].U16[7], state.v[25].U16[7], state.v[31].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001958:	// 4001958: <c9382007>	LQV       vec24 <00> = [T1 + 0x70]
	{
		_u32 addr = (0x00000070 + state.r[T1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[24].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[24].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[24].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[24].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[24].U64[0] = state.v[24].U64[0] & ~temp1;
			state.v[24].U64[1] = state.v[24].U64[1] & ~temp2;
			state.v[24].U64[0] = state.v[24].U64[0] | value1;
			state.v[24].U64[1] = state.v[24].U64[1] | value2;
		}
	}


_0400195C:	// 400195c: <22f50020>	ADDI      S5 = S7 + 0020
	state.r[S5] = state.r[S7] + 0x0020;


_04001960:	// 4001960: <22f40030>	ADDI      S4 = S7 + 0030
	state.r[S4] = state.r[S7] + 0x0030;


_04001964:	// 4001964: <4a16b5ac>	VXOR      vec22 = vec22 xor vec22[<none>]
	rsp_cop2_vxor(&state.v[22], &state.v[22], &state.v[22]);


_04001968:	// 4001968: <4bf7fdc5>	VMUDM     vec23 = ( acc = vec31 * vec23[7] ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[31*16].U16[0]
			MOVQ mm1, state.v[31*16].U16[4*2]
			PSHUFW mm4, state.v[23*16].U16[0*2], 0
			MOVQ mm6, mm0
			MOVQ mm7, mm1
			PMULLW mm6, mm4
			PMULLW mm7, mm4
			MOVQ accumulator[0*4], mm6
			MOVQ accumulator[2*4], mm7
			MOVQ mm2, mm0
			MOVQ mm3, mm1
			PMULHUW mm0, mm4
			PMULHUW mm1, mm4
			PSRAW mm2, 15
			PSRAW mm3, 15
			PMULLW mm2, mm4
			PMULLW mm3, mm4
			PADDW mm0, mm2
			PADDW mm1, mm3
			MOVQ mm2, mm0
			MOVQ mm3, mm0
			MOVQ mm4, mm1
			MOVQ mm5, mm1
			PSRAW mm0, 15
			PSRAW mm1, 15
			PUNPCKLWD mm2, mm0
			PUNPCKHWD mm3, mm0
			PUNPCKLWD mm4, mm1
			PUNPCKHWD mm5, mm1
			MOVQ accumulator_hi[0*4], mm2
			MOVQ accumulator_hi[2*4], mm3
			MOVQ accumulator_hi[4*4], mm4
			MOVQ accumulator_hi[6*4], mm5
		}
	}


_0400196C:	// 400196c: <4b92cd8d>	VMADM     vec22 = ( acc+= vec25 * vec18[4] ) >> 16
	{
		_u16		s2value = state.v[18].U16[3];
		VMADM_operation(0, state.v[22].U16[0], state.v[25].U16[0], s2value, 1, 1, 1, 1)
		VMADM_operation(1, state.v[22].U16[1], state.v[25].U16[1], s2value, 1, 1, 1, 1)
		VMADM_operation(2, state.v[22].U16[2], state.v[25].U16[2], s2value, 1, 1, 1, 1)
		VMADM_operation(3, state.v[22].U16[3], state.v[25].U16[3], s2value, 1, 1, 1, 1)
		VMADM_operation(4, state.v[22].U16[4], state.v[25].U16[4], s2value, 1, 1, 1, 1)
		VMADM_operation(5, state.v[22].U16[5], state.v[25].U16[5], s2value, 1, 1, 1, 1)
		VMADM_operation(6, state.v[22].U16[6], state.v[25].U16[6], s2value, 1, 1, 1, 1)
		VMADM_operation(7, state.v[22].U16[7], state.v[25].U16[7], s2value, 1, 1, 1, 1)
	}


_04001970:	// 4001970: <4b1efdce>	VMADN     vec23 = ( acc+= vec31 * vec30[0] )
	{
		_u16		s2value = state.v[30].U16[7];
		VMADN_operation(0, state.v[23].U16[0], state.v[31].U16[0], s2value, 1, 0, 0, 1)
		VMADN_operation(1, state.v[23].U16[1], state.v[31].U16[1], s2value, 1, 0, 0, 1)
		VMADN_operation(2, state.v[23].U16[2], state.v[31].U16[2], s2value, 1, 0, 0, 1)
		VMADN_operation(3, state.v[23].U16[3], state.v[31].U16[3], s2value, 1, 0, 0, 1)
		VMADN_operation(4, state.v[23].U16[4], state.v[31].U16[4], s2value, 1, 0, 0, 1)
		VMADN_operation(5, state.v[23].U16[5], state.v[31].U16[5], s2value, 1, 0, 0, 1)
		VMADN_operation(6, state.v[23].U16[6], state.v[31].U16[6], s2value, 1, 0, 0, 1)
		VMADN_operation(7, state.v[23].U16[7], state.v[31].U16[7], s2value, 1, 0, 0, 1)
	}


_04001974:	// 4001974: <4b52fd46>	VMUDN     vec21 = ( acc = vec31 * vec18[2]      ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[31*16].U16[0]
			MOVQ mm1, state.v[31*16].U16[4*2]
			PSHUFW mm4, state.v[18*16].U16[5*2], 0
			MOVQ mm6, mm0
			MOVQ mm7, mm1
			PMULLW mm6, mm4
			PMULLW mm7, mm4
			MOVQ accumulator[0*4], mm6
			MOVQ accumulator[2*4], mm7
			MOVQ mm2, mm0
			MOVQ mm3, mm1
			PMULHUW mm2, mm4
			PMULHUW mm3, mm4
			PSRAW mm0, 15
			PSRAW mm1, 15
			PMULLW mm0, mm4
			PMULLW mm1, mm4
			PADDW mm0, mm2
			PADDW mm1, mm3
			MOVQ mm2, mm0
			MOVQ mm3, mm0
			MOVQ mm4, mm1
			MOVQ mm5, mm1
			PSRAW mm0, 15
			PSRAW mm1, 15
			PUNPCKLWD mm2, mm0
			PUNPCKHWD mm3, mm0
			PUNPCKLWD mm4, mm1
			PUNPCKHWD mm5, mm1
			MOVQ accumulator_hi[0*4], mm2
			MOVQ accumulator_hi[2*4], mm3
			MOVQ accumulator_hi[4*4], mm4
			MOVQ accumulator_hi[6*4], mm5
		}
	}


_04001978:	// 4001978: <4b5eb54e>	VMADN     vec21 = ( acc+= vec22 * vec30[2] )
	{
		_u16		s2value = state.v[30].U16[5];
		VMADN_operation(0, state.v[21].U16[0], state.v[22].U16[0], s2value, 1, 0, 0, 1)
		VMADN_operation(1, state.v[21].U16[1], state.v[22].U16[1], s2value, 1, 0, 0, 1)
		VMADN_operation(2, state.v[21].U16[2], state.v[22].U16[2], s2value, 1, 0, 0, 1)
		VMADN_operation(3, state.v[21].U16[3], state.v[22].U16[3], s2value, 1, 0, 0, 1)
		VMADN_operation(4, state.v[21].U16[4], state.v[22].U16[4], s2value, 1, 0, 0, 1)
		VMADN_operation(5, state.v[21].U16[5], state.v[22].U16[5], s2value, 1, 0, 0, 1)
		VMADN_operation(6, state.v[21].U16[6], state.v[22].U16[6], s2value, 1, 0, 0, 1)
		VMADN_operation(7, state.v[21].U16[7], state.v[22].U16[7], s2value, 1, 0, 0, 1)
	}


_0400197C:	// 400197c: <4bb2bc44>	VMUDL     vec17 = ( acc = (vec23 * vec18[5] >> 16)      )
	{
		__asm {
			MOVQ mm0, state.v[23*16].U16[0]
			MOVQ mm1, state.v[23*16].U16[4*2]
			PSHUFW mm4, state.v[18*16].U16[2*2], 0
			PMULHUW mm0, mm4
			PMULHUW mm1, mm4
			MOVQ state.v[17*16].U16[0], mm0
			MOVQ state.v[17*16].U16[4*2], mm1
		}
	}


_04001980:	// 4001980: <4b9e8c46>	VMUDN     vec17 = ( acc = vec17 * vec30[4]      ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[17*16].U16[0]
			MOVQ mm1, state.v[17*16].U16[4*2]
			PSHUFW mm4, state.v[30*16].U16[3*2], 0
			MOVQ mm6, mm0
			MOVQ mm7, mm1
			PMULLW mm6, mm4
			PMULLW mm7, mm4
			MOVQ accumulator[0*4], mm6
			MOVQ accumulator[2*4], mm7
			MOVQ mm2, mm0
			MOVQ mm3, mm1
			PMULHUW mm2, mm4
			PMULHUW mm3, mm4
			PSRAW mm0, 15
			PSRAW mm1, 15
			PMULLW mm0, mm4
			PMULLW mm1, mm4
			PADDW mm0, mm2
			PADDW mm1, mm3
			MOVQ mm2, mm0
			MOVQ mm3, mm0
			MOVQ mm4, mm1
			MOVQ mm5, mm1
			PSRAW mm0, 15
			PSRAW mm1, 15
			PUNPCKLWD mm2, mm0
			PUNPCKHWD mm3, mm0
			PUNPCKLWD mm4, mm1
			PUNPCKHWD mm5, mm1
			MOVQ accumulator_hi[0*4], mm2
			MOVQ accumulator_hi[2*4], mm3
			MOVQ accumulator_hi[4*4], mm4
			MOVQ accumulator_hi[6*4], mm5
		}
	}


_04001984:	// 4001984: <4b72fc4e>	VMADN     vec17 = ( acc+= vec31 * vec18[3] )
	{
		_u16		s2value = state.v[18].U16[4];
		VMADN_operation(0, state.v[17].U16[0], state.v[31].U16[0], s2value, 1, 0, 0, 1)
		VMADN_operation(1, state.v[17].U16[1], state.v[31].U16[1], s2value, 1, 0, 0, 1)
		VMADN_operation(2, state.v[17].U16[2], state.v[31].U16[2], s2value, 1, 0, 0, 1)
		VMADN_operation(3, state.v[17].U16[3], state.v[31].U16[3], s2value, 1, 0, 0, 1)
		VMADN_operation(4, state.v[17].U16[4], state.v[31].U16[4], s2value, 1, 0, 0, 1)
		VMADN_operation(5, state.v[17].U16[5], state.v[31].U16[5], s2value, 1, 0, 0, 1)
		VMADN_operation(6, state.v[17].U16[6], state.v[31].U16[6], s2value, 1, 0, 0, 1)
		VMADN_operation(7, state.v[17].U16[7], state.v[31].U16[7], s2value, 1, 0, 0, 1)
	}


_04001988:	// 4001988: <c9392000>	LQV       vec25 <00> = [T1 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[T1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[25].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[25].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[25].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[25].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[25].U64[0] = state.v[25].U64[0] & ~temp1;
			state.v[25].U64[1] = state.v[25].U64[1] & ~temp2;
			state.v[25].U64[0] = state.v[25].U64[0] | value1;
			state.v[25].U64[1] = state.v[25].U64[1] | value2;
		}
	}


_0400198C:	// 400198c: <eab52000>	SQV       [S5 + 0x00] = vec21 <00>
	{
		_u32    addr = (0x00000000 + state.r[S5]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[21].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[21].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[21].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[21].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[21].U64[0] & temp1);
			value2 |= (state.v[21].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001990:	// 4001990: <ea912000>	SQV       [S4 + 0x00] = vec17 <00>
	{
		_u32    addr = (0x00000000 + state.r[S4]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[17].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[17].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[17].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[17].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[17].U64[0] & temp1);
			value2 |= (state.v[17].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001994:	// 4001994: <eaf70b84>	SSV       [S7 + 0x08] = vec23 <07>
	Save16_DMEM(state.v[23].U16[4], (0x00000008 + state.r[S7]) & 0xfff);


_04001998:	// 4001998: <86b10000>	LH        S1 = [S5+0000]
	state.r[S1] = (_s32)(_s16)Load16_DMEM((state.r[S5] + 0x00000000) & 0xfff);


_0400199C:	// 400199c: <86890000>	LH        T1 = [S4+0000]
	state.r[T1] = (_s32)(_s16)Load16_DMEM((state.r[S4] + 0x00000000) & 0xfff);


_040019A0:	// 40019a0: <86ad0008>	LH        T5 = [S5+0008]
	state.r[T5] = (_s32)(_s16)Load16_DMEM((state.r[S5] + 0x00000008) & 0xfff);


_040019A4:	// 40019a4: <86850008>	LH        A1 = [S4+0008]
	state.r[A1] = (_s32)(_s16)Load16_DMEM((state.r[S4] + 0x00000008) & 0xfff);


_040019A8:	// 40019a8: <86b00002>	LH        S0 = [S5+0002]
	state.r[S0] = (_s32)(_s16)Load16_DMEM((state.r[S5] + 0x00000002) & 0xfff);


_040019AC:	// 40019ac: <86880002>	LH        T0 = [S4+0002]
	state.r[T0] = (_s32)(_s16)Load16_DMEM((state.r[S4] + 0x00000002) & 0xfff);


_040019B0:	// 40019b0: <86ac000a>	LH        T4 = [S5+000a]
	state.r[T4] = (_s32)(_s16)Load16_DMEM((state.r[S5] + 0x0000000A) & 0xfff);


_040019B4:	// 40019b4: <8684000a>	LH        A0 = [S4+000a]
	state.r[A0] = (_s32)(_s16)Load16_DMEM((state.r[S4] + 0x0000000A) & 0xfff);


_040019B8:	// 40019b8: <86af0004>	LH        T7 = [S5+0004]
	state.r[T7] = (_s32)(_s16)Load16_DMEM((state.r[S5] + 0x00000004) & 0xfff);


_040019BC:	// 40019bc: <86870004>	LH        A3 = [S4+0004]
	state.r[A3] = (_s32)(_s16)Load16_DMEM((state.r[S4] + 0x00000004) & 0xfff);


_040019C0:	// 40019c0: <86ab000c>	LH        T3 = [S5+000c]
	state.r[T3] = (_s32)(_s16)Load16_DMEM((state.r[S5] + 0x0000000C) & 0xfff);


_040019C4:	// 40019c4: <8683000c>	LH        V1 = [S4+000c]
	state.r[V1] = (_s32)(_s16)Load16_DMEM((state.r[S4] + 0x0000000C) & 0xfff);


_040019C8:	// 40019c8: <86ae0006>	LH        T6 = [S5+0006]
	state.r[T6] = (_s32)(_s16)Load16_DMEM((state.r[S5] + 0x00000006) & 0xfff);


_040019CC:	// 40019cc: <86860006>	LH        A2 = [S4+0006]
	state.r[A2] = (_s32)(_s16)Load16_DMEM((state.r[S4] + 0x00000006) & 0xfff);


_040019D0:	// 40019d0: <86aa000e>	LH        T2 = [S5+000e]
	state.r[T2] = (_s32)(_s16)Load16_DMEM((state.r[S5] + 0x0000000E) & 0xfff);


_040019D4:	// 40019d4: <8682000e>	LH        V0 = [S4+000e]
	state.r[V0] = (_s32)(_s16)Load16_DMEM((state.r[S4] + 0x0000000E) & 0xfff);


_040019D8:	// 40019d8: <ca301800>	LDV       vec16 <00> = [S1 + 0x00]
	// In function: Mario19D8_1AC4
	//Call the function: Mario19D8_1AC4
	Mario19D8_1AC4();
	goto _04001AC8;

_040019DC:	// 40019dc: <4bf7fdc5>	VMUDM     vec23 = ( acc = vec31 * vec23[7] ) >> 16
	ErrorToCallFunction(0x040019DC);

_040019E0:	// 40019e0: <c92f1800>	LDV       vec15 <00> = [T1 + 0x00]
	ErrorToCallFunction(0x040019E0);

_040019E4:	// 40019e4: <4bf6fdcf>	VMADH     vec23 = ( acc+= (vec31 * vec22[7]) << 16) >> 16
	ErrorToCallFunction(0x040019E4);

_040019E8:	// 40019e8: <c9b01c00>	LDV       vec16 <08> = [T5 + 0x00]
	ErrorToCallFunction(0x040019E8);

_040019EC:	// 40019ec: <4b92cd8d>	VMADM     vec22 = ( acc+= vec25 * vec18[4] ) >> 16
	ErrorToCallFunction(0x040019EC);

_040019F0:	// 40019f0: <c8af1c00>	LDV       vec15 <08> = [A1 + 0x00]
	ErrorToCallFunction(0x040019F0);

_040019F4:	// 40019f4: <4b1efdce>	VMADN     vec23 = ( acc+= vec31 * vec30[0] )
	ErrorToCallFunction(0x040019F4);

_040019F8:	// 40019f8: <ca0e1800>	LDV       vec14 <00> = [S0 + 0x00]
	ErrorToCallFunction(0x040019F8);

_040019FC:	// 40019fc: <4b52fd46>	VMUDN     vec21 = ( acc = vec31 * vec18[2]      ) >> 16
	ErrorToCallFunction(0x040019FC);

_04001A00:	// 4001a00: <c90d1800>	LDV       vec13 <00> = [T0 + 0x00]
	ErrorToCallFunction(0x04001A00);

_04001A04:	// 4001a04: <4b5eb54e>	VMADN     vec21 = ( acc+= vec22 * vec30[2] )
	ErrorToCallFunction(0x04001A04);

_04001A08:	// 4001a08: <c98e1c00>	LDV       vec14 <08> = [T4 + 0x00]
	ErrorToCallFunction(0x04001A08);

_04001A0C:	// 4001a0c: <4bb2bc44>	VMUDL     vec17 = ( acc = (vec23 * vec18[5] >> 16)      )
	ErrorToCallFunction(0x04001A0C);

_04001A10:	// 4001a10: <c88d1c00>	LDV       vec13 <08> = [A0 + 0x00]
	ErrorToCallFunction(0x04001A10);

_04001A14:	// 4001a14: <c9ec1800>	LDV       vec12 <00> = [T7 + 0x00]
	ErrorToCallFunction(0x04001A14);

_04001A18:	// 4001a18: <c8eb1800>	LDV       vec11 <00> = [A3 + 0x00]
	ErrorToCallFunction(0x04001A18);

_04001A1C:	// 4001a1c: <c96c1c00>	LDV       vec12 <08> = [T3 + 0x00]
	ErrorToCallFunction(0x04001A1C);

_04001A20:	// 4001a20: <4b9e8c46>	VMUDN     vec17 = ( acc = vec17 * vec30[4]      ) >> 16
	ErrorToCallFunction(0x04001A20);

_04001A24:	// 4001a24: <c86b1c00>	LDV       vec11 <08> = [V1 + 0x00]
	ErrorToCallFunction(0x04001A24);

_04001A28:	// 4001a28: <c9ca1800>	LDV       vec10 <00> = [T6 + 0x00]
	ErrorToCallFunction(0x04001A28);

_04001A2C:	// 4001a2c: <c8c91800>	LDV       vec09 <00> = [A2 + 0x00]
	ErrorToCallFunction(0x04001A2C);

_04001A30:	// 4001a30: <4b72fc4e>	VMADN     vec17 = ( acc+= vec31 * vec18[3] )
	ErrorToCallFunction(0x04001A30);

_04001A34:	// 4001a34: <c94a1c00>	LDV       vec10 <08> = [T2 + 0x00]
	ErrorToCallFunction(0x04001A34);

_04001A38:	// 4001a38: <4a0f8200>	VMULF     vec08 = ( acc = (vec16 * vec15[<none>]) << 1 ) >> 16
	ErrorToCallFunction(0x04001A38);

_04001A3C:	// 4001a3c: <c8491c00>	LDV       vec09 <08> = [V0 + 0x00]
	ErrorToCallFunction(0x04001A3C);

_04001A40:	// 4001a40: <4a0d71c0>	VMULF     vec07 = ( acc = (vec14 * vec13[<none>]) << 1 ) >> 16
	ErrorToCallFunction(0x04001A40);

_04001A44:	// 4001a44: <eab52000>	SQV       [S5 + 0x00] = vec21 <00>
	ErrorToCallFunction(0x04001A44);

_04001A48:	// 4001a48: <4a0b6180>	VMULF     vec06 = ( acc = (vec12 * vec11[<none>]) << 1 ) >> 16
	ErrorToCallFunction(0x04001A48);

_04001A4C:	// 4001a4c: <ea912000>	SQV       [S4 + 0x00] = vec17 <00>
	ErrorToCallFunction(0x04001A4C);

_04001A50:	// 4001a50: <86b10000>	LH        S1 = [S5+0000]
	ErrorToCallFunction(0x04001A50);

_04001A54:	// 4001a54: <4a095140>	VMULF     vec05 = ( acc = (vec10 * vec09[<none>]) << 1 ) >> 16
	ErrorToCallFunction(0x04001A54);

_04001A58:	// 4001a58: <86890000>	LH        T1 = [S4+0000]
	ErrorToCallFunction(0x04001A58);

_04001A5C:	// 4001a5c: <4a684210>	VADD      vec08 = vec08 + vec08[1q]
	ErrorToCallFunction(0x04001A5C);

_04001A60:	// 4001a60: <86ad0008>	LH        T5 = [S5+0008]
	ErrorToCallFunction(0x04001A60);

_04001A64:	// 4001a64: <4a6739d0>	VADD      vec07 = vec07 + vec07[1q]
	ErrorToCallFunction(0x04001A64);

_04001A68:	// 4001a68: <86850008>	LH        A1 = [S4+0008]
	ErrorToCallFunction(0x04001A68);

_04001A6C:	// 4001a6c: <4a663190>	VADD      vec06 = vec06 + vec06[1q]
	ErrorToCallFunction(0x04001A6C);

_04001A70:	// 4001a70: <86b00002>	LH        S0 = [S5+0002]
	ErrorToCallFunction(0x04001A70);

_04001A74:	// 4001a74: <4a652950>	VADD      vec05 = vec05 + vec05[1q]
	ErrorToCallFunction(0x04001A74);

_04001A78:	// 4001a78: <86880002>	LH        T0 = [S4+0002]
	ErrorToCallFunction(0x04001A78);

_04001A7C:	// 4001a7c: <4ac84210>	VADD      vec08 = vec08 + vec08[2h]
	ErrorToCallFunction(0x04001A7C);

_04001A80:	// 4001a80: <86ac000a>	LH        T4 = [S5+000a]
	ErrorToCallFunction(0x04001A80);

_04001A84:	// 4001a84: <4ac739d0>	VADD      vec07 = vec07 + vec07[2h]
	ErrorToCallFunction(0x04001A84);

_04001A88:	// 4001a88: <8684000a>	LH        A0 = [S4+000a]
	ErrorToCallFunction(0x04001A88);

_04001A8C:	// 4001a8c: <4ac63190>	VADD      vec06 = vec06 + vec06[2h]
	ErrorToCallFunction(0x04001A8C);

_04001A90:	// 4001a90: <86af0004>	LH        T7 = [S5+0004]
	ErrorToCallFunction(0x04001A90);

_04001A94:	// 4001a94: <4ac52950>	VADD      vec05 = vec05 + vec05[2h]
	ErrorToCallFunction(0x04001A94);

_04001A98:	// 4001a98: <86870004>	LH        A3 = [S4+0004]
	ErrorToCallFunction(0x04001A98);

_04001A9C:	// 4001a9c: <4a88e906>	VMUDN     vec04 = ( acc = vec29 * vec08[0h]      ) >> 16
	ErrorToCallFunction(0x04001A9C);

_04001AA0:	// 4001aa0: <86ab000c>	LH        T3 = [S5+000c]
	ErrorToCallFunction(0x04001AA0);

_04001AA4:	// 4001aa4: <4a87e10e>	VMADN     vec04 = ( acc+= vec28 * vec07[0h] )
	ErrorToCallFunction(0x04001AA4);

_04001AA8:	// 4001aa8: <8683000c>	LH        V1 = [S4+000c]
	ErrorToCallFunction(0x04001AA8);

_04001AAC:	// 4001aac: <4a86d90e>	VMADN     vec04 = ( acc+= vec27 * vec06[0h] )
	ErrorToCallFunction(0x04001AAC);

_04001AB0:	// 4001ab0: <86ae0006>	LH        T6 = [S5+0006]
	ErrorToCallFunction(0x04001AB0);

_04001AB4:	// 4001ab4: <4a85d10e>	VMADN     vec04 = ( acc+= vec26 * vec05[0h] )
	ErrorToCallFunction(0x04001AB4);

_04001AB8:	// 4001ab8: <86860006>	LH        A2 = [S4+0006]
	ErrorToCallFunction(0x04001AB8);

_04001ABC:	// 4001abc: <86aa000e>	LH        T2 = [S5+000e]
	ErrorToCallFunction(0x04001ABC);

_04001AC0:	// 4001ac0: <2252fff0>	ADDI      S2 = S2 + fff0
	ErrorToCallFunction(0x04001AC0);

_04001AC4:	// 4001ac4: <ea642000>	SQV       [S3 + 0x00] = vec04 <00>
	ErrorToCallFunction(0x04001AC4);

_04001AC8:	// 4001ac8: <1a400003>	BLEZ      (R0<=0) --> 1ad8
	sp_reg_pc = 0x04001AC8;
	if ((_s32)state.r[S2] <= 0)
	{
		state.r[V0] = (_s32)(_s16)Load16_DMEM((state.r[S4] + 0x0000000E) & 0xfff);
		goto _04001AD8;
	}


_04001ACC:	// 4001acc: <8682000e>	LH        V0 = [S4+000e]
	state.r[V0] = (_s32)(_s16)Load16_DMEM((state.r[S4] + 0x0000000E) & 0xfff);


_04001AD0:	// 4001ad0: <09000676>	J         040019d8
	state.r[S3] = state.r[S3] + 0x0010;
	goto _040019D8;


_04001AD4:	// 4001ad4: <22730010>	ADDI      S3 = S3 + 0010
	state.r[S3] = state.r[S3] + 0x0010;


_04001AD8:	// 4001ad8: <eaf70804>	SSV       [S7 + 0x08] = vec23 <00>
	Save16_DMEM(state.v[23].U16[7], (0x00000008 + state.r[S7]) & 0xfff);


_04001ADC:	// 4001adc: <ca301800>	LDV       vec16 <00> = [S1 + 0x00]
	rsp_ldv_compiler((state.r[S1] & 0xFFF), 16, 8);


_04001AE0:	// 4001ae0: <eaf01800>	SDV       [S7 + 0x00] = vec16 <00>
	{
		_u32	addr = (0x00000000 + state.r[S7]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[16].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[16].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[16].U32[0x00000003];
		}
	}


_04001AE4:	// 4001ae4: <87060000>	LH        A2 = [T8+0000]
	state.r[A2] = (_s32)(_s16)Load16_DMEM((state.r[T8] + 0x00000000) & 0xfff);


_04001AE8:	// 4001ae8: <22310008>	ADDI      S1 = S1 + 0008
	state.r[S1] = state.r[S1] + 0x0008;


_04001AEC:	// 4001aec: <02262822>	SUB       A1 = S1-A2
	state.r[A1] = (state.r[S1] - state.r[A2]);


_04001AF0:	// 4001af0: <30a4000f>	ANDI      A0 = A1 & 000f
	state.r[A0] = (state.r[A1] & 0x0000000F);


_04001AF4:	// 4001af4: <02248822>	SUB       S1 = S1-A0
	state.r[S1] = (state.r[S1] - state.r[A0]);


_04001AF8:	// 4001af8: <10800002>	BEQ       (R0==A0) --> 1b04
	sp_reg_pc = 0x04001AF8;
	if (state.r[A0] == 0)
	{
		state.r[A3] = 0 + 0x0010;
		goto _04001B04;
	}


_04001AFC:	// 4001afc: <20070010>	ADDI      A3 = R0 + 0010
	state.r[A3] = 0 + 0x0010;


_04001B00:	// 4001b00: <00e42022>	SUB       A0 = A3-A0
	state.r[A0] = (state.r[A3] - state.r[A0]);


_04001B04:	// 4001b04: <a6e4000a>	SH        [S7+000a] = A0
	Save16_DMEM((_u16)state.r[A0], (state.r[S7] + 0x0000000A) & 0xfff);


_04001B08:	// 4001b08: <ca231800>	LDV       vec03 <00> = [S1 + 0x00]
	rsp_ldv_compiler((state.r[S1] & 0xFFF), 3, 8);


_04001B0C:	// 4001b0c: <ca231c01>	LDV       vec03 <08> = [S1 + 0x08]
	rsp_ldv_compiler((state.r[S1] + 0x00000008) & 0xFFF, 3, 0);


_04001B10:	// 4001b10: <eae32001>	SQV       [S7 + 0x10] = vec03 <00>
	{
		_u32    addr = (0x00000010 + state.r[S7]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[3].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[3].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[3].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[3].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[3].U64[0] & temp1);
			value2 |= (state.v[3].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001B14:	// 4001b14: <8ee20040>	LW        V0 = [S7+0040]
	state.r[V0] = (_s32)Load32_DMEM((state.r[S7] + 0x00000040) & 0xfff);


_04001B18:	// 4001b18: <22e10000>	ADDI      AT = S7 + 0000
	state.r[AT] = state.r[S7] + 0x0000;


_04001B1C:	// 4001b1c: <0d00046c>	JAL	    040011b0
	state.r[V1] = 0 + 0x001F;
	sp_reg_pc = 0x04001B1C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040011B0;


_04001B20:	// 4001b20: <2003001f>	ADDI      V1 = R0 + 001f
	state.r[V1] = 0 + 0x001F;


_04001B24:	// 4001b24: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001B28:	// 4001b28: <14a0fffe>	BNE       (R0!=A1) --> 1b24
	sp_reg_pc = 0x04001B28;
	if (state.r[A1] != 0)
	{
		goto _04001B24;
	}


_04001B2C:	// 4001b2c: <00000000>	NOP       


_04001B30:	// 4001b30: <09000446>	J         04001118
	goto _04001118;


_04001B34:	// 4001b34: <40803800>	MTC0      SP semaphore = R0


_04001B38:	// 4001b38: <3c0400ff>	LUI       A0 = 0x00ff0000
	state.r[A0] = 0x00FF0000;


_04001B3C:	// 4001b3c: <3484ffff>	ORI       A0 = A0 | 0xffff
	state.r[A0] = (state.r[A0] | 0x0000FFFF);


_04001B40:	// 4001b40: <03241024>	AND       V0 = T9 & A0
	state.r[V0] = (state.r[T9] & state.r[A0]);


_04001B44:	// 4001b44: <00192e02>	SRL       A1 = T9 >> 24
	state.r[A1] = ((_u32)state.r[T9] >> 24);


_04001B48:	// 4001b48: <00052880>	SLL       A1 = A1 << 2
	state.r[A1] = ((_u32)state.r[A1] << 2);


_04001B4C:	// 4001b4c: <8ca60320>	LW        A2 = [A1+0320]
	state.r[A2] = (_s32)Load32_DMEM((state.r[A1] + 0x00000320) & 0xfff);


_04001B50:	// 4001b50: <00461020>	ADD       V0 = V0+A2
	state.r[V0] = (state.r[V0] + state.r[A2]);


_04001B54:	// 4001b54: <22e10000>	ADDI      AT = S7 + 0000
	state.r[AT] = state.r[S7] + 0x0000;


_04001B58:	// 4001b58: <2003004f>	ADDI      V1 = R0 + 004f
	state.r[V1] = 0 + 0x004F;


_04001B5C:	// 4001b5c: <4a00002c>	VXOR      vec00 = vec00 xor vec00[<none>]
	rsp_cop2_vxor(&state.v[0], &state.v[0], &state.v[0]);


_04001B60:	// 4001b60: <200b0040>	ADDI      T3 = R0 + 0040
	state.r[T3] = 0 + 0x0040;


_04001B64:	// 4001b64: <c97f2001>	LQV       vec31 <00> = [T3 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[T3]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[31].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[31].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[31].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[31].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[31].U64[0] = state.v[31].U64[0] & ~temp1;
			state.v[31].U64[1] = state.v[31].U64[1] & ~temp2;
			state.v[31].U64[0] = state.v[31].U64[0] | value1;
			state.v[31].U64[1] = state.v[31].U64[1] | value2;
		}
	}


_04001B68:	// 4001b68: <c80a2000>	LQV       vec10 <00> = [R0 + 0x00]
	{
		_u32 addr = (0x00000000 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[10].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[10].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[10].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[10].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[10].U64[0] = state.v[10].U64[0] & ~temp1;
			state.v[10].U64[1] = state.v[10].U64[1] & ~temp2;
			state.v[10].U64[0] = state.v[10].U64[0] | value1;
			state.v[10].U64[1] = state.v[10].U64[1] | value2;
		}
	}


_04001B6C:	// 4001b6c: <001a6402>	SRL       T4 = K0 >> 16
	state.r[T4] = ((_u32)state.r[K0] >> 16);


_04001B70:	// 4001b70: <318a0001>	ANDI      T2 = T4 & 0001
	state.r[T2] = (state.r[T4] & 0x00000001);


_04001B74:	// 4001b74: <11400003>	BEQ       (R0==T2) --> 1b84
	sp_reg_pc = 0x04001B74;
	if (state.r[T2] == 0)
	{
		{
			_u32 addr = (0x00000010 + state.r[T8]);
			int shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				state.v[24].U32[0] = *(_u32 *)&pDMEM[addr+12];
				state.v[24].U32[1] = *(_u32 *)&pDMEM[addr+8];
				state.v[24].U32[2] = *(_u32 *)&pDMEM[addr+4];
				state.v[24].U32[3] = *(_u32 *)&pDMEM[addr];
			}
			else
			{
				_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
				_u64		value1 = Load64_DMEM(addr+8);
				_u64		value2 = Load64_DMEM(addr);
				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & temp1;
				value2 = value2 & temp2;

				state.v[24].U64[0] = state.v[24].U64[0] & ~temp1;
				state.v[24].U64[1] = state.v[24].U64[1] & ~temp2;
				state.v[24].U64[0] = state.v[24].U64[0] | value1;
				state.v[24].U64[1] = state.v[24].U64[1] | value2;
			}
		}
		goto _04001B84;
	}


_04001B78:	// 4001b78: <cb182001>	LQV       vec24 <00> = [T8 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[T8]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[24].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[24].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[24].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[24].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[24].U64[0] = state.v[24].U64[0] & ~temp1;
			state.v[24].U64[1] = state.v[24].U64[1] & ~temp2;
			state.v[24].U64[0] = state.v[24].U64[0] | value1;
			state.v[24].U64[1] = state.v[24].U64[1] | value2;
		}
	}


_04001B7C:	// 4001b7c: <090006ec>	J         04001bb0
	goto _04001BB0;


_04001B80:	// 4001b80: <00000000>	NOP       


_04001B84:	// 4001b84: <0d000461>	JAL	    04001184
	sp_reg_pc = 0x04001B84;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001184;


_04001B88:	// 4001b88: <00000000>	NOP       


_04001B8C:	// 4001b8c: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001B90:	// 4001b90: <14a0fffe>	BNE       (R0!=A1) --> 1b8c
	sp_reg_pc = 0x04001B90;
	if (state.r[A1] != 0)
	{
		goto _04001B8C;
	}


_04001B94:	// 4001b94: <00000000>	NOP       


_04001B98:	// 4001b98: <40803800>	MTC0      SP semaphore = R0


_04001B9C:	// 4001b9c: <caf42000>	LQV       vec20 <00> = [S7 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S7]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[20].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[20].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[20].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[20].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[20].U64[0] = state.v[20].U64[0] & ~temp1;
			state.v[20].U64[1] = state.v[20].U64[1] & ~temp2;
			state.v[20].U64[0] = state.v[20].U64[0] | value1;
			state.v[20].U64[1] = state.v[20].U64[1] | value2;
		}
	}


_04001BA0:	// 4001ba0: <caf52001>	LQV       vec21 <00> = [S7 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[S7]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[21].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[21].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[21].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[21].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[21].U64[0] = state.v[21].U64[0] & ~temp1;
			state.v[21].U64[1] = state.v[21].U64[1] & ~temp2;
			state.v[21].U64[0] = state.v[21].U64[0] | value1;
			state.v[21].U64[1] = state.v[21].U64[1] | value2;
		}
	}


_04001BA4:	// 4001ba4: <caf22002>	LQV       vec18 <00> = [S7 + 0x20]
	{
		_u32 addr = (0x00000020 + state.r[S7]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[18].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[18].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[18].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[18].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[18].U64[0] = state.v[18].U64[0] & ~temp1;
			state.v[18].U64[1] = state.v[18].U64[1] & ~temp2;
			state.v[18].U64[0] = state.v[18].U64[0] | value1;
			state.v[18].U64[1] = state.v[18].U64[1] | value2;
		}
	}


_04001BA8:	// 4001ba8: <caf32003>	LQV       vec19 <00> = [S7 + 0x30]
	{
		_u32 addr = (0x00000030 + state.r[S7]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[19].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[19].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[19].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[19].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[19].U64[0] = state.v[19].U64[0] & ~temp1;
			state.v[19].U64[1] = state.v[19].U64[1] & ~temp2;
			state.v[19].U64[0] = state.v[19].U64[0] | value1;
			state.v[19].U64[1] = state.v[19].U64[1] | value2;
		}
	}


_04001BAC:	// 4001bac: <caf82004>	LQV       vec24 <00> = [S7 + 0x40]
	{
		_u32 addr = (0x00000040 + state.r[S7]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[24].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[24].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[24].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[24].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[24].U64[0] = state.v[24].U64[0] & ~temp1;
			state.v[24].U64[1] = state.v[24].U64[1] & ~temp2;
			state.v[24].U64[0] = state.v[24].U64[0] | value1;
			state.v[24].U64[1] = state.v[24].U64[1] | value2;
		}
	}


_04001BB0:	// 4001bb0: <870d0000>	LH        T5 = [T8+0000]
	state.r[T5] = (_s32)(_s16)Load16_DMEM((state.r[T8] + 0x00000000) & 0xfff);


_04001BB4:	// 4001bb4: <87130002>	LH        S3 = [T8+0002]
	state.r[S3] = (_s32)(_s16)Load16_DMEM((state.r[T8] + 0x00000002) & 0xfff);


_04001BB8:	// 4001bb8: <8712000a>	LH        S2 = [T8+000a]
	state.r[S2] = (_s32)(_s16)Load16_DMEM((state.r[T8] + 0x0000000A) & 0xfff);


_04001BBC:	// 4001bbc: <8711000c>	LH        S1 = [T8+000c]
	state.r[S1] = (_s32)(_s16)Load16_DMEM((state.r[T8] + 0x0000000C) & 0xfff);


_04001BC0:	// 4001bc0: <8710000e>	LH        S0 = [T8+000e]
	state.r[S0] = (_s32)(_s16)Load16_DMEM((state.r[T8] + 0x0000000E) & 0xfff);


_04001BC4:	// 4001bc4: <870e0004>	LH        T6 = [T8+0004]
	state.r[T6] = (_s32)(_s16)Load16_DMEM((state.r[T8] + 0x00000004) & 0xfff);


_04001BC8:	// 4001bc8: <200f0010>	ADDI      T7 = R0 + 0010
	state.r[T7] = 0 + 0x0010;


_04001BCC:	// 4001bcc: <4815c100>	MFC2      S5 = vec24 <02>
	state.r[S5] = (_s32)state.v[24].S16[6];


_04001BD0:	// 4001bd0: <4814c400>	MFC2      S4 = vec24 <08>
	state.r[S4] = (_s32)state.v[24].S16[3];


_04001BD4:	// 4001bd4: <31890008>	ANDI      T1 = T4 & 0008
	state.r[T1] = (state.r[T4] & 0x00000008);


_04001BD8:	// 4001bd8: <1d200004>	BGTZ      (R0>0) --> 1bec
	sp_reg_pc = 0x04001BD8;
	if((_s32)state.r[T1] > 0)
	{
		goto _04001BEC;
	}


_04001BDC:	// 4001bdc: <00000000>	NOP       


_04001BE0:	// 4001be0: <22f10050>	ADDI      S1 = S7 + 0050
	state.r[S1] = state.r[S7] + 0x0050;


_04001BE4:	// 4001be4: <00118020>	ADD       S0 = R0+S1
	state.r[S0] = (0 + state.r[S1]);


_04001BE8:	// 4001be8: <200f0000>	ADDI      T7 = R0 + 0000
	state.r[T7] = 0 + 0x0000;


_04001BEC:	// 4001bec: <11400036>	BEQ       (R0==T2) --> 1cc8
	sp_reg_pc = 0x04001BEC;
	if (state.r[T2] == 0)
	{
		{
			_u32 addr = (0x00000070 + state.r[T3]);
			int shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				state.v[30].U32[0] = *(_u32 *)&pDMEM[addr+12];
				state.v[30].U32[1] = *(_u32 *)&pDMEM[addr+8];
				state.v[30].U32[2] = *(_u32 *)&pDMEM[addr+4];
				state.v[30].U32[3] = *(_u32 *)&pDMEM[addr];
			}
			else
			{
				_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
				_u64		value1 = Load64_DMEM(addr+8);
				_u64		value2 = Load64_DMEM(addr);
				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & temp1;
				value2 = value2 & temp2;

				state.v[30].U64[0] = state.v[30].U64[0] & ~temp1;
				state.v[30].U64[1] = state.v[30].U64[1] & ~temp2;
				state.v[30].U64[0] = state.v[30].U64[0] | value1;
				state.v[30].U64[1] = state.v[30].U64[1] | value2;
			}
		}
		goto _04001CC8;
	}


_04001BF0:	// 4001bf0: <c97e2007>	LQV       vec30 <00> = [T3 + 0x70]
	{
		_u32 addr = (0x00000070 + state.r[T3]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[30].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[30].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[30].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[30].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[30].U64[0] = state.v[30].U64[0] & ~temp1;
			state.v[30].U64[1] = state.v[30].U64[1] & ~temp2;
			state.v[30].U64[0] = state.v[30].U64[0] | value1;
			state.v[30].U64[1] = state.v[30].U64[1] | value2;
		}
	}


_04001BF4:	// 4001bf4: <c9b12000>	LQV       vec17 <00> = [T5 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[T5]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[17].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[17].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[17].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[17].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[17].U64[0] = state.v[17].U64[0] & ~temp1;
			state.v[17].U64[1] = state.v[17].U64[1] & ~temp2;
			state.v[17].U64[0] = state.v[17].U64[0] | value1;
			state.v[17].U64[1] = state.v[17].U64[1] | value2;
		}
	}


_04001BF8:	// 4001bf8: <ca7d2000>	LQV       vec29 <00> = [S3 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S3]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[29].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[29].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[29].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[29].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[29].U64[0] = state.v[29].U64[0] & ~temp1;
			state.v[29].U64[1] = state.v[29].U64[1] & ~temp2;
			state.v[29].U64[0] = state.v[29].U64[0] | value1;
			state.v[29].U64[1] = state.v[29].U64[1] | value2;
		}
	}


_04001BFC:	// 4001bfc: <ca3b2000>	LQV       vec27 <00> = [S1 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
			state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
			state.v[27].U64[0] = state.v[27].U64[0] | value1;
			state.v[27].U64[1] = state.v[27].U64[1] | value2;
		}
	}


_04001C00:	// 4001c00: <4a15ad6c>	VXOR      vec21 = vec21 xor vec21[<none>]
	rsp_cop2_vxor(&state.v[21], &state.v[21], &state.v[21]);


_04001C04:	// 4001c04: <cb140f03>	LSV       vec20 <14> = [T8 + 0x06]
	state.v[20].U16[0] = Load16_DMEM(0x00000006 + state.r[T8]);


_04001C08:	// 4001c08: <4b58f5c4>	VMUDL     vec23 = ( acc = (vec30 * vec24[2] >> 16)      )
	{
		__asm {
			MOVQ mm0, state.v[30*16].U16[0]
			MOVQ mm1, state.v[30*16].U16[4*2]
			PSHUFW mm4, state.v[24*16].U16[5*2], 0
			PMULHUW mm0, mm4
			PMULHUW mm1, mm4
			MOVQ accumulator[0*4], mm0
			MOVQ accumulator[2*4], mm1
			PXOR mm7, mm7
			MOVQ accumulator_hi[0*4], mm7
			MOVQ accumulator_hi[2*4], mm7
			MOVQ accumulator_hi[4*4], mm7
			MOVQ accumulator_hi[6*4], mm7
		}
	}


_04001C0C:	// 4001c0c: <4b38f5ce>	VMADN     vec23 = ( acc+= vec30 * vec24[1] )
	{
		_u16		s2value = state.v[24].U16[6];
		VMADN_operation(0, state.v[23].U16[0], state.v[30].U16[0], s2value, 1, 1, 1, 1)
		VMADN_operation(1, state.v[23].U16[1], state.v[30].U16[1], s2value, 1, 1, 1, 1)
		VMADN_operation(2, state.v[23].U16[2], state.v[30].U16[2], s2value, 1, 1, 1, 1)
		VMADN_operation(3, state.v[23].U16[3], state.v[30].U16[3], s2value, 1, 1, 1, 1)
		VMADN_operation(4, state.v[23].U16[4], state.v[30].U16[4], s2value, 1, 1, 1, 1)
		VMADN_operation(5, state.v[23].U16[5], state.v[30].U16[5], s2value, 1, 1, 1, 1)
		VMADN_operation(6, state.v[23].U16[6], state.v[30].U16[6], s2value, 1, 1, 1, 1)
		VMADN_operation(7, state.v[23].U16[7], state.v[30].U16[7], s2value, 1, 1, 1, 1)
	}


_04001C10:	// 4001c10: <4b00fd8d>	VMADM     vec22 = ( acc+= vec31 * vec00[0] ) >> 16
	{
		_u16		s2value = state.v[0].U16[7];
		VMADM_operation(0, state.v[22].U16[0], state.v[31].U16[0], s2value, 1, 1, 1, 1)
		VMADM_operation(1, state.v[22].U16[1], state.v[31].U16[1], s2value, 1, 1, 1, 1)
		VMADM_operation(2, state.v[22].U16[2], state.v[31].U16[2], s2value, 1, 1, 1, 1)
		VMADM_operation(3, state.v[22].U16[3], state.v[31].U16[3], s2value, 1, 1, 1, 1)
		VMADM_operation(4, state.v[22].U16[4], state.v[31].U16[4], s2value, 1, 1, 1, 1)
		VMADM_operation(5, state.v[22].U16[5], state.v[31].U16[5], s2value, 1, 1, 1, 1)
		VMADM_operation(6, state.v[22].U16[6], state.v[31].U16[6], s2value, 1, 1, 1, 1)
		VMADM_operation(7, state.v[22].U16[7], state.v[31].U16[7], s2value, 1, 1, 1, 1)
	}


_04001C14:	// 4001c14: <4bf5fd4d>	VMADM     vec21 = ( acc+= vec31 * vec21[7] ) >> 16
	{
		_u16		s2value = state.v[21].U16[0];
		VMADM_operation(0, state.v[21].U16[0], state.v[31].U16[0], s2value, 1, 1, 1, 1)
		VMADM_operation(1, state.v[21].U16[1], state.v[31].U16[1], s2value, 1, 1, 1, 1)
		VMADM_operation(2, state.v[21].U16[2], state.v[31].U16[2], s2value, 1, 1, 1, 1)
		VMADM_operation(3, state.v[21].U16[3], state.v[31].U16[3], s2value, 1, 1, 1, 1)
		VMADM_operation(4, state.v[21].U16[4], state.v[31].U16[4], s2value, 1, 1, 1, 1)
		VMADM_operation(5, state.v[21].U16[5], state.v[31].U16[5], s2value, 1, 1, 1, 1)
		VMADM_operation(6, state.v[21].U16[6], state.v[31].U16[6], s2value, 1, 1, 1, 1)
		VMADM_operation(7, state.v[21].U16[7], state.v[31].U16[7], s2value, 1, 1, 1, 1)
	}


_04001C18:	// 4001c18: <4bf4fd0f>	VMADH     vec20 = ( acc+= (vec31 * vec20[7]) << 16) >> 16
	{
		_u16		s2value = state.v[20].U16[0];
		VMADH_operation(0, state.v[20].U16[0], state.v[31].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[20].U16[1], state.v[31].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[20].U16[2], state.v[31].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[20].U16[3], state.v[31].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[20].U16[4], state.v[31].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[20].U16[5], state.v[31].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[20].U16[6], state.v[31].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[20].U16[7], state.v[31].U16[7], s2value, 1, 1, 0, 1)
	}


_04001C1C:	// 4001c1c: <1ea00004>	BGTZ      (R0>0) --> 1c30
	sp_reg_pc = 0x04001C1C;
	if((_s32)state.r[S5] > 0)
	{
		{
			_u16		s2value = state.v[0].U16[7];
			VMADN_operation(0, state.v[21].U16[0], state.v[31].U16[0], s2value, 1, 1, 1, 1)
			VMADN_operation(1, state.v[21].U16[1], state.v[31].U16[1], s2value, 1, 1, 1, 1)
			VMADN_operation(2, state.v[21].U16[2], state.v[31].U16[2], s2value, 1, 1, 1, 1)
			VMADN_operation(3, state.v[21].U16[3], state.v[31].U16[3], s2value, 1, 1, 1, 1)
			VMADN_operation(4, state.v[21].U16[4], state.v[31].U16[4], s2value, 1, 1, 1, 1)
			VMADN_operation(5, state.v[21].U16[5], state.v[31].U16[5], s2value, 1, 1, 1, 1)
			VMADN_operation(6, state.v[21].U16[6], state.v[31].U16[6], s2value, 1, 1, 1, 1)
			VMADN_operation(7, state.v[21].U16[7], state.v[31].U16[7], s2value, 1, 1, 1, 1)
		}
		goto _04001C30;
	}


_04001C20:	// 4001c20: <4b00fd4e>	VMADN     vec21 = ( acc+= vec31 * vec00[0] )
	{
		_u16		s2value = state.v[0].U16[7];
		VMADN_operation(0, state.v[21].U16[0], state.v[31].U16[0], s2value, 1, 1, 1, 1)
		VMADN_operation(1, state.v[21].U16[1], state.v[31].U16[1], s2value, 1, 1, 1, 1)
		VMADN_operation(2, state.v[21].U16[2], state.v[31].U16[2], s2value, 1, 1, 1, 1)
		VMADN_operation(3, state.v[21].U16[3], state.v[31].U16[3], s2value, 1, 1, 1, 1)
		VMADN_operation(4, state.v[21].U16[4], state.v[31].U16[4], s2value, 1, 1, 1, 1)
		VMADN_operation(5, state.v[21].U16[5], state.v[31].U16[5], s2value, 1, 1, 1, 1)
		VMADN_operation(6, state.v[21].U16[6], state.v[31].U16[6], s2value, 1, 1, 1, 1)
		VMADN_operation(7, state.v[21].U16[7], state.v[31].U16[7], s2value, 1, 1, 1, 1)
	}


_04001C24:	// 4001c24: <4b18a523>	VGE       vec20 = (vec20 >= vec24[0])
	rsp_cop2_vge_element(&state.v[20], &state.v[20], &state.v[24].U16[7]);


_04001C28:	// 4001c28: <0900070d>	J         04001c34
	goto _04001C34;


_04001C2C:	// 4001c2c: <00000000>	NOP       


_04001C30:	// 4001c30: <4b18a524>	VCL ?-?
	rsp_cop2_vcl_element(&state.v[20], &state.v[20], &state.v[24].U16[7]);


_04001C34:	// 4001c34: <4bd8a400>	VMULF     vec16 = ( acc = (vec20 * vec24[6]) << 1 ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[20*16].U16[0]
			MOVQ mm1, state.v[20*16].U16[4*2]
			PSHUFW mm4, state.v[24*16].U16[1*2], 0
			MOVQ mm6, mm0
			MOVQ mm7, mm1
			PMULLW mm0, mm4
			PMULLW mm1, mm4
			//mm2 = result << 1
			MOVQ    mm2, mm0
			MOVQ   mm3, mm1
			PSLLW   mm2, 1
			PSLLW  mm3, 1
			//mm6 = result >> 15
			PMULHW  mm6, mm4
			PMULHW  mm7, mm4
			//get 0x4000 bit of result
			PSRLW   mm2, 14 ; get last 3 bits to add
			PSRLW   mm3, 14
			//if (result & 0x4000) hiValue++;
			PADDSW  mm6, mm2 ;hiValue + (1, 2, 3 or 0)
			PADDSW  mm7, mm3
			PSLLW   mm6, 1
			PSLLW   mm7, 1
			MOVQ state.v[16*16].U16[0], mm6
			MOVQ state.v[16*16].U16[4*2], mm7
		}
	}


_04001C38:	// 4001c38: <4bf8a3c0>	VMULF     vec15 = ( acc = (vec20 * vec24[7]) << 1 ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[20*16].U16[0]
			MOVQ mm1, state.v[20*16].U16[4*2]
			PSHUFW mm4, state.v[24*16].U16[0*2], 0
			MOVQ mm6, mm0
			MOVQ mm7, mm1
			PMULLW mm0, mm4
			PMULLW mm1, mm4
			//mm2 = result << 1
			MOVQ    mm2, mm0
			MOVQ   mm3, mm1
			PSLLW   mm2, 1
			PSLLW  mm3, 1
			//mm6 = result >> 15
			PMULHW  mm6, mm4
			PMULHW  mm7, mm4
			//get 0x4000 bit of result
			PSRLW   mm2, 14 ; get last 3 bits to add
			PSRLW   mm3, 14
			//if (result & 0x4000) hiValue++;
			PADDSW  mm6, mm2 ;hiValue + (1, 2, 3 or 0)
			PADDSW  mm7, mm3
			PSLLW   mm6, 1
			PSLLW   mm7, 1
			MOVQ state.v[15*16].U16[0], mm6
			MOVQ state.v[15*16].U16[4*2], mm7
		}
	}


_04001C3C:	// 4001c3c: <4bcaef40>	VMULF     vec29 = ( acc = (vec29 * vec10[6]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[1];
		VMULF_operation(0, state.v[29].U16[0], state.v[29].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[29].U16[1], state.v[29].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[29].U16[2], state.v[29].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[29].U16[3], state.v[29].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[29].U16[4], state.v[29].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[29].U16[5], state.v[29].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[29].U16[6], state.v[29].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[29].U16[7], state.v[29].U16[7], s2value, 0, 1, 1, 1)
	}


_04001C40:	// 4001c40: <4a108f48>	VMACF     vec29 = ( acc += (vec17 * vec16[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[29].U16[0], state.v[17].U16[0], state.v[16].U16[0], 1, 0, 0, 1)
		VMACF_operation(1, state.v[29].U16[1], state.v[17].U16[1], state.v[16].U16[1], 1, 0, 0, 1)
		VMACF_operation(2, state.v[29].U16[2], state.v[17].U16[2], state.v[16].U16[2], 1, 0, 0, 1)
		VMACF_operation(3, state.v[29].U16[3], state.v[17].U16[3], state.v[16].U16[3], 1, 0, 0, 1)
		VMACF_operation(4, state.v[29].U16[4], state.v[17].U16[4], state.v[16].U16[4], 1, 0, 0, 1)
		VMACF_operation(5, state.v[29].U16[5], state.v[17].U16[5], state.v[16].U16[5], 1, 0, 0, 1)
		VMACF_operation(6, state.v[29].U16[6], state.v[17].U16[6], state.v[16].U16[6], 1, 0, 0, 1)
		VMACF_operation(7, state.v[29].U16[7], state.v[17].U16[7], state.v[16].U16[7], 1, 0, 0, 1)
	}


_04001C44:	// 4001c44: <4bcadec0>	VMULF     vec27 = ( acc = (vec27 * vec10[6]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[1];
		VMULF_operation(0, state.v[27].U16[0], state.v[27].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[27].U16[1], state.v[27].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[27].U16[2], state.v[27].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[27].U16[3], state.v[27].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[27].U16[4], state.v[27].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[27].U16[5], state.v[27].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[27].U16[6], state.v[27].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[27].U16[7], state.v[27].U16[7], s2value, 0, 1, 1, 1)
	}


_04001C48:	// 4001c48: <4a0f8ec8>	VMACF     vec27 = ( acc += (vec17 * vec15[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[27].U16[0], state.v[17].U16[0], state.v[15].U16[0], 1, 0, 0, 1)
		VMACF_operation(1, state.v[27].U16[1], state.v[17].U16[1], state.v[15].U16[1], 1, 0, 0, 1)
		VMACF_operation(2, state.v[27].U16[2], state.v[17].U16[2], state.v[15].U16[2], 1, 0, 0, 1)
		VMACF_operation(3, state.v[27].U16[3], state.v[17].U16[3], state.v[15].U16[3], 1, 0, 0, 1)
		VMACF_operation(4, state.v[27].U16[4], state.v[17].U16[4], state.v[15].U16[4], 1, 0, 0, 1)
		VMACF_operation(5, state.v[27].U16[5], state.v[17].U16[5], state.v[15].U16[5], 1, 0, 0, 1)
		VMACF_operation(6, state.v[27].U16[6], state.v[17].U16[6], state.v[15].U16[6], 1, 0, 0, 1)
		VMACF_operation(7, state.v[27].U16[7], state.v[17].U16[7], state.v[15].U16[7], 1, 0, 0, 1)
	}


_04001C4C:	// 4001c4c: <ea7d2000>	SQV       [S3 + 0x00] = vec29 <00>
	{
		_u32    addr = (0x00000000 + state.r[S3]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[29].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[29].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[29].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[29].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[29].U64[0] & temp1);
			value2 |= (state.v[29].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001C50:	// 4001c50: <ea3b2000>	SQV       [S1 + 0x00] = vec27 <00>
	{
		_u32    addr = (0x00000000 + state.r[S1]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[27].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[27].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[27].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[27].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[27].U64[0] & temp1);
			value2 |= (state.v[27].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001C54:	// 4001c54: <ca5c2000>	LQV       vec28 <00> = [S2 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S2]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[28].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[28].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[28].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[28].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[28].U64[0] = state.v[28].U64[0] & ~temp1;
			state.v[28].U64[1] = state.v[28].U64[1] & ~temp2;
			state.v[28].U64[0] = state.v[28].U64[0] | value1;
			state.v[28].U64[1] = state.v[28].U64[1] | value2;
		}
	}


_04001C58:	// 4001c58: <ca1a2000>	LQV       vec26 <00> = [S0 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S0]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[26].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[26].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[26].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[26].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[26].U64[0] = state.v[26].U64[0] & ~temp1;
			state.v[26].U64[1] = state.v[26].U64[1] & ~temp2;
			state.v[26].U64[0] = state.v[26].U64[0] | value1;
			state.v[26].U64[1] = state.v[26].U64[1] | value2;
		}
	}


_04001C5C:	// 4001c5c: <4a139cec>	VXOR      vec19 = vec19 xor vec19[<none>]
	rsp_cop2_vxor(&state.v[19], &state.v[19], &state.v[19]);


_04001C60:	// 4001c60: <cb120f04>	LSV       vec18 <14> = [T8 + 0x08]
	state.v[18].U16[0] = Load16_DMEM(0x00000008 + state.r[T8]);


_04001C64:	// 4001c64: <4bb8f5c4>	VMUDL     vec23 = ( acc = (vec30 * vec24[5] >> 16)      )
	{
		__asm {
			MOVQ mm0, state.v[30*16].U16[0]
			MOVQ mm1, state.v[30*16].U16[4*2]
			PSHUFW mm4, state.v[24*16].U16[2*2], 0
			PMULHUW mm0, mm4
			PMULHUW mm1, mm4
			MOVQ accumulator[0*4], mm0
			MOVQ accumulator[2*4], mm1
			PXOR mm7, mm7
			MOVQ accumulator_hi[0*4], mm7
			MOVQ accumulator_hi[2*4], mm7
			MOVQ accumulator_hi[4*4], mm7
			MOVQ accumulator_hi[6*4], mm7
		}
	}


_04001C68:	// 4001c68: <4b98f5ce>	VMADN     vec23 = ( acc+= vec30 * vec24[4] )
	{
		_u16		s2value = state.v[24].U16[3];
		VMADN_operation(0, state.v[23].U16[0], state.v[30].U16[0], s2value, 1, 1, 1, 1)
		VMADN_operation(1, state.v[23].U16[1], state.v[30].U16[1], s2value, 1, 1, 1, 1)
		VMADN_operation(2, state.v[23].U16[2], state.v[30].U16[2], s2value, 1, 1, 1, 1)
		VMADN_operation(3, state.v[23].U16[3], state.v[30].U16[3], s2value, 1, 1, 1, 1)
		VMADN_operation(4, state.v[23].U16[4], state.v[30].U16[4], s2value, 1, 1, 1, 1)
		VMADN_operation(5, state.v[23].U16[5], state.v[30].U16[5], s2value, 1, 1, 1, 1)
		VMADN_operation(6, state.v[23].U16[6], state.v[30].U16[6], s2value, 1, 1, 1, 1)
		VMADN_operation(7, state.v[23].U16[7], state.v[30].U16[7], s2value, 1, 1, 1, 1)
	}


_04001C6C:	// 4001c6c: <4b00fd8d>	VMADM     vec22 = ( acc+= vec31 * vec00[0] ) >> 16
	{
		_u16		s2value = state.v[0].U16[7];
		VMADM_operation(0, state.v[22].U16[0], state.v[31].U16[0], s2value, 1, 1, 1, 1)
		VMADM_operation(1, state.v[22].U16[1], state.v[31].U16[1], s2value, 1, 1, 1, 1)
		VMADM_operation(2, state.v[22].U16[2], state.v[31].U16[2], s2value, 1, 1, 1, 1)
		VMADM_operation(3, state.v[22].U16[3], state.v[31].U16[3], s2value, 1, 1, 1, 1)
		VMADM_operation(4, state.v[22].U16[4], state.v[31].U16[4], s2value, 1, 1, 1, 1)
		VMADM_operation(5, state.v[22].U16[5], state.v[31].U16[5], s2value, 1, 1, 1, 1)
		VMADM_operation(6, state.v[22].U16[6], state.v[31].U16[6], s2value, 1, 1, 1, 1)
		VMADM_operation(7, state.v[22].U16[7], state.v[31].U16[7], s2value, 1, 1, 1, 1)
	}


_04001C70:	// 4001c70: <4bf3fccd>	VMADM     vec19 = ( acc+= vec31 * vec19[7] ) >> 16
	{
		_u16		s2value = state.v[19].U16[0];
		VMADM_operation(0, state.v[19].U16[0], state.v[31].U16[0], s2value, 1, 1, 1, 1)
		VMADM_operation(1, state.v[19].U16[1], state.v[31].U16[1], s2value, 1, 1, 1, 1)
		VMADM_operation(2, state.v[19].U16[2], state.v[31].U16[2], s2value, 1, 1, 1, 1)
		VMADM_operation(3, state.v[19].U16[3], state.v[31].U16[3], s2value, 1, 1, 1, 1)
		VMADM_operation(4, state.v[19].U16[4], state.v[31].U16[4], s2value, 1, 1, 1, 1)
		VMADM_operation(5, state.v[19].U16[5], state.v[31].U16[5], s2value, 1, 1, 1, 1)
		VMADM_operation(6, state.v[19].U16[6], state.v[31].U16[6], s2value, 1, 1, 1, 1)
		VMADM_operation(7, state.v[19].U16[7], state.v[31].U16[7], s2value, 1, 1, 1, 1)
	}


_04001C74:	// 4001c74: <4bf2fc8f>	VMADH     vec18 = ( acc+= (vec31 * vec18[7]) << 16) >> 16
	{
		_u16		s2value = state.v[18].U16[0];
		VMADH_operation(0, state.v[18].U16[0], state.v[31].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[18].U16[1], state.v[31].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[18].U16[2], state.v[31].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[18].U16[3], state.v[31].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[18].U16[4], state.v[31].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[18].U16[5], state.v[31].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[18].U16[6], state.v[31].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[18].U16[7], state.v[31].U16[7], s2value, 1, 1, 0, 1)
	}


_04001C78:	// 4001c78: <1e800004>	BGTZ      (R0>0) --> 1c8c
	sp_reg_pc = 0x04001C78;
	if((_s32)state.r[S4] > 0)
	{
		{
			_u16		s2value = state.v[0].U16[7];
			VMADN_operation(0, state.v[19].U16[0], state.v[31].U16[0], s2value, 1, 1, 1, 1)
			VMADN_operation(1, state.v[19].U16[1], state.v[31].U16[1], s2value, 1, 1, 1, 1)
			VMADN_operation(2, state.v[19].U16[2], state.v[31].U16[2], s2value, 1, 1, 1, 1)
			VMADN_operation(3, state.v[19].U16[3], state.v[31].U16[3], s2value, 1, 1, 1, 1)
			VMADN_operation(4, state.v[19].U16[4], state.v[31].U16[4], s2value, 1, 1, 1, 1)
			VMADN_operation(5, state.v[19].U16[5], state.v[31].U16[5], s2value, 1, 1, 1, 1)
			VMADN_operation(6, state.v[19].U16[6], state.v[31].U16[6], s2value, 1, 1, 1, 1)
			VMADN_operation(7, state.v[19].U16[7], state.v[31].U16[7], s2value, 1, 1, 1, 1)
		}
		goto _04001C8C;
	}


_04001C7C:	// 4001c7c: <4b00fcce>	VMADN     vec19 = ( acc+= vec31 * vec00[0] )
	{
		_u16		s2value = state.v[0].U16[7];
		VMADN_operation(0, state.v[19].U16[0], state.v[31].U16[0], s2value, 1, 1, 1, 1)
		VMADN_operation(1, state.v[19].U16[1], state.v[31].U16[1], s2value, 1, 1, 1, 1)
		VMADN_operation(2, state.v[19].U16[2], state.v[31].U16[2], s2value, 1, 1, 1, 1)
		VMADN_operation(3, state.v[19].U16[3], state.v[31].U16[3], s2value, 1, 1, 1, 1)
		VMADN_operation(4, state.v[19].U16[4], state.v[31].U16[4], s2value, 1, 1, 1, 1)
		VMADN_operation(5, state.v[19].U16[5], state.v[31].U16[5], s2value, 1, 1, 1, 1)
		VMADN_operation(6, state.v[19].U16[6], state.v[31].U16[6], s2value, 1, 1, 1, 1)
		VMADN_operation(7, state.v[19].U16[7], state.v[31].U16[7], s2value, 1, 1, 1, 1)
	}


_04001C80:	// 4001c80: <4b7894a3>	VGE       vec18 = (vec18 >= vec24[3])
	rsp_cop2_vge_element(&state.v[18], &state.v[18], &state.v[24].U16[4]);


_04001C84:	// 4001c84: <09000724>	J         04001c90
	goto _04001C90;


_04001C88:	// 4001c88: <00000000>	NOP       


_04001C8C:	// 4001c8c: <4b7894a4>	VCL ?-?
	rsp_cop2_vcl_element(&state.v[18], &state.v[18], &state.v[24].U16[4]);


_04001C90:	// 4001c90: <4bd89400>	VMULF     vec16 = ( acc = (vec18 * vec24[6]) << 1 ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[18*16].U16[0]
			MOVQ mm1, state.v[18*16].U16[4*2]
			PSHUFW mm4, state.v[24*16].U16[1*2], 0
			MOVQ mm6, mm0
			MOVQ mm7, mm1
			PMULLW mm0, mm4
			PMULLW mm1, mm4
			//mm2 = result << 1
			MOVQ    mm2, mm0
			MOVQ   mm3, mm1
			PSLLW   mm2, 1
			PSLLW  mm3, 1
			//mm6 = result >> 15
			PMULHW  mm6, mm4
			PMULHW  mm7, mm4
			//get 0x4000 bit of result
			PSRLW   mm2, 14 ; get last 3 bits to add
			PSRLW   mm3, 14
			//if (result & 0x4000) hiValue++;
			PADDSW  mm6, mm2 ;hiValue + (1, 2, 3 or 0)
			PADDSW  mm7, mm3
			PSLLW   mm6, 1
			PSLLW   mm7, 1
			MOVQ state.v[16*16].U16[0], mm6
			MOVQ state.v[16*16].U16[4*2], mm7
		}
	}


_04001C94:	// 4001c94: <4bf893c0>	VMULF     vec15 = ( acc = (vec18 * vec24[7]) << 1 ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[18*16].U16[0]
			MOVQ mm1, state.v[18*16].U16[4*2]
			PSHUFW mm4, state.v[24*16].U16[0*2], 0
			MOVQ mm6, mm0
			MOVQ mm7, mm1
			PMULLW mm0, mm4
			PMULLW mm1, mm4
			//mm2 = result << 1
			MOVQ    mm2, mm0
			MOVQ   mm3, mm1
			PSLLW   mm2, 1
			PSLLW  mm3, 1
			//mm6 = result >> 15
			PMULHW  mm6, mm4
			PMULHW  mm7, mm4
			//get 0x4000 bit of result
			PSRLW   mm2, 14 ; get last 3 bits to add
			PSRLW   mm3, 14
			//if (result & 0x4000) hiValue++;
			PADDSW  mm6, mm2 ;hiValue + (1, 2, 3 or 0)
			PADDSW  mm7, mm3
			PSLLW   mm6, 1
			PSLLW   mm7, 1
			MOVQ state.v[15*16].U16[0], mm6
			MOVQ state.v[15*16].U16[4*2], mm7
		}
	}


_04001C98:	// 4001c98: <4bcae700>	VMULF     vec28 = ( acc = (vec28 * vec10[6]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[1];
		VMULF_operation(0, state.v[28].U16[0], state.v[28].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[28].U16[1], state.v[28].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[28].U16[2], state.v[28].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[28].U16[3], state.v[28].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[28].U16[4], state.v[28].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[28].U16[5], state.v[28].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[28].U16[6], state.v[28].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[28].U16[7], state.v[28].U16[7], s2value, 0, 1, 1, 1)
	}


_04001C9C:	// 4001c9c: <4a108f08>	VMACF     vec28 = ( acc += (vec17 * vec16[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[28].U16[0], state.v[17].U16[0], state.v[16].U16[0], 1, 0, 0, 1)
		VMACF_operation(1, state.v[28].U16[1], state.v[17].U16[1], state.v[16].U16[1], 1, 0, 0, 1)
		VMACF_operation(2, state.v[28].U16[2], state.v[17].U16[2], state.v[16].U16[2], 1, 0, 0, 1)
		VMACF_operation(3, state.v[28].U16[3], state.v[17].U16[3], state.v[16].U16[3], 1, 0, 0, 1)
		VMACF_operation(4, state.v[28].U16[4], state.v[17].U16[4], state.v[16].U16[4], 1, 0, 0, 1)
		VMACF_operation(5, state.v[28].U16[5], state.v[17].U16[5], state.v[16].U16[5], 1, 0, 0, 1)
		VMACF_operation(6, state.v[28].U16[6], state.v[17].U16[6], state.v[16].U16[6], 1, 0, 0, 1)
		VMACF_operation(7, state.v[28].U16[7], state.v[17].U16[7], state.v[16].U16[7], 1, 0, 0, 1)
	}


_04001CA0:	// 4001ca0: <4bcad680>	VMULF     vec26 = ( acc = (vec26 * vec10[6]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[1];
		VMULF_operation(0, state.v[26].U16[0], state.v[26].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[26].U16[1], state.v[26].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[26].U16[2], state.v[26].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[26].U16[3], state.v[26].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[26].U16[4], state.v[26].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[26].U16[5], state.v[26].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[26].U16[6], state.v[26].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[26].U16[7], state.v[26].U16[7], s2value, 0, 1, 1, 1)
	}


_04001CA4:	// 4001ca4: <4a0f8e88>	VMACF     vec26 = ( acc += (vec17 * vec15[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[26].U16[0], state.v[17].U16[0], state.v[15].U16[0], 1, 1, 1, 1)
		VMACF_operation(1, state.v[26].U16[1], state.v[17].U16[1], state.v[15].U16[1], 1, 1, 1, 1)
		VMACF_operation(2, state.v[26].U16[2], state.v[17].U16[2], state.v[15].U16[2], 1, 1, 1, 1)
		VMACF_operation(3, state.v[26].U16[3], state.v[17].U16[3], state.v[15].U16[3], 1, 1, 1, 1)
		VMACF_operation(4, state.v[26].U16[4], state.v[17].U16[4], state.v[15].U16[4], 1, 1, 1, 1)
		VMACF_operation(5, state.v[26].U16[5], state.v[17].U16[5], state.v[15].U16[5], 1, 1, 1, 1)
		VMACF_operation(6, state.v[26].U16[6], state.v[17].U16[6], state.v[15].U16[6], 1, 1, 1, 1)
		VMACF_operation(7, state.v[26].U16[7], state.v[17].U16[7], state.v[15].U16[7], 1, 1, 1, 1)
	}


_04001CA8:	// 4001ca8: <ea5c2000>	SQV       [S2 + 0x00] = vec28 <00>
	{
		_u32    addr = (0x00000000 + state.r[S2]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[28].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[28].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[28].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[28].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[28].U64[0] & temp1);
			value2 |= (state.v[28].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001CAC:	// 4001cac: <ea1a2000>	SQV       [S0 + 0x00] = vec26 <00>
	{
		_u32    addr = (0x00000000 + state.r[S0]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[26].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[26].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[26].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[26].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[26].U64[0] & temp1);
			value2 |= (state.v[26].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001CB0:	// 4001cb0: <21cefff0>	ADDI      T6 = T6 + fff0
	state.r[T6] = state.r[T6] + 0xFFFFFFF0;


_04001CB4:	// 4001cb4: <21ad0010>	ADDI      T5 = T5 + 0010
	state.r[T5] = state.r[T5] + 0x0010;


_04001CB8:	// 4001cb8: <22730010>	ADDI      S3 = S3 + 0010
	state.r[S3] = state.r[S3] + 0x0010;


_04001CBC:	// 4001cbc: <22520010>	ADDI      S2 = S2 + 0010
	state.r[S2] = state.r[S2] + 0x0010;


_04001CC0:	// 4001cc0: <022f8820>	ADD       S1 = S1+T7
	state.r[S1] = (state.r[S1] + state.r[T7]);


_04001CC4:	// 4001cc4: <020f8020>	ADD       S0 = S0+T7
	state.r[S0] = (state.r[S0] + state.r[T7]);


_04001CC8:	// 4001cc8: <4b58ad54>	VADDC	vec21 = vec21 + vec24[2]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[24].U16[5];
		VADDC_operation(0, state.v[21].U16[0], state.v[21].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[21].U16[1], state.v[21].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[21].U16[2], state.v[21].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[21].U16[3], state.v[21].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[21].U16[4], state.v[21].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[21].U16[5], state.v[21].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[21].U16[6], state.v[21].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[21].U16[7], state.v[21].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_04001CCC:	// 4001ccc: <4b38a510>	VADD      vec20 = vec20 + vec24[1]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[24].U16[6];
		VADD_operation(0, state.v[20].U16[0], state.v[20].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[20].U16[1], state.v[20].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[20].U16[2], state.v[20].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[20].U16[3], state.v[20].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[20].U16[4], state.v[20].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[20].U16[5], state.v[20].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[20].U16[6], state.v[20].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[20].U16[7], state.v[20].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001CD0:	// 4001cd0: <1ea00008>	BGTZ      (R0>0) --> 1cf4
	sp_reg_pc = 0x04001CD0;
	if((_s32)state.r[S5] > 0)
	{
		{
			_u32 addr = (0x00000000 + state.r[T5]);
			int shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				state.v[17].U32[0] = *(_u32 *)&pDMEM[addr+12];
				state.v[17].U32[1] = *(_u32 *)&pDMEM[addr+8];
				state.v[17].U32[2] = *(_u32 *)&pDMEM[addr+4];
				state.v[17].U32[3] = *(_u32 *)&pDMEM[addr];
			}
			else
			{
				_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
				_u64		value1 = Load64_DMEM(addr+8);
				_u64		value2 = Load64_DMEM(addr);
				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & temp1;
				value2 = value2 & temp2;

				state.v[17].U64[0] = state.v[17].U64[0] & ~temp1;
				state.v[17].U64[1] = state.v[17].U64[1] & ~temp2;
				state.v[17].U64[0] = state.v[17].U64[0] | value1;
				state.v[17].U64[1] = state.v[17].U64[1] | value2;
			}
		}
		goto _04001CF4;
	}


_04001CD4:	// 4001cd4: <c9b12000>	LQV       vec17 <00> = [T5 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[T5]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[17].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[17].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[17].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[17].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[17].U64[0] = state.v[17].U64[0] & ~temp1;
			state.v[17].U64[1] = state.v[17].U64[1] & ~temp2;
			state.v[17].U64[0] = state.v[17].U64[0] | value1;
			state.v[17].U64[1] = state.v[17].U64[1] | value2;
		}
	}


_04001CD8:	// 4001cd8: <4b18a523>	VGE       vec20 = (vec20 >= vec24[0])
	rsp_cop2_vge_element(&state.v[20], &state.v[20], &state.v[24].U16[7]);


_04001CDC:	// 4001cdc: <4bb89cd4>	VADDC	vec19 = vec19 + vec24[5]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[24].U16[2];
		VADDC_operation(0, state.v[19].U16[0], state.v[19].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[19].U16[1], state.v[19].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[19].U16[2], state.v[19].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[19].U16[3], state.v[19].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[19].U16[4], state.v[19].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[19].U16[5], state.v[19].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[19].U16[6], state.v[19].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[19].U16[7], state.v[19].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_04001CE0:	// 4001ce0: <ca7d2000>	LQV       vec29 <00> = [S3 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S3]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[29].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[29].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[29].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[29].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[29].U64[0] = state.v[29].U64[0] & ~temp1;
			state.v[29].U64[1] = state.v[29].U64[1] & ~temp2;
			state.v[29].U64[0] = state.v[29].U64[0] | value1;
			state.v[29].U64[1] = state.v[29].U64[1] | value2;
		}
	}


_04001CE4:	// 4001ce4: <4b989490>	VADD      vec18 = vec18 + vec24[4]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[24].U16[3];
		VADD_operation(0, state.v[18].U16[0], state.v[18].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[18].U16[1], state.v[18].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[18].U16[2], state.v[18].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[18].U16[3], state.v[18].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[18].U16[4], state.v[18].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[18].U16[5], state.v[18].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[18].U16[6], state.v[18].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[18].U16[7], state.v[18].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001CE8:	// 4001ce8: <ca3b2000>	LQV       vec27 <00> = [S1 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
			state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
			state.v[27].U64[0] = state.v[27].U64[0] | value1;
			state.v[27].U64[1] = state.v[27].U64[1] | value2;
		}
	}


_04001CEC:	// 4001cec: <09000742>	J         04001d08
	goto _04001D08;


_04001CF0:	// 4001cf0: <00000000>	NOP       


_04001CF4:	// 4001cf4: <4b18a524>	VCL ?-?

	// [start function: GoldenEye1CF4_1D04]

	GoldenEye1CF4_1D04();
	goto _04001D08;

_04001CF8:	// 4001cf8: <4bb89cd4>	VADDC	vec19 = vec19 + vec24[5]

_04001CFC:	// 4001cfc: <ca7d2000>	LQV       vec29 <00> = [S3 + 0x00]

_04001D00:	// 4001d00: <4b989490>	VADD      vec18 = vec18 + vec24[4]

_04001D04:	// 4001d04: <ca3b2000>	LQV       vec27 <00> = [S1 + 0x00]
	ErrorToCallFunction(0x04001D04);

	// [end of function: GoldenEye1CF4_1D04]

_04001D08:	// 4001d08: <4bd8a400>	VMULF     vec16 = ( acc = (vec20 * vec24[6]) << 1 ) >> 16

	// [start function: GoldenEye1D08_1D2C]

	GoldenEye1D08_1D2C();
	goto _04001D30;

_04001D0C:	// 4001d0c: <eaf42000>	SQV       [S7 + 0x00] = vec20 <00>

_04001D10:	// 4001d10: <4bf8a3c0>	VMULF     vec15 = ( acc = (vec20 * vec24[7]) << 1 ) >> 16

_04001D14:	// 4001d14: <eaf52001>	SQV       [S7 + 0x10] = vec21 <00>

_04001D18:	// 4001d18: <4bcaef40>	VMULF     vec29 = ( acc = (vec29 * vec10[6]) << 1 ) >> 16

_04001D1C:	// 4001d1c: <4a108f48>	VMACF     vec29 = ( acc += (vec17 * vec16[<none>]) << 1 ) >> 16

_04001D20:	// 4001d20: <ca5c2000>	LQV       vec28 <00> = [S2 + 0x00]

_04001D24:	// 4001d24: <4bcadec0>	VMULF     vec27 = ( acc = (vec27 * vec10[6]) << 1 ) >> 16

_04001D28:	// 4001d28: <ca1a2000>	LQV       vec26 <00> = [S0 + 0x00]

_04001D2C:	// 4001d2c: <4a0f8ec8>	VMACF     vec27 = ( acc += (vec17 * vec15[<none>]) << 1 ) >> 16
	ErrorToCallFunction(0x04001D2C);

	// [end of function: GoldenEye1D08_1D2C]

_04001D30:	// 4001d30: <1e800007>	BGTZ      (R0>0) --> 1d50
	sp_reg_pc = 0x04001D30;
	if((_s32)state.r[S4] > 0)
	{
		{
			_u32    addr = (0x00000000 + state.r[S3]);
			int     shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				*(_u32 *)&pDMEM[addr+12] = state.v[29].U32[0];
				*(_u32 *)&pDMEM[addr+8 ] = state.v[29].U32[1];
				*(_u32 *)&pDMEM[addr+4 ] = state.v[29].U32[2];
				*(_u32 *)&pDMEM[addr   ] = state.v[29].U32[3];
			}
			else
			{
				_u64    value1 = Load64_DMEM(addr+8);
				_u64    value2 = Load64_DMEM(addr);
				_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & ~temp1;
				value2 = value2 & ~temp2;

				value1 |= (state.v[29].U64[0] & temp1);
				value2 |= (state.v[29].U64[1] & temp2);

				Save64_DMEM(value1, addr+8);
				Save64_DMEM(value2, addr  );
			}
		}
		goto _04001D50;
	}


_04001D34:	// 4001d34: <ea7d2000>	SQV       [S3 + 0x00] = vec29 <00>
	{
		_u32    addr = (0x00000000 + state.r[S3]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[29].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[29].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[29].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[29].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[29].U64[0] & temp1);
			value2 |= (state.v[29].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001D38:	// 4001d38: <4b7894a3>	VGE       vec18 = (vec18 >= vec24[3])
	rsp_cop2_vge_element(&state.v[18], &state.v[18], &state.v[24].U16[4]);


_04001D3C:	// 4001d3c: <4b58ad54>	VADDC	vec21 = vec21 + vec24[2]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[24].U16[5];
		VADDC_operation(0, state.v[21].U16[0], state.v[21].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[21].U16[1], state.v[21].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[21].U16[2], state.v[21].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[21].U16[3], state.v[21].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[21].U16[4], state.v[21].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[21].U16[5], state.v[21].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[21].U16[6], state.v[21].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[21].U16[7], state.v[21].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_04001D40:	// 4001d40: <ea3b2000>	SQV       [S1 + 0x00] = vec27 <00>
	{
		_u32    addr = (0x00000000 + state.r[S1]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[27].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[27].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[27].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[27].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[27].U64[0] & temp1);
			value2 |= (state.v[27].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001D44:	// 4001d44: <4b38a510>	VADD      vec20 = vec20 + vec24[1]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[24].U16[6];
		VADD_operation(0, state.v[20].U16[0], state.v[20].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[20].U16[1], state.v[20].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[20].U16[2], state.v[20].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[20].U16[3], state.v[20].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[20].U16[4], state.v[20].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[20].U16[5], state.v[20].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[20].U16[6], state.v[20].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[20].U16[7], state.v[20].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001D48:	// 4001d48: <09000758>	J         04001d60
	goto _04001D60;


_04001D4C:	// 4001d4c: <00000000>	NOP       


_04001D50:	// 4001d50: <4b7894a4>	VCL ?-?
	rsp_cop2_vcl_element(&state.v[18], &state.v[18], &state.v[24].U16[4]);


_04001D54:	// 4001d54: <4b58ad54>	VADDC	vec21 = vec21 + vec24[2]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[24].U16[5];
		VADDC_operation(0, state.v[21].U16[0], state.v[21].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[21].U16[1], state.v[21].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[21].U16[2], state.v[21].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[21].U16[3], state.v[21].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[21].U16[4], state.v[21].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[21].U16[5], state.v[21].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[21].U16[6], state.v[21].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[21].U16[7], state.v[21].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_04001D58:	// 4001d58: <ea3b2000>	SQV       [S1 + 0x00] = vec27 <00>
	{
		_u32    addr = (0x00000000 + state.r[S1]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[27].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[27].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[27].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[27].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[27].U64[0] & temp1);
			value2 |= (state.v[27].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001D5C:	// 4001d5c: <4b38a510>	VADD      vec20 = vec20 + vec24[1]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[24].U16[6];
		VADD_operation(0, state.v[20].U16[0], state.v[20].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[20].U16[1], state.v[20].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[20].U16[2], state.v[20].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[20].U16[3], state.v[20].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[20].U16[4], state.v[20].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[20].U16[5], state.v[20].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[20].U16[6], state.v[20].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[20].U16[7], state.v[20].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001D60:	// 4001d60: <4bd89400>	VMULF     vec16 = ( acc = (vec18 * vec24[6]) << 1 ) >> 16

	// [start function: GoldenEye1D60_1D8C]

	GoldenEye1D60_1D8C();
	goto _04001D90;

_04001D64:	// 4001d64: <21cefff0>	ADDI      T6 = T6 + fff0

_04001D68:	// 4001d68: <4bf893c0>	VMULF     vec15 = ( acc = (vec18 * vec24[7]) << 1 ) >> 16

_04001D6C:	// 4001d6c: <22730010>	ADDI      S3 = S3 + 0010

_04001D70:	// 4001d70: <4bcae700>	VMULF     vec28 = ( acc = (vec28 * vec10[6]) << 1 ) >> 16

_04001D74:	// 4001d74: <022f8820>	ADD       S1 = S1+T7

_04001D78:	// 4001d78: <4a108f08>	VMACF     vec28 = ( acc += (vec17 * vec16[<none>]) << 1 ) >> 16

_04001D7C:	// 4001d7c: <21ad0010>	ADDI      T5 = T5 + 0010

_04001D80:	// 4001d80: <4bcad680>	VMULF     vec26 = ( acc = (vec26 * vec10[6]) << 1 ) >> 16

_04001D84:	// 4001d84: <4a0f8e88>	VMACF     vec26 = ( acc += (vec17 * vec15[<none>]) << 1 ) >> 16

_04001D88:	// 4001d88: <ea5c2000>	SQV       [S2 + 0x00] = vec28 <00>

_04001D8C:	// 4001d8c: <22520010>	ADDI      S2 = S2 + 0010
	ErrorToCallFunction(0x04001D8C);

	// [end of function: GoldenEye1D60_1D8C]

_04001D90:	// 4001d90: <19c00003>	BLEZ      (R0<=0) --> 1da0
	sp_reg_pc = 0x04001D90;
	if ((_s32)state.r[T6] <= 0)
	{
		{
			_u32    addr = (0x00000000 + state.r[S0]);
			int     shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				*(_u32 *)&pDMEM[addr+12] = state.v[26].U32[0];
				*(_u32 *)&pDMEM[addr+8 ] = state.v[26].U32[1];
				*(_u32 *)&pDMEM[addr+4 ] = state.v[26].U32[2];
				*(_u32 *)&pDMEM[addr   ] = state.v[26].U32[3];
			}
			else
			{
				_u64    value1 = Load64_DMEM(addr+8);
				_u64    value2 = Load64_DMEM(addr);
				_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & ~temp1;
				value2 = value2 & ~temp2;

				value1 |= (state.v[26].U64[0] & temp1);
				value2 |= (state.v[26].U64[1] & temp2);

				Save64_DMEM(value1, addr+8);
				Save64_DMEM(value2, addr  );
			}
		}
		goto _04001DA0;
	}


_04001D94:	// 4001d94: <ea1a2000>	SQV       [S0 + 0x00] = vec26 <00>
	{
		_u32    addr = (0x00000000 + state.r[S0]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[26].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[26].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[26].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[26].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[26].U64[0] & temp1);
			value2 |= (state.v[26].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001D98:	// 4001d98: <09000734>	J         04001cd0
	state.r[S0] = (state.r[S0] + state.r[T7]);
	goto _04001CD0;


_04001D9C:	// 4001d9c: <020f8020>	ADD       S0 = S0+T7
	state.r[S0] = (state.r[S0] + state.r[T7]);


_04001DA0:	// 4001da0: <eaf22002>	SQV       [S7 + 0x20] = vec18 <00>
	{
		_u32    addr = (0x00000020 + state.r[S7]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[18].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[18].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[18].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[18].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[18].U64[0] & temp1);
			value2 |= (state.v[18].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001DA4:	// 4001da4: <eaf32003>	SQV       [S7 + 0x30] = vec19 <00>
	{
		_u32    addr = (0x00000030 + state.r[S7]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[19].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[19].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[19].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[19].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[19].U64[0] & temp1);
			value2 |= (state.v[19].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001DA8:	// 4001da8: <eaf82004>	SQV       [S7 + 0x40] = vec24 <00>
	{
		_u32    addr = (0x00000040 + state.r[S7]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[24].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[24].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[24].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[24].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[24].U64[0] & temp1);
			value2 |= (state.v[24].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001DAC:	// 4001dac: <0d00046c>	JAL	    040011b0
	state.r[V1] = 0 + 0x004F;
	sp_reg_pc = 0x04001DAC;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040011B0;


_04001DB0:	// 4001db0: <2003004f>	ADDI      V1 = R0 + 004f
	state.r[V1] = 0 + 0x004F;


_04001DB4:	// 4001db4: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001DB8:	// 4001db8: <14a0fffe>	BNE       (R0!=A1) --> 1db4
	sp_reg_pc = 0x04001DB8;
	if (state.r[A1] != 0)
	{
		goto _04001DB4;
	}


_04001DBC:	// 4001dbc: <00000000>	NOP       


_04001DC0:	// 4001dc0: <09000446>	J         04001118
	goto _04001118;


_04001DC4:	// 4001dc4: <40803800>	MTC0      SP semaphore = R0


_04001DC8:	// 4001dc8: <c81f2000>	LQV       vec31 <00> = [R0 + 0x00]
	{
		_u32 addr = (0x00000000 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[31].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[31].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[31].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[31].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[31].U64[0] = state.v[31].U64[0] & ~temp1;
			state.v[31].U64[1] = state.v[31].U64[1] & ~temp2;
			state.v[31].U64[0] = state.v[31].U64[0] | value1;
			state.v[31].U64[1] = state.v[31].U64[1] | value2;
		}
	}


_04001DCC:	// 4001dcc: <97120004>	LHU       S2 = [T8+0004]
	state.r[S2] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x00000004) & 0xfff);


_04001DD0:	// 4001dd0: <12400019>	BEQ       (R0==S2) --> 1e38
	sp_reg_pc = 0x04001DD0;
	if (state.r[S2] == 0)
	{
		goto _04001E38;
	}


_04001DD4:	// 4001dd4: <00000000>	NOP       


_04001DD8:	// 4001dd8: <3333ffff>	ANDI      S3 = T9 & ffff
	state.r[S3] = (state.r[T9] & 0x0000FFFF);


_04001DDC:	// 4001ddc: <227305c0>	ADDI      S3 = S3 + 05c0
	state.r[S3] = state.r[S3] + 0x05C0;


_04001DE0:	// 4001de0: <0019a402>	SRL       S4 = T9 >> 16
	state.r[S4] = ((_u32)state.r[T9] >> 16);


_04001DE4:	// 4001de4: <229405c0>	ADDI      S4 = S4 + 05c0
	state.r[S4] = state.r[S4] + 0x05C0;


_04001DE8:	// 4001de8: <3351ffff>	ANDI      S1 = K0 & ffff
	state.r[S1] = (state.r[K0] & 0x0000FFFF);


_04001DEC:	// 4001dec: <4891f000>	MTC2      vec30 <00> = S1
	state.v[30].U16[7] = (_u16)state.r[S1];


_04001DF0:	// 4001df0: <ca7b2000>	LQV       vec27 <00> = [S3 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S3]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
			state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
			state.v[27].U64[0] = state.v[27].U64[0] | value1;
			state.v[27].U64[1] = state.v[27].U64[1] | value2;
		}
	}


_04001DF4:	// 4001df4: <ca9d2000>	LQV       vec29 <00> = [S4 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S4]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[29].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[29].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[29].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[29].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[29].U64[0] = state.v[29].U64[0] & ~temp1;
			state.v[29].U64[1] = state.v[29].U64[1] & ~temp2;
			state.v[29].U64[0] = state.v[29].U64[0] | value1;
			state.v[29].U64[1] = state.v[29].U64[1] | value2;
		}
	}


_04001DF8:	// 4001df8: <ca7a2001>	LQV       vec26 <00> = [S3 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[S3]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[26].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[26].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[26].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[26].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[26].U64[0] = state.v[26].U64[0] & ~temp1;
			state.v[26].U64[1] = state.v[26].U64[1] & ~temp2;
			state.v[26].U64[0] = state.v[26].U64[0] | value1;
			state.v[26].U64[1] = state.v[26].U64[1] | value2;
		}
	}


_04001DFC:	// 4001dfc: <ca9c2001>	LQV       vec28 <00> = [S4 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[S4]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[28].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[28].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[28].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[28].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[28].U64[0] = state.v[28].U64[0] & ~temp1;
			state.v[28].U64[1] = state.v[28].U64[1] & ~temp2;
			state.v[28].U64[0] = state.v[28].U64[0] | value1;
			state.v[28].U64[1] = state.v[28].U64[1] | value2;
		}
	}


_04001E00:	// 4001e00: <4bdfdec0>	VMULF     vec27 = ( acc = (vec27 * vec31[6]) << 1 ) >> 16
	// In function: Mario1E5C_1E88
	//Call the function: Mario1E5C_1E88
	Mario1E5C_1E88();
	goto _04001E30;

_04001E04:	// 4001e04: <2252ffe0>	ADDI      S2 = S2 + ffe0
	ErrorToCallFunction(0x04001E04);

_04001E08:	// 4001e08: <4b1eeec8>	VMACF     vec27 = ( acc += (vec29 * vec30[0]) << 1 ) >> 16
	ErrorToCallFunction(0x04001E08);

_04001E0C:	// 4001e0c: <22940020>	ADDI      S4 = S4 + 0020
	ErrorToCallFunction(0x04001E0C);

_04001E10:	// 4001e10: <ea7b2000>	SQV       [S3 + 0x00] = vec27 <00>
	ErrorToCallFunction(0x04001E10);

_04001E14:	// 4001e14: <4bdfd680>	VMULF     vec26 = ( acc = (vec26 * vec31[6]) << 1 ) >> 16
	ErrorToCallFunction(0x04001E14);

_04001E18:	// 4001e18: <ca9d2000>	LQV       vec29 <00> = [S4 + 0x00]
	ErrorToCallFunction(0x04001E18);

_04001E1C:	// 4001e1c: <4b1ee688>	VMACF     vec26 = ( acc += (vec28 * vec30[0]) << 1 ) >> 16
	ErrorToCallFunction(0x04001E1C);

_04001E20:	// 4001e20: <ca9c2001>	LQV       vec28 <00> = [S4 + 0x10]
	ErrorToCallFunction(0x04001E20);

_04001E24:	// 4001e24: <ea7a2001>	SQV       [S3 + 0x10] = vec26 <00>
	ErrorToCallFunction(0x04001E24);

_04001E28:	// 4001e28: <22730020>	ADDI      S3 = S3 + 0020
	ErrorToCallFunction(0x04001E28);

_04001E2C:	// 4001e2c: <ca7b2000>	LQV       vec27 <00> = [S3 + 0x00]
	ErrorToCallFunction(0x04001E2C);

_04001E30:	// 4001e30: <1e40fff3>	BGTZ      (R0>0) --> 1e00
	sp_reg_pc = 0x04001E30;
	if((_s32)state.r[S2] > 0)
	{
		{
			_u32 addr = (0x00000010 + state.r[S3]);
			int shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				state.v[26].U32[0] = *(_u32 *)&pDMEM[addr+12];
				state.v[26].U32[1] = *(_u32 *)&pDMEM[addr+8];
				state.v[26].U32[2] = *(_u32 *)&pDMEM[addr+4];
				state.v[26].U32[3] = *(_u32 *)&pDMEM[addr];
			}
			else
			{
				_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
				_u64		value1 = Load64_DMEM(addr+8);
				_u64		value2 = Load64_DMEM(addr);
				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & temp1;
				value2 = value2 & temp2;

				state.v[26].U64[0] = state.v[26].U64[0] & ~temp1;
				state.v[26].U64[1] = state.v[26].U64[1] & ~temp2;
				state.v[26].U64[0] = state.v[26].U64[0] | value1;
				state.v[26].U64[1] = state.v[26].U64[1] | value2;
			}
		}
		goto _04001E00;
	}


_04001E34:	// 4001e34: <ca7a2001>	LQV       vec26 <00> = [S3 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[S3]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[26].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[26].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[26].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[26].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[26].U64[0] = state.v[26].U64[0] & ~temp1;
			state.v[26].U64[1] = state.v[26].U64[1] & ~temp2;
			state.v[26].U64[0] = state.v[26].U64[0] | value1;
			state.v[26].U64[1] = state.v[26].U64[1] | value2;
		}
	}


_04001E38:	// 4001e38: <09000446>	J         04001118
	goto _04001118;


_04001E3C:	// 4001e3c: <00000000>	NOP       


_04001E40:	// 4001e40: <00000000>	NOP       


_04001E44:	// 4001e44: <00000002>	SRL       R0 = R0 >> 0
	; //0 = ((_u32)0 >> 0);



_04001E48:	// 4001e48: <10000000>	BEQ       (R0==R0) --> 1e4c
	sp_reg_pc = 0x04001E48;
	if (0 == 0)
	{
		state.r[K0] = (_s32)(_s8)pDMEM[((state.r[AT] + 0xFFFFB400) & 0xfff) ^ 3];
		goto _04001E4C;
	}


_04001E4C:	// 4001e4c: <803ab400>	LB        K0 = [AT+b400]
	state.r[K0] = (_s32)(_s8)pDMEM[((state.r[AT] + 0xFFFFB400) & 0xfff) ^ 3];


_04001E50:	// 4001e50: <800283d0>	LB        V0 = [R0+83d0]
	state.r[V0] = (_s32)(_s8)pDMEM[((0 + 0xFFFF83D0) & 0xfff) ^ 3];


_04001E54:	// 4001e54: <803ab410>	LB        K0 = [AT+b410]
	state.r[K0] = (_s32)(_s8)pDMEM[((state.r[AT] + 0xFFFFB410) & 0xfff) ^ 3];


_04001E58:	// 4001e58: <800283d8>	LB        V0 = [R0+83d8]
	state.r[V0] = (_s32)(_s8)pDMEM[((0 + 0xFFFF83D8) & 0xfff) ^ 3];


_04001E5C:	// 4001e5c: <803ab710>	LB        K0 = [AT+b710]
	state.r[K0] = (_s32)(_s8)pDMEM[((state.r[AT] + 0xFFFFB710) & 0xfff) ^ 3];


_04001E60:	// 4001e60: <800283e0>	LB        V0 = [R0+83e0]
	state.r[V0] = (_s32)(_s8)pDMEM[((0 + 0xFFFF83E0) & 0xfff) ^ 3];


_04001E64:	// 4001e64: <803ab750>	LB        K0 = [AT+b750]
	state.r[K0] = (_s32)(_s8)pDMEM[((state.r[AT] + 0xFFFFB750) & 0xfff) ^ 3];


_04001E68:	// 4001e68: <800283e8>	LB        V0 = [R0+83e8]
	state.r[V0] = (_s32)(_s8)pDMEM[((0 + 0xFFFF83E8) & 0xfff) ^ 3];


_04001E6C:	// 4001e6c: <803ab950>	LB        K0 = [AT+b950]
	state.r[K0] = (_s32)(_s8)pDMEM[((state.r[AT] + 0xFFFFB950) & 0xfff) ^ 3];


_04001E70:	// 4001e70: <800283f0>	LB        V0 = [R0+83f0]
	state.r[V0] = (_s32)(_s8)pDMEM[((0 + 0xFFFF83F0) & 0xfff) ^ 3];


_04001E74:	// 4001e74: <803b3950>	LB        K1 = [AT+3950]
	state.r[K1] = (_s32)(_s8)pDMEM[((state.r[AT] + 0x00003950) & 0xfff) ^ 3];


_04001E78:	// 4001e78: <800283f8>	LB        V0 = [R0+83f8]
	state.r[V0] = (_s32)(_s8)pDMEM[((0 + 0xFFFF83F8) & 0xfff) ^ 3];


_04001E7C:	// 4001e7c: <00000000>	NOP       


_04001E80:	// 4001e80: <00000000>	NOP       


_04001E84:	// 4001e84: <00000000>	NOP       


_04001E88:	// 4001e88: <00000000>	NOP       


_04001E8C:	// 4001e8c: <00000000>	NOP       


_04001E90:	// 4001e90: <00000000>	NOP       


_04001E94:	// 4001e94: <00000000>	NOP       


_04001E98:	// 4001e98: <00000000>	NOP       


_04001E9C:	// 4001e9c: <00000000>	NOP       


_04001EA0:	// 4001ea0: <02aea540>	SLL       S4 = T6 << 21
	state.r[S4] = ((_u32)state.r[T6] << 21);


_04001EA4:	// 4001ea4: <014453fd>	SPECIAL RESERVED


_04001EA8:	// 4001ea8: <00000000>	NOP       


_04001EAC:	// 4001eac: <00000000>	NOP       


_04001EB0:	// 4001eb0: <00000000>	NOP       


_04001EB4:	// 4001eb4: <3f800000>	LUI       R0 = 0x00000000
	; //0 = 0x00000000;



_04001EB8:	// 4001eb8: <3f800000>	LUI       R0 = 0x00000000
	; //0 = 0x00000000;



_04001EBC:	// 4001ebc: <3f800000>	LUI       R0 = 0x00000000
	; //0 = 0x00000000;



_04001EC0:	// 4001ec0: <3f800000>	LUI       R0 = 0x00000000
	; //0 = 0x00000000;



_04001EC4:	// 4001ec4: <00000000>	NOP       


_04001EC8:	// 4001ec8: <00000000>	NOP       


_04001ECC:	// 4001ecc: <00000001>	SPECIAL RESERVED


_04001ED0:	// 4001ed0: <00000000>	NOP       


_04001ED4:	// 4001ed4: <00000000>	NOP       


_04001ED8:	// 4001ed8: <00000000>	NOP       


_04001EDC:	// 4001edc: <00000000>	NOP       


_04001EE0:	// 4001ee0: <ab8d9f77>	RESEREVED


_04001EE4:	// 4001ee4: <81280783>	LB        T0 = [T1+0783]
	state.r[T0] = (_s32)(_s8)pDMEM[((state.r[T1] + 0x00000783) & 0xfff) ^ 3];


_04001EE8:	// 4001ee8: <00000000>	NOP       


_04001EEC:	// 4001eec: <00000000>	NOP       


_04001EF0:	// 4001ef0: <00000000>	NOP       


_04001EF4:	// 4001ef4: <0000000a>	SPECIAL RESERVED


_04001EF8:	// 4001ef8: <00000000>	NOP       


_04001EFC:	// 4001efc: <00000000>	NOP       


_04001F00:	// 4001f00: <00000006>	SRLV      R0 = R0 >> R0
	; //0 = ((_u32)0 >> (0 & 0x1F));



_04001F04:	// 4001f04: <00001900>	SLL       V1 = R0 << 4
	state.r[V1] = ((_u32)0 << 4);


_04001F08:	// 4001f08: <00000000>	NOP       


_04001F0C:	// 4001f0c: <000000a0>	ADD       R0 = R0+R0
	; //0 = (0 + 0);



_04001F10:	// 4001f10: <00002666>	XOR       A0 = R0 xor R0
	state.r[A0] = (0 ^ 0);


_04001F14:	// 4001f14: <ffffd99a>	RESEREVED


_04001F18:	// 4001f18: <00000000>	NOP       


_04001F1C:	// 4001f1c: <00000000>	NOP       


_04001F20:	// 4001f20: <00000000>	NOP       


_04001F24:	// 4001f24: <00000000>	NOP       


_04001F28:	// 4001f28: <000000a0>	ADD       R0 = R0+R0
	; //0 = (0 + 0);



_04001F2C:	// 4001f2c: <00000140>	SLL       R0 = R0 << 5
	; //0 = ((_u32)0 << 5);



_04001F30:	// 4001f30: <00002666>	XOR       A0 = R0 xor R0
	state.r[A0] = (0 ^ 0);


_04001F34:	// 4001f34: <ffffd99a>	RESEREVED


_04001F38:	// 4001f38: <00002b84>	SLLV      R0 = A1 << R0
	state.r[A1] = (0 << (0 & 0x1F));


_04001F3C:	// 4001f3c: <00000000>	NOP       


_04001F40:	// 4001f40: <00000000>	NOP       


_04001F44:	// 4001f44: <00002500>	SLL       A0 = R0 << 20
	state.r[A0] = ((_u32)0 << 20);


_04001F48:	// 4001f48: <00000320>	ADD       R0 = R0+R0
	; //0 = (0 + 0);



_04001F4C:	// 4001f4c: <00000a00>	SLL       AT = R0 << 8
	state.r[AT] = ((_u32)0 << 8);


_04001F50:	// 4001f50: <00004000>	SLL       T0 = R0 << 0
	state.r[T0] = ((_u32)0 << 0);


_04001F54:	// 4001f54: <ffffc000>	RESEREVED


_04001F58:	// 4001f58: <000011eb>	SLTU ?-?
	if((_u32)0 < (_u32)0)
	{
		state.r[V0] = 1;
	}
	else
	{
		state.r[V0] = 0;
	}


_04001F5C:	// 4001f5c: <00000000>	NOP       


_04001F60:	// 4001f60: <00000000>	NOP       


_04001F64:	// 4001f64: <00003000>	SLL       A2 = R0 << 0
	state.r[A2] = ((_u32)0 << 0);


_04001F68:	// 4001f68: <00000c80>	SLL       AT = R0 << 18
	state.r[AT] = ((_u32)0 << 18);


_04001F6C:	// 4001f6c: <000015e0>	ADD       V0 = R0+R0
	state.r[V0] = (0 + 0);


_04001F70:	// 4001f70: <00004000>	SLL       T0 = R0 << 0
	state.r[T0] = ((_u32)0 << 0);


_04001F74:	// 4001f74: <ffffc000>	RESEREVED


_04001F78:	// 4001f78: <000011eb>	SLTU ?-?
	if((_u32)0 < (_u32)0)
	{
		state.r[V0] = 1;
	}
	else
	{
		state.r[V0] = 0;
	}


_04001F7C:	// 4001f7c: <00000000>	NOP       


_04001F80:	// 4001f80: <00000000>	NOP       


_04001F84:	// 4001f84: <00003500>	SLL       A2 = R0 << 20
	state.r[A2] = ((_u32)0 << 20);


_04001F88:	// 4001f88: <00000d20>	ADD       AT = R0+R0
	state.r[AT] = (0 + 0);


_04001F8C:	// 4001f8c: <000012c0>	SLL       V0 = R0 << 11
	state.r[V0] = ((_u32)0 << 11);


_04001F90:	// 4001f90: <00002000>	SLL       A0 = R0 << 0
	state.r[A0] = ((_u32)0 << 0);


_04001F94:	// 4001f94: <ffffe000>	RESEREVED


_04001F98:	// 4001f98: <00000000>	NOP       


_04001F9C:	// 4001f9c: <00000000>	NOP       


_04001FA0:	// 4001fa0: <00000000>	NOP       


_04001FA4:	// 4001fa4: <00004000>	SLL       T0 = R0 << 0
	state.r[T0] = ((_u32)0 << 0);


_04001FA8:	// 4001fa8: <00000000>	NOP       


_04001FAC:	// 4001fac: <00001720>	ADD       V0 = R0+R0
	state.r[V0] = (0 + 0);


_04001FB0:	// 4001fb0: <000032c8>	JR        R0
	{
		_u32	temp = ((0 & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001FB4:	// 4001fb4: <ffffcd38>	RESEREVED

_04001FB8:
_04001FBC:
_04001FC0:
_04001FC4:
_04001FC8:
_04001FCC:
_04001FD0:
_04001FD4:
_04001FD8:
_04001FDC:
_04001FE0:
_04001FE4:
_04001FE8:
_04001FEC:
_04001FF0:
_04001FF4:
_04001FF8:
_04001FFC:
	state.halt = 1;
	return;

	_BuildJumpTable:
	#include "jumptable.h"
	goto _Label;
}

void GoldenEye1800_184C(void)
{

	// 4001800: <4bdccc07>	VMUDH     vec16 = ( acc = (vec25 * vec28[6]) << 16) >> 16
	{
		_u16		s2value = state.v[28].U16[1];
		VMUDH_operation(0, state.v[16].U16[0], state.v[25].U16[0], s2value, 0, 1, 0, 1)
		VMUDH_operation(1, state.v[16].U16[1], state.v[25].U16[1], s2value, 0, 1, 0, 1)
		VMUDH_operation(2, state.v[16].U16[2], state.v[25].U16[2], s2value, 0, 1, 0, 1)
		VMUDH_operation(3, state.v[16].U16[3], state.v[25].U16[3], s2value, 0, 1, 0, 1)
		VMUDH_operation(4, state.v[16].U16[4], state.v[25].U16[4], s2value, 0, 1, 0, 1)
		VMUDH_operation(5, state.v[16].U16[5], state.v[25].U16[5], s2value, 0, 1, 0, 1)
		VMUDH_operation(6, state.v[16].U16[6], state.v[25].U16[6], s2value, 0, 1, 0, 1)
		VMUDH_operation(7, state.v[16].U16[7], state.v[25].U16[7], s2value, 0, 1, 0, 1)
	}


	// 4001804: <22b50010>	ADDI      S5 = S5 + 0010
	state.r[S5] = state.r[S5] + 0x0010;


	// 4001808: <4bfcc40f>	VMADH     vec16 = ( acc+= (vec24 * vec28[7]) << 16) >> 16
	{
		_u16		s2value = state.v[28].U16[0];
		VMADH_operation(0, state.v[16].U16[0], state.v[24].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[16].U16[1], state.v[24].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[16].U16[2], state.v[24].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[16].U16[3], state.v[24].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[16].U16[4], state.v[24].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[16].U16[5], state.v[24].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[16].U16[6], state.v[24].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[16].U16[7], state.v[24].U16[7], s2value, 0, 1, 0, 1)
	}


	// 400180c: <2273fff0>	ADDI      S3 = S3 + fff0
	state.r[S3] = state.r[S3] + 0xFFFFFFF0;


	// 4001810: <4b1ebc0f>	VMADH     vec16 = ( acc+= (vec23 * vec30[0]) << 16) >> 16
	{
		_u16		s2value = state.v[30].U16[7];
		VMADH_operation(0, state.v[16].U16[0], state.v[23].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[16].U16[1], state.v[23].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[16].U16[2], state.v[23].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[16].U16[3], state.v[23].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[16].U16[4], state.v[23].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[16].U16[5], state.v[23].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[16].U16[6], state.v[23].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[16].U16[7], state.v[23].U16[7], s2value, 0, 1, 0, 1)
	}


	// 4001814: <4b3eb40f>	VMADH     vec16 = ( acc+= (vec22 * vec30[1]) << 16) >> 16
	{
		_u16		s2value = state.v[30].U16[6];
		VMADH_operation(0, state.v[16].U16[0], state.v[22].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[16].U16[1], state.v[22].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[16].U16[2], state.v[22].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[16].U16[3], state.v[22].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[16].U16[4], state.v[22].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[16].U16[5], state.v[22].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[16].U16[6], state.v[22].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[16].U16[7], state.v[22].U16[7], s2value, 0, 1, 0, 1)
	}


	// 4001818: <4b5eac0f>	VMADH     vec16 = ( acc+= (vec21 * vec30[2]) << 16) >> 16
	{
		_u16		s2value = state.v[30].U16[5];
		VMADH_operation(0, state.v[16].U16[0], state.v[21].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[16].U16[1], state.v[21].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[16].U16[2], state.v[21].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[16].U16[3], state.v[21].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[16].U16[4], state.v[21].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[16].U16[5], state.v[21].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[16].U16[6], state.v[21].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[16].U16[7], state.v[21].U16[7], s2value, 0, 1, 0, 1)
	}


	// 400181c: <4b7ea40f>	VMADH     vec16 = ( acc+= (vec20 * vec30[3]) << 16) >> 16
	{
		_u16		s2value = state.v[30].U16[4];
		VMADH_operation(0, state.v[16].U16[0], state.v[20].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[16].U16[1], state.v[20].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[16].U16[2], state.v[20].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[16].U16[3], state.v[20].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[16].U16[4], state.v[20].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[16].U16[5], state.v[20].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[16].U16[6], state.v[20].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[16].U16[7], state.v[20].U16[7], s2value, 0, 1, 0, 1)
	}


	// 4001820: <4b9e9f0f>	VMADH     vec28 = ( acc+= (vec19 * vec30[4]) << 16) >> 16
	{
		_u16		s2value = state.v[30].U16[3];
		VMADH_operation(0, state.v[28].U16[0], state.v[19].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[28].U16[1], state.v[19].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[28].U16[2], state.v[19].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[28].U16[3], state.v[19].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[28].U16[4], state.v[19].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[28].U16[5], state.v[19].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[28].U16[6], state.v[19].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[28].U16[7], state.v[19].U16[7], s2value, 0, 1, 0, 1)
	}


	// 4001824: <4bbe940f>	VMADH     vec16 = ( acc+= (vec18 * vec30[5]) << 16) >> 16
	{
		_u16		s2value = state.v[30].U16[2];
		VMADH_operation(0, state.v[16].U16[0], state.v[18].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[16].U16[1], state.v[18].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[16].U16[2], state.v[18].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[16].U16[3], state.v[18].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[16].U16[4], state.v[18].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[16].U16[5], state.v[18].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[16].U16[6], state.v[18].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[16].U16[7], state.v[18].U16[7], s2value, 0, 1, 0, 1)
	}


	// 4001828: <4bde8c0f>	VMADH     vec16 = ( acc+= (vec17 * vec30[6]) << 16) >> 16
	{
		_u16		s2value = state.v[30].U16[1];
		VMADH_operation(0, state.v[16].U16[0], state.v[17].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[16].U16[1], state.v[17].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[16].U16[2], state.v[17].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[16].U16[3], state.v[17].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[16].U16[4], state.v[17].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[16].U16[5], state.v[17].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[16].U16[6], state.v[17].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[16].U16[7], state.v[17].U16[7], s2value, 0, 1, 0, 1)
	}


	// 400182c: <4bbff40f>	VMADH     vec16 = ( acc+= (vec30 * vec31[5]) << 16) >> 16
	{
		_u16		s2value = state.v[31].U16[2];
		VMADH_operation(0, state.v[16].U16[0], state.v[30].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[16].U16[1], state.v[30].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[16].U16[2], state.v[30].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[16].U16[3], state.v[30].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[16].U16[4], state.v[30].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[16].U16[5], state.v[30].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[16].U16[6], state.v[30].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[16].U16[7], state.v[30].U16[7], s2value, 0, 1, 0, 1)
	}


	// 4001830: <cabe1800>	LDV       vec30 <00> = [S5 + 0x00]
	rsp_ldv_compiler((state.r[S5] & 0xFFF), 30, 8);


	// 4001834: <4b3c7e9d>	VSAW $v26, $v15, $v28[[1]]
	state.v[26].U16[0] = accumulator[0];
	state.v[26].U16[1] = accumulator[1];
	state.v[26].U16[2] = accumulator[2];
	state.v[26].U16[3] = accumulator[3];
	state.v[26].U16[4] = accumulator[4];
	state.v[26].U16[5] = accumulator[5];
	state.v[26].U16[6] = accumulator[6];
	state.v[26].U16[7] = accumulator[7];


	// 4001838: <cabe1c01>	LDV       vec30 <08> = [S5 + 0x08]
	rsp_ldv_compiler((state.r[S5] + 0x00000008) & 0xFFF, 30, 0);


	// 400183c: <4b1c7f1d>	VSAW $v28, $v15, $v28[[0]]
	state.v[28].U16[0] = accumulator_hi[0].U16[1];
	state.v[28].U16[1] = accumulator_hi[1].U16[1];
	state.v[28].U16[2] = accumulator_hi[2].U16[1];
	state.v[28].U16[3] = accumulator_hi[3].U16[1];
	state.v[28].U16[4] = accumulator_hi[4].U16[1];
	state.v[28].U16[5] = accumulator_hi[5].U16[1];
	state.v[28].U16[6] = accumulator_hi[6].U16[1];
	state.v[28].U16[7] = accumulator_hi[7].U16[1];


	// 4001840: <4b0ed406>	VMUDN     vec16 = ( acc = vec26 * vec14[0]      ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[26*16].U16[0]
			MOVQ mm1, state.v[26*16].U16[4*2]
			PSHUFW mm4, state.v[14*16].U16[7*2], 0
			MOVQ mm6, mm0
			MOVQ mm7, mm1
			PMULLW mm6, mm4
			PMULLW mm7, mm4
			MOVQ accumulator[0*4], mm6
			MOVQ accumulator[2*4], mm7
			MOVQ mm2, mm0
			MOVQ mm3, mm1
			PMULHUW mm2, mm4
			PMULHUW mm3, mm4
			PSRAW mm0, 15
			PSRAW mm1, 15
			PMULLW mm0, mm4
			PMULLW mm1, mm4
			PADDW mm0, mm2
			PADDW mm1, mm3
			MOVQ state.v[16*16].U16[0], mm0
			MOVQ state.v[16*16].U16[4*2], mm1
			MOVQ mm2, mm0
			MOVQ mm3, mm0
			MOVQ mm4, mm1
			MOVQ mm5, mm1
			PSRAW mm0, 15
			PSRAW mm1, 15
			PUNPCKLWD mm2, mm0
			PUNPCKHWD mm3, mm0
			PUNPCKLWD mm4, mm1
			PUNPCKHWD mm5, mm1
			MOVQ accumulator_hi[0*4], mm2
			MOVQ accumulator_hi[2*4], mm3
			MOVQ accumulator_hi[4*4], mm4
			MOVQ accumulator_hi[6*4], mm5
		}
	}


	// 4001844: <4b0ee70f>	VMADH     vec28 = ( acc+= (vec28 * vec14[0]) << 16) >> 16
	{
		_u16		s2value = state.v[14].U16[7];
		VMADH_operation(0, state.v[28].U16[0], state.v[28].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[28].U16[1], state.v[28].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[28].U16[2], state.v[28].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[28].U16[3], state.v[28].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[28].U16[4], state.v[28].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[28].U16[5], state.v[28].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[28].U16[6], state.v[28].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[28].U16[7], state.v[28].U16[7], s2value, 1, 1, 0, 1)
	}


	// 4001848: <ea9c1800>	SDV       [S4 + 0x00] = vec28 <00>
	{
		_u32	addr = (0x00000000 + state.r[S4]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[28].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[28].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[28].U32[0x00000003];
		}
	}


	// 400184c: <ea9c1c01>	SDV       [S4 + 0x04] = vec28 <08>
	{
		_u32	addr = (0x00000008 + state.r[S4]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[28].U64[0x00000000], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[28].U32[0x00000000];
			*(_u32 *)&pDMEM[addr  ] = state.v[28].U32[0x00000001];
		}
	}

_04001850:
	;
}

void GoldenEye1CF4_1D04(void)
{

	// 4001cf4: <4b18a524>	VCL ?-?
	rsp_cop2_vcl_element(&state.v[20], &state.v[20], &state.v[24].U16[7]);


	// 4001cf8: <4bb89cd4>	VADDC	vec19 = vec19 + vec24[5]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[24].U16[2];
		VADDC_operation(0, state.v[19].U16[0], state.v[19].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[19].U16[1], state.v[19].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[19].U16[2], state.v[19].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[19].U16[3], state.v[19].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[19].U16[4], state.v[19].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[19].U16[5], state.v[19].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[19].U16[6], state.v[19].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[19].U16[7], state.v[19].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


	// 4001cfc: <ca7d2000>	LQV       vec29 <00> = [S3 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S3]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[29].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[29].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[29].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[29].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[29].U64[0] = state.v[29].U64[0] & ~temp1;
			state.v[29].U64[1] = state.v[29].U64[1] & ~temp2;
			state.v[29].U64[0] = state.v[29].U64[0] | value1;
			state.v[29].U64[1] = state.v[29].U64[1] | value2;
		}
	}


	// 4001d00: <4b989490>	VADD      vec18 = vec18 + vec24[4]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[24].U16[3];
		VADD_operation(0, state.v[18].U16[0], state.v[18].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[18].U16[1], state.v[18].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[18].U16[2], state.v[18].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[18].U16[3], state.v[18].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[18].U16[4], state.v[18].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[18].U16[5], state.v[18].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[18].U16[6], state.v[18].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[18].U16[7], state.v[18].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


	// 4001d04: <ca3b2000>	LQV       vec27 <00> = [S1 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
			state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
			state.v[27].U64[0] = state.v[27].U64[0] | value1;
			state.v[27].U64[1] = state.v[27].U64[1] | value2;
		}
	}

_04001D08:
	;
}

void GoldenEye1D08_1D2C(void)
{

	// 4001d08: <4bd8a400>	VMULF     vec16 = ( acc = (vec20 * vec24[6]) << 1 ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[20*16].U16[0]
			MOVQ mm1, state.v[20*16].U16[4*2]
			PSHUFW mm4, state.v[24*16].U16[1*2], 0
			MOVQ mm6, mm0
			MOVQ mm7, mm1
			PMULLW mm0, mm4
			PMULLW mm1, mm4
			//mm2 = result << 1
			MOVQ    mm2, mm0
			MOVQ   mm3, mm1
			PSLLW   mm2, 1
			PSLLW  mm3, 1
			//mm6 = result >> 15
			PMULHW  mm6, mm4
			PMULHW  mm7, mm4
			//get 0x4000 bit of result
			PSRLW   mm2, 14 ; get last 3 bits to add
			PSRLW   mm3, 14
			//if (result & 0x4000) hiValue++;
			PADDSW  mm6, mm2 ;hiValue + (1, 2, 3 or 0)
			PADDSW  mm7, mm3
			PSLLW   mm6, 1
			PSLLW   mm7, 1
			MOVQ state.v[16*16].U16[0], mm6
			MOVQ state.v[16*16].U16[4*2], mm7
		}
	}


	// 4001d0c: <eaf42000>	SQV       [S7 + 0x00] = vec20 <00>
	{
		_u32    addr = (0x00000000 + state.r[S7]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[20].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[20].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[20].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[20].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[20].U64[0] & temp1);
			value2 |= (state.v[20].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


	// 4001d10: <4bf8a3c0>	VMULF     vec15 = ( acc = (vec20 * vec24[7]) << 1 ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[20*16].U16[0]
			MOVQ mm1, state.v[20*16].U16[4*2]
			PSHUFW mm4, state.v[24*16].U16[0*2], 0
			MOVQ mm6, mm0
			MOVQ mm7, mm1
			PMULLW mm0, mm4
			PMULLW mm1, mm4
			//mm2 = result << 1
			MOVQ    mm2, mm0
			MOVQ   mm3, mm1
			PSLLW   mm2, 1
			PSLLW  mm3, 1
			//mm6 = result >> 15
			PMULHW  mm6, mm4
			PMULHW  mm7, mm4
			//get 0x4000 bit of result
			PSRLW   mm2, 14 ; get last 3 bits to add
			PSRLW   mm3, 14
			//if (result & 0x4000) hiValue++;
			PADDSW  mm6, mm2 ;hiValue + (1, 2, 3 or 0)
			PADDSW  mm7, mm3
			PSLLW   mm6, 1
			PSLLW   mm7, 1
			MOVQ state.v[15*16].U16[0], mm6
			MOVQ state.v[15*16].U16[4*2], mm7
		}
	}


	// 4001d14: <eaf52001>	SQV       [S7 + 0x10] = vec21 <00>
	{
		_u32    addr = (0x00000010 + state.r[S7]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[21].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[21].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[21].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[21].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[21].U64[0] & temp1);
			value2 |= (state.v[21].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


	// 4001d18: <4bcaef40>	VMULF     vec29 = ( acc = (vec29 * vec10[6]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[1];
		VMULF_operation(0, state.v[29].U16[0], state.v[29].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[29].U16[1], state.v[29].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[29].U16[2], state.v[29].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[29].U16[3], state.v[29].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[29].U16[4], state.v[29].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[29].U16[5], state.v[29].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[29].U16[6], state.v[29].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[29].U16[7], state.v[29].U16[7], s2value, 0, 1, 1, 1)
	}


	// 4001d1c: <4a108f48>	VMACF     vec29 = ( acc += (vec17 * vec16[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[29].U16[0], state.v[17].U16[0], state.v[16].U16[0], 1, 0, 0, 1)
		VMACF_operation(1, state.v[29].U16[1], state.v[17].U16[1], state.v[16].U16[1], 1, 0, 0, 1)
		VMACF_operation(2, state.v[29].U16[2], state.v[17].U16[2], state.v[16].U16[2], 1, 0, 0, 1)
		VMACF_operation(3, state.v[29].U16[3], state.v[17].U16[3], state.v[16].U16[3], 1, 0, 0, 1)
		VMACF_operation(4, state.v[29].U16[4], state.v[17].U16[4], state.v[16].U16[4], 1, 0, 0, 1)
		VMACF_operation(5, state.v[29].U16[5], state.v[17].U16[5], state.v[16].U16[5], 1, 0, 0, 1)
		VMACF_operation(6, state.v[29].U16[6], state.v[17].U16[6], state.v[16].U16[6], 1, 0, 0, 1)
		VMACF_operation(7, state.v[29].U16[7], state.v[17].U16[7], state.v[16].U16[7], 1, 0, 0, 1)
	}


	// 4001d20: <ca5c2000>	LQV       vec28 <00> = [S2 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S2]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[28].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[28].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[28].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[28].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[28].U64[0] = state.v[28].U64[0] & ~temp1;
			state.v[28].U64[1] = state.v[28].U64[1] & ~temp2;
			state.v[28].U64[0] = state.v[28].U64[0] | value1;
			state.v[28].U64[1] = state.v[28].U64[1] | value2;
		}
	}


	// 4001d24: <4bcadec0>	VMULF     vec27 = ( acc = (vec27 * vec10[6]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[1];
		VMULF_operation(0, state.v[27].U16[0], state.v[27].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[27].U16[1], state.v[27].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[27].U16[2], state.v[27].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[27].U16[3], state.v[27].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[27].U16[4], state.v[27].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[27].U16[5], state.v[27].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[27].U16[6], state.v[27].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[27].U16[7], state.v[27].U16[7], s2value, 0, 1, 1, 1)
	}


	// 4001d28: <ca1a2000>	LQV       vec26 <00> = [S0 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S0]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[26].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[26].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[26].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[26].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[26].U64[0] = state.v[26].U64[0] & ~temp1;
			state.v[26].U64[1] = state.v[26].U64[1] & ~temp2;
			state.v[26].U64[0] = state.v[26].U64[0] | value1;
			state.v[26].U64[1] = state.v[26].U64[1] | value2;
		}
	}


	// 4001d2c: <4a0f8ec8>	VMACF     vec27 = ( acc += (vec17 * vec15[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[27].U16[0], state.v[17].U16[0], state.v[15].U16[0], 1, 1, 1, 1)
		VMACF_operation(1, state.v[27].U16[1], state.v[17].U16[1], state.v[15].U16[1], 1, 1, 1, 1)
		VMACF_operation(2, state.v[27].U16[2], state.v[17].U16[2], state.v[15].U16[2], 1, 1, 1, 1)
		VMACF_operation(3, state.v[27].U16[3], state.v[17].U16[3], state.v[15].U16[3], 1, 1, 1, 1)
		VMACF_operation(4, state.v[27].U16[4], state.v[17].U16[4], state.v[15].U16[4], 1, 1, 1, 1)
		VMACF_operation(5, state.v[27].U16[5], state.v[17].U16[5], state.v[15].U16[5], 1, 1, 1, 1)
		VMACF_operation(6, state.v[27].U16[6], state.v[17].U16[6], state.v[15].U16[6], 1, 1, 1, 1)
		VMACF_operation(7, state.v[27].U16[7], state.v[17].U16[7], state.v[15].U16[7], 1, 1, 1, 1)
	}

_04001D30:
	;
}

void GoldenEye1D60_1D8C(void)
{

	// 4001d60: <4bd89400>	VMULF     vec16 = ( acc = (vec18 * vec24[6]) << 1 ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[18*16].U16[0]
			MOVQ mm1, state.v[18*16].U16[4*2]
			PSHUFW mm4, state.v[24*16].U16[1*2], 0
			MOVQ mm6, mm0
			MOVQ mm7, mm1
			PMULLW mm0, mm4
			PMULLW mm1, mm4
			//mm2 = result << 1
			MOVQ    mm2, mm0
			MOVQ   mm3, mm1
			PSLLW   mm2, 1
			PSLLW  mm3, 1
			//mm6 = result >> 15
			PMULHW  mm6, mm4
			PMULHW  mm7, mm4
			//get 0x4000 bit of result
			PSRLW   mm2, 14 ; get last 3 bits to add
			PSRLW   mm3, 14
			//if (result & 0x4000) hiValue++;
			PADDSW  mm6, mm2 ;hiValue + (1, 2, 3 or 0)
			PADDSW  mm7, mm3
			PSLLW   mm6, 1
			PSLLW   mm7, 1
			MOVQ state.v[16*16].U16[0], mm6
			MOVQ state.v[16*16].U16[4*2], mm7
		}
	}


	// 4001d64: <21cefff0>	ADDI      T6 = T6 + fff0
	state.r[T6] = state.r[T6] + 0xFFFFFFF0;


	// 4001d68: <4bf893c0>	VMULF     vec15 = ( acc = (vec18 * vec24[7]) << 1 ) >> 16
	{
		__asm {
			MOVQ mm0, state.v[18*16].U16[0]
			MOVQ mm1, state.v[18*16].U16[4*2]
			PSHUFW mm4, state.v[24*16].U16[0*2], 0
			MOVQ mm6, mm0
			MOVQ mm7, mm1
			PMULLW mm0, mm4
			PMULLW mm1, mm4
			//mm2 = result << 1
			MOVQ    mm2, mm0
			MOVQ   mm3, mm1
			PSLLW   mm2, 1
			PSLLW  mm3, 1
			//mm6 = result >> 15
			PMULHW  mm6, mm4
			PMULHW  mm7, mm4
			//get 0x4000 bit of result
			PSRLW   mm2, 14 ; get last 3 bits to add
			PSRLW   mm3, 14
			//if (result & 0x4000) hiValue++;
			PADDSW  mm6, mm2 ;hiValue + (1, 2, 3 or 0)
			PADDSW  mm7, mm3
			PSLLW   mm6, 1
			PSLLW   mm7, 1
			MOVQ state.v[15*16].U16[0], mm6
			MOVQ state.v[15*16].U16[4*2], mm7
		}
	}


	// 4001d6c: <22730010>	ADDI      S3 = S3 + 0010
	state.r[S3] = state.r[S3] + 0x0010;


	// 4001d70: <4bcae700>	VMULF     vec28 = ( acc = (vec28 * vec10[6]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[1];
		VMULF_operation(0, state.v[28].U16[0], state.v[28].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[28].U16[1], state.v[28].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[28].U16[2], state.v[28].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[28].U16[3], state.v[28].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[28].U16[4], state.v[28].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[28].U16[5], state.v[28].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[28].U16[6], state.v[28].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[28].U16[7], state.v[28].U16[7], s2value, 0, 1, 1, 1)
	}


	// 4001d74: <022f8820>	ADD       S1 = S1+T7
	state.r[S1] = (state.r[S1] + state.r[T7]);


	// 4001d78: <4a108f08>	VMACF     vec28 = ( acc += (vec17 * vec16[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[28].U16[0], state.v[17].U16[0], state.v[16].U16[0], 1, 0, 0, 1)
		VMACF_operation(1, state.v[28].U16[1], state.v[17].U16[1], state.v[16].U16[1], 1, 0, 0, 1)
		VMACF_operation(2, state.v[28].U16[2], state.v[17].U16[2], state.v[16].U16[2], 1, 0, 0, 1)
		VMACF_operation(3, state.v[28].U16[3], state.v[17].U16[3], state.v[16].U16[3], 1, 0, 0, 1)
		VMACF_operation(4, state.v[28].U16[4], state.v[17].U16[4], state.v[16].U16[4], 1, 0, 0, 1)
		VMACF_operation(5, state.v[28].U16[5], state.v[17].U16[5], state.v[16].U16[5], 1, 0, 0, 1)
		VMACF_operation(6, state.v[28].U16[6], state.v[17].U16[6], state.v[16].U16[6], 1, 0, 0, 1)
		VMACF_operation(7, state.v[28].U16[7], state.v[17].U16[7], state.v[16].U16[7], 1, 0, 0, 1)
	}


	// 4001d7c: <21ad0010>	ADDI      T5 = T5 + 0010
	state.r[T5] = state.r[T5] + 0x0010;


	// 4001d80: <4bcad680>	VMULF     vec26 = ( acc = (vec26 * vec10[6]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[1];
		VMULF_operation(0, state.v[26].U16[0], state.v[26].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[26].U16[1], state.v[26].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[26].U16[2], state.v[26].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[26].U16[3], state.v[26].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[26].U16[4], state.v[26].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[26].U16[5], state.v[26].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[26].U16[6], state.v[26].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[26].U16[7], state.v[26].U16[7], s2value, 0, 1, 1, 1)
	}


	// 4001d84: <4a0f8e88>	VMACF     vec26 = ( acc += (vec17 * vec15[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[26].U16[0], state.v[17].U16[0], state.v[15].U16[0], 1, 1, 1, 1)
		VMACF_operation(1, state.v[26].U16[1], state.v[17].U16[1], state.v[15].U16[1], 1, 1, 1, 1)
		VMACF_operation(2, state.v[26].U16[2], state.v[17].U16[2], state.v[15].U16[2], 1, 1, 1, 1)
		VMACF_operation(3, state.v[26].U16[3], state.v[17].U16[3], state.v[15].U16[3], 1, 1, 1, 1)
		VMACF_operation(4, state.v[26].U16[4], state.v[17].U16[4], state.v[15].U16[4], 1, 1, 1, 1)
		VMACF_operation(5, state.v[26].U16[5], state.v[17].U16[5], state.v[15].U16[5], 1, 1, 1, 1)
		VMACF_operation(6, state.v[26].U16[6], state.v[17].U16[6], state.v[15].U16[6], 1, 1, 1, 1)
		VMACF_operation(7, state.v[26].U16[7], state.v[17].U16[7], state.v[15].U16[7], 1, 1, 1, 1)
	}


	// 4001d88: <ea5c2000>	SQV       [S2 + 0x00] = vec28 <00>
	{
		_u32    addr = (0x00000000 + state.r[S2]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[28].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[28].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[28].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[28].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[28].U64[0] & temp1);
			value2 |= (state.v[28].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


	// 4001d8c: <22520010>	ADDI      S2 = S2 + 0010
	state.r[S2] = state.r[S2] + 0x0010;

_04001D90:
	;
}
