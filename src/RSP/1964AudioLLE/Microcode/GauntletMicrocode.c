//RSP microcode

#include "../../Shared/rsp_prefix.h"
#include "../../Shared/rsp_macros.h"
#include "Microcode.h"

void _GauntletData(_u32 StartAddress);


void _GauntletBootCode(_u32 StartAddress)
{
	static _u32	JumpTable[(0x1000 >> 2)];
	static _u32	BuildJumpTable = 0;

	if (!BuildJumpTable)
	{
		BuildJumpTable = 1;
		goto _BuildJumpTable;
	}

	_Label:
	StartAddress = JumpTable[(StartAddress & 0x0FFF) >> 2];
	__asm mov eax, StartAddress
	__asm jmp eax


_04001000:	// 4001000: <09000419>	J         04001064
	state.r[AT] = 0 + 0x0FC0;
	goto _04001064;


_04001004:	// 4001004: <20010fc0>	ADDI      AT = R0 + 0fc0
	state.r[AT] = 0 + 0x0FC0;


_04001008:	// 4001008: <8c220010>	LW        V0 = [AT+0010]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000010) & 0xfff);


_0400100C:	// 400100c: <20030f7f>	ADDI      V1 = R0 + 0f7f
	state.r[V1] = 0 + 0x0F7F;


_04001010:	// 4001010: <20071080>	ADDI      A3 = R0 + 1080
	state.r[A3] = 0 + 0x1080;


_04001014:	// 4001014: <40870000>	MTC0      SP memory address = A3
	DMEM_Address = state.r[A3];


_04001018:	// 4001018: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_0400101C:	// 400101c: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x04001020;
	_GauntletData(0x04001020);
	return;


_04001020:	// 4001020: <40043000>	MFC0      A2 = SP status
	state.r[A0] = 0;


_04001024:	// 4001024: <1480fffe>	BNE       (R0!=A0) --> 1020
	sp_reg_pc = 0x04001024;
	if (state.r[A0] != 0)
	{
		goto _04001020;
	}


_04001028:	// 4001028: <00000000>	NOP       


_0400102C:	// 400102c: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x0400102C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_04001030:	// 4001030: <00000000>	NOP       


_04001034:	// 4001034: <00e00008>	JR        A3
	{
		_u32	temp = ((state.r[A3] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001038:	// 4001038: <40803800>	MTC0      SP semaphore = R0


_0400103C:	// 400103c: <40082000>	MFC0      A0 = DP CMD DMA start
	state.r[T0] = 0;


_04001040:	// 4001040: <31080080>	ANDI      T0 = T0 & 0080
	state.r[T0] = (state.r[T0] & 0x00000080);


_04001044:	// 4001044: <15000002>	BNE       (R0!=T0) --> 1050
	sp_reg_pc = 0x04001044;
	if (state.r[T0] != 0)
	{
		goto _04001050;
	}


_04001048:	// 4001048: <00000000>	NOP       


_0400104C:	// 400104c: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001050:	// 4001050: <40803800>	MTC0      SP semaphore = R0


_04001054:	// 4001054: <34085200>	ORI       T0 = R0 | 0x5200
	state.r[T0] = (0 | 0x00005200);


_04001058:	// 4001058: <40882000>	MTC0      SP status = T0


_0400105C:	// 400105c: <0000000d>	BREAK
	state.halt = 1;
	return;


_04001060:	// 4001060: <00000000>	NOP       


_04001064:	// 4001064: <8c220004>	LW        V0 = [AT+0004]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000004) & 0xfff);


_04001068:	// 4001068: <30420002>	ANDI      V0 = V0 & 0002
	state.r[V0] = (state.r[V0] & 0x00000002);


_0400106C:	// 400106c: <10400007>	BEQ       (R0==V0) --> 108c
	sp_reg_pc = 0x0400106C;
	if (state.r[V0] == 0)
	{
		goto _0400108C;
	}


_04001070:	// 4001070: <00000000>	NOP       


_04001074:	// 4001074: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x04001074;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_04001078:	// 4001078: <00000000>	NOP       


_0400107C:	// 400107c: <40025800>	MFC0      T3 = SP read DMA length
	state.r[V0] = 0;


_04001080:	// 4001080: <30420100>	ANDI      V0 = V0 & 0100
	state.r[V0] = (state.r[V0] & 0x00000100);


_04001084:	// 4001084: <1c40ffed>	BGTZ      (R0>0) --> 103c
	sp_reg_pc = 0x04001084;
	if((_s32)state.r[V0] > 0)
	{
		goto _0400103C;
	}


_04001088:	// 4001088: <00000000>	NOP       


_0400108C:	// 400108c: <8c220018>	LW        V0 = [AT+0018]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000018) & 0xfff);


_04001090:	// 4001090: <8c23001c>	LW        V1 = [AT+001c]
	state.r[V1] = (_s32)Load32_DMEM((state.r[AT] + 0x0000001C) & 0xfff);


_04001094:	// 4001094: <2063ffff>	ADDI      V1 = V1 + ffff
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;


_04001098:	// 4001098: <401e2800>	MFC0      A1 = unknown
	state.r[S8] = 0;


_0400109C:	// 400109c: <17c0fffe>	BNE       (R0!=S8) --> 1098
	sp_reg_pc = 0x0400109C;
	if (state.r[S8] != 0)
	{
		goto _04001098;
	}


_040010A0:	// 40010a0: <00000000>	NOP       


_040010A4:	// 40010a4: <40800000>	MTC0      SP memory address = R0
	DMEM_Address = 0;


_040010A8:	// 40010a8: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_040010AC:	// 40010ac: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x040010AC;
	DMARead(state.r[V1]);


_040010B0:	// 40010b0: <40043000>	MFC0      A2 = SP status
	state.r[A0] = 0;


_040010B4:	// 40010b4: <1480fffe>	BNE       (R0!=A0) --> 10b0
	sp_reg_pc = 0x040010B4;
	if (state.r[A0] != 0)
	{
		goto _040010B0;
	}


_040010B8:	// 40010b8: <00000000>	NOP       


_040010BC:	// 40010bc: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x040010BC;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_040010C0:	// 40010c0: <00000000>	NOP       


_040010C4:	// 40010c4: <09000402>	J         04001008
	goto _04001008;


_040010C8:	// 40010c8: <00000000>	NOP       

_040010CC:
_040010D0:
_040010D4:
_040010D8:
_040010DC:
_040010E0:
_040010E4:
_040010E8:
_040010EC:
_040010F0:
_040010F4:
_040010F8:
_040010FC:
_04001100:
_04001104:
_04001108:
_0400110C:
_04001110:
_04001114:
_04001118:
_0400111C:
_04001120:
_04001124:
_04001128:
_0400112C:
_04001130:
_04001134:
_04001138:
_0400113C:
_04001140:
_04001144:
_04001148:
_0400114C:
_04001150:
_04001154:
_04001158:
_0400115C:
_04001160:
_04001164:
_04001168:
_0400116C:
_04001170:
_04001174:
_04001178:
_0400117C:
_04001180:
_04001184:
_04001188:
_0400118C:
_04001190:
_04001194:
_04001198:
_0400119C:
_040011A0:
_040011A4:
_040011A8:
_040011AC:
_040011B0:
_040011B4:
_040011B8:
_040011BC:
_040011C0:
_040011C4:
_040011C8:
_040011CC:
_040011D0:
_040011D4:
_040011D8:
_040011DC:
_040011E0:
_040011E4:
_040011E8:
_040011EC:
_040011F0:
_040011F4:
_040011F8:
_040011FC:
_04001200:
_04001204:
_04001208:
_0400120C:
_04001210:
_04001214:
_04001218:
_0400121C:
_04001220:
_04001224:
_04001228:
_0400122C:
_04001230:
_04001234:
_04001238:
_0400123C:
_04001240:
_04001244:
_04001248:
_0400124C:
_04001250:
_04001254:
_04001258:
_0400125C:
_04001260:
_04001264:
_04001268:
_0400126C:
_04001270:
_04001274:
_04001278:
_0400127C:
_04001280:
_04001284:
_04001288:
_0400128C:
_04001290:
_04001294:
_04001298:
_0400129C:
_040012A0:
_040012A4:
_040012A8:
_040012AC:
_040012B0:
_040012B4:
_040012B8:
_040012BC:
_040012C0:
_040012C4:
_040012C8:
_040012CC:
_040012D0:
_040012D4:
_040012D8:
_040012DC:
_040012E0:
_040012E4:
_040012E8:
_040012EC:
_040012F0:
_040012F4:
_040012F8:
_040012FC:
_04001300:
_04001304:
_04001308:
_0400130C:
_04001310:
_04001314:
_04001318:
_0400131C:
_04001320:
_04001324:
_04001328:
_0400132C:
_04001330:
_04001334:
_04001338:
_0400133C:
_04001340:
_04001344:
_04001348:
_0400134C:
_04001350:
_04001354:
_04001358:
_0400135C:
_04001360:
_04001364:
_04001368:
_0400136C:
_04001370:
_04001374:
_04001378:
_0400137C:
_04001380:
_04001384:
_04001388:
_0400138C:
_04001390:
_04001394:
_04001398:
_0400139C:
_040013A0:
_040013A4:
_040013A8:
_040013AC:
_040013B0:
_040013B4:
_040013B8:
_040013BC:
_040013C0:
_040013C4:
_040013C8:
_040013CC:
_040013D0:
_040013D4:
_040013D8:
_040013DC:
_040013E0:
_040013E4:
_040013E8:
_040013EC:
_040013F0:
_040013F4:
_040013F8:
_040013FC:
_04001400:
_04001404:
_04001408:
_0400140C:
_04001410:
_04001414:
_04001418:
_0400141C:
_04001420:
_04001424:
_04001428:
_0400142C:
_04001430:
_04001434:
_04001438:
_0400143C:
_04001440:
_04001444:
_04001448:
_0400144C:
_04001450:
_04001454:
_04001458:
_0400145C:
_04001460:
_04001464:
_04001468:
_0400146C:
_04001470:
_04001474:
_04001478:
_0400147C:
_04001480:
_04001484:
_04001488:
_0400148C:
_04001490:
_04001494:
_04001498:
_0400149C:
_040014A0:
_040014A4:
_040014A8:
_040014AC:
_040014B0:
_040014B4:
_040014B8:
_040014BC:
_040014C0:
_040014C4:
_040014C8:
_040014CC:
_040014D0:
_040014D4:
_040014D8:
_040014DC:
_040014E0:
_040014E4:
_040014E8:
_040014EC:
_040014F0:
_040014F4:
_040014F8:
_040014FC:
_04001500:
_04001504:
_04001508:
_0400150C:
_04001510:
_04001514:
_04001518:
_0400151C:
_04001520:
_04001524:
_04001528:
_0400152C:
_04001530:
_04001534:
_04001538:
_0400153C:
_04001540:
_04001544:
_04001548:
_0400154C:
_04001550:
_04001554:
_04001558:
_0400155C:
_04001560:
_04001564:
_04001568:
_0400156C:
_04001570:
_04001574:
_04001578:
_0400157C:
_04001580:
_04001584:
_04001588:
_0400158C:
_04001590:
_04001594:
_04001598:
_0400159C:
_040015A0:
_040015A4:
_040015A8:
_040015AC:
_040015B0:
_040015B4:
_040015B8:
_040015BC:
_040015C0:
_040015C4:
_040015C8:
_040015CC:
_040015D0:
_040015D4:
_040015D8:
_040015DC:
_040015E0:
_040015E4:
_040015E8:
_040015EC:
_040015F0:
_040015F4:
_040015F8:
_040015FC:
_04001600:
_04001604:
_04001608:
_0400160C:
_04001610:
_04001614:
_04001618:
_0400161C:
_04001620:
_04001624:
_04001628:
_0400162C:
_04001630:
_04001634:
_04001638:
_0400163C:
_04001640:
_04001644:
_04001648:
_0400164C:
_04001650:
_04001654:
_04001658:
_0400165C:
_04001660:
_04001664:
_04001668:
_0400166C:
_04001670:
_04001674:
_04001678:
_0400167C:
_04001680:
_04001684:
_04001688:
_0400168C:
_04001690:
_04001694:
_04001698:
_0400169C:
_040016A0:
_040016A4:
_040016A8:
_040016AC:
_040016B0:
_040016B4:
_040016B8:
_040016BC:
_040016C0:
_040016C4:
_040016C8:
_040016CC:
_040016D0:
_040016D4:
_040016D8:
_040016DC:
_040016E0:
_040016E4:
_040016E8:
_040016EC:
_040016F0:
_040016F4:
_040016F8:
_040016FC:
_04001700:
_04001704:
_04001708:
_0400170C:
_04001710:
_04001714:
_04001718:
_0400171C:
_04001720:
_04001724:
_04001728:
_0400172C:
_04001730:
_04001734:
_04001738:
_0400173C:
_04001740:
_04001744:
_04001748:
_0400174C:
_04001750:
_04001754:
_04001758:
_0400175C:
_04001760:
_04001764:
_04001768:
_0400176C:
_04001770:
_04001774:
_04001778:
_0400177C:
_04001780:
_04001784:
_04001788:
_0400178C:
_04001790:
_04001794:
_04001798:
_0400179C:
_040017A0:
_040017A4:
_040017A8:
_040017AC:
_040017B0:
_040017B4:
_040017B8:
_040017BC:
_040017C0:
_040017C4:
_040017C8:
_040017CC:
_040017D0:
_040017D4:
_040017D8:
_040017DC:
_040017E0:
_040017E4:
_040017E8:
_040017EC:
_040017F0:
_040017F4:
_040017F8:
_040017FC:
_04001800:
_04001804:
_04001808:
_0400180C:
_04001810:
_04001814:
_04001818:
_0400181C:
_04001820:
_04001824:
_04001828:
_0400182C:
_04001830:
_04001834:
_04001838:
_0400183C:
_04001840:
_04001844:
_04001848:
_0400184C:
_04001850:
_04001854:
_04001858:
_0400185C:
_04001860:
_04001864:
_04001868:
_0400186C:
_04001870:
_04001874:
_04001878:
_0400187C:
_04001880:
_04001884:
_04001888:
_0400188C:
_04001890:
_04001894:
_04001898:
_0400189C:
_040018A0:
_040018A4:
_040018A8:
_040018AC:
_040018B0:
_040018B4:
_040018B8:
_040018BC:
_040018C0:
_040018C4:
_040018C8:
_040018CC:
_040018D0:
_040018D4:
_040018D8:
_040018DC:
_040018E0:
_040018E4:
_040018E8:
_040018EC:
_040018F0:
_040018F4:
_040018F8:
_040018FC:
_04001900:
_04001904:
_04001908:
_0400190C:
_04001910:
_04001914:
_04001918:
_0400191C:
_04001920:
_04001924:
_04001928:
_0400192C:
_04001930:
_04001934:
_04001938:
_0400193C:
_04001940:
_04001944:
_04001948:
_0400194C:
_04001950:
_04001954:
_04001958:
_0400195C:
_04001960:
_04001964:
_04001968:
_0400196C:
_04001970:
_04001974:
_04001978:
_0400197C:
_04001980:
_04001984:
_04001988:
_0400198C:
_04001990:
_04001994:
_04001998:
_0400199C:
_040019A0:
_040019A4:
_040019A8:
_040019AC:
_040019B0:
_040019B4:
_040019B8:
_040019BC:
_040019C0:
_040019C4:
_040019C8:
_040019CC:
_040019D0:
_040019D4:
_040019D8:
_040019DC:
_040019E0:
_040019E4:
_040019E8:
_040019EC:
_040019F0:
_040019F4:
_040019F8:
_040019FC:
_04001A00:
_04001A04:
_04001A08:
_04001A0C:
_04001A10:
_04001A14:
_04001A18:
_04001A1C:
_04001A20:
_04001A24:
_04001A28:
_04001A2C:
_04001A30:
_04001A34:
_04001A38:
_04001A3C:
_04001A40:
_04001A44:
_04001A48:
_04001A4C:
_04001A50:
_04001A54:
_04001A58:
_04001A5C:
_04001A60:
_04001A64:
_04001A68:
_04001A6C:
_04001A70:
_04001A74:
_04001A78:
_04001A7C:
_04001A80:
_04001A84:
_04001A88:
_04001A8C:
_04001A90:
_04001A94:
_04001A98:
_04001A9C:
_04001AA0:
_04001AA4:
_04001AA8:
_04001AAC:
_04001AB0:
_04001AB4:
_04001AB8:
_04001ABC:
_04001AC0:
_04001AC4:
_04001AC8:
_04001ACC:
_04001AD0:
_04001AD4:
_04001AD8:
_04001ADC:
_04001AE0:
_04001AE4:
_04001AE8:
_04001AEC:
_04001AF0:
_04001AF4:
_04001AF8:
_04001AFC:
_04001B00:
_04001B04:
_04001B08:
_04001B0C:
_04001B10:
_04001B14:
_04001B18:
_04001B1C:
_04001B20:
_04001B24:
_04001B28:
_04001B2C:
_04001B30:
_04001B34:
_04001B38:
_04001B3C:
_04001B40:
_04001B44:
_04001B48:
_04001B4C:
_04001B50:
_04001B54:
_04001B58:
_04001B5C:
_04001B60:
_04001B64:
_04001B68:
_04001B6C:
_04001B70:
_04001B74:
_04001B78:
_04001B7C:
_04001B80:
_04001B84:
_04001B88:
_04001B8C:
_04001B90:
_04001B94:
_04001B98:
_04001B9C:
_04001BA0:
_04001BA4:
_04001BA8:
_04001BAC:
_04001BB0:
_04001BB4:
_04001BB8:
_04001BBC:
_04001BC0:
_04001BC4:
_04001BC8:
_04001BCC:
_04001BD0:
_04001BD4:
_04001BD8:
_04001BDC:
_04001BE0:
_04001BE4:
_04001BE8:
_04001BEC:
_04001BF0:
_04001BF4:
_04001BF8:
_04001BFC:
_04001C00:
_04001C04:
_04001C08:
_04001C0C:
_04001C10:
_04001C14:
_04001C18:
_04001C1C:
_04001C20:
_04001C24:
_04001C28:
_04001C2C:
_04001C30:
_04001C34:
_04001C38:
_04001C3C:
_04001C40:
_04001C44:
_04001C48:
_04001C4C:
_04001C50:
_04001C54:
_04001C58:
_04001C5C:
_04001C60:
_04001C64:
_04001C68:
_04001C6C:
_04001C70:
_04001C74:
_04001C78:
_04001C7C:
_04001C80:
_04001C84:
_04001C88:
_04001C8C:
_04001C90:
_04001C94:
_04001C98:
_04001C9C:
_04001CA0:
_04001CA4:
_04001CA8:
_04001CAC:
_04001CB0:
_04001CB4:
_04001CB8:
_04001CBC:
_04001CC0:
_04001CC4:
_04001CC8:
_04001CCC:
_04001CD0:
_04001CD4:
_04001CD8:
_04001CDC:
_04001CE0:
_04001CE4:
_04001CE8:
_04001CEC:
_04001CF0:
_04001CF4:
_04001CF8:
_04001CFC:
_04001D00:
_04001D04:
_04001D08:
_04001D0C:
_04001D10:
_04001D14:
_04001D18:
_04001D1C:
_04001D20:
_04001D24:
_04001D28:
_04001D2C:
_04001D30:
_04001D34:
_04001D38:
_04001D3C:
_04001D40:
_04001D44:
_04001D48:
_04001D4C:
_04001D50:
_04001D54:
_04001D58:
_04001D5C:
_04001D60:
_04001D64:
_04001D68:
_04001D6C:
_04001D70:
_04001D74:
_04001D78:
_04001D7C:
_04001D80:
_04001D84:
_04001D88:
_04001D8C:
_04001D90:
_04001D94:
_04001D98:
_04001D9C:
_04001DA0:
_04001DA4:
_04001DA8:
_04001DAC:
_04001DB0:
_04001DB4:
_04001DB8:
_04001DBC:
_04001DC0:
_04001DC4:
_04001DC8:
_04001DCC:
_04001DD0:
_04001DD4:
_04001DD8:
_04001DDC:
_04001DE0:
_04001DE4:
_04001DE8:
_04001DEC:
_04001DF0:
_04001DF4:
_04001DF8:
_04001DFC:
_04001E00:
_04001E04:
_04001E08:
_04001E0C:
_04001E10:
_04001E14:
_04001E18:
_04001E1C:
_04001E20:
_04001E24:
_04001E28:
_04001E2C:
_04001E30:
_04001E34:
_04001E38:
_04001E3C:
_04001E40:
_04001E44:
_04001E48:
_04001E4C:
_04001E50:
_04001E54:
_04001E58:
_04001E5C:
_04001E60:
_04001E64:
_04001E68:
_04001E6C:
_04001E70:
_04001E74:
_04001E78:
_04001E7C:
_04001E80:
_04001E84:
_04001E88:
_04001E8C:
_04001E90:
_04001E94:
_04001E98:
_04001E9C:
_04001EA0:
_04001EA4:
_04001EA8:
_04001EAC:
_04001EB0:
_04001EB4:
_04001EB8:
_04001EBC:
_04001EC0:
_04001EC4:
_04001EC8:
_04001ECC:
_04001ED0:
_04001ED4:
_04001ED8:
_04001EDC:
_04001EE0:
_04001EE4:
_04001EE8:
_04001EEC:
_04001EF0:
_04001EF4:
_04001EF8:
_04001EFC:
_04001F00:
_04001F04:
_04001F08:
_04001F0C:
_04001F10:
_04001F14:
_04001F18:
_04001F1C:
_04001F20:
_04001F24:
_04001F28:
_04001F2C:
_04001F30:
_04001F34:
_04001F38:
_04001F3C:
_04001F40:
_04001F44:
_04001F48:
_04001F4C:
_04001F50:
_04001F54:
_04001F58:
_04001F5C:
_04001F60:
_04001F64:
_04001F68:
_04001F6C:
_04001F70:
_04001F74:
_04001F78:
_04001F7C:
_04001F80:
_04001F84:
_04001F88:
_04001F8C:
_04001F90:
_04001F94:
_04001F98:
_04001F9C:
_04001FA0:
_04001FA4:
_04001FA8:
_04001FAC:
_04001FB0:
_04001FB4:
_04001FB8:
_04001FBC:
_04001FC0:
_04001FC4:
_04001FC8:
_04001FCC:
_04001FD0:
_04001FD4:
_04001FD8:
_04001FDC:
_04001FE0:
_04001FE4:
_04001FE8:
_04001FEC:
_04001FF0:
_04001FF4:
_04001FF8:
_04001FFC:
	state.halt = 1;
	return;

	_BuildJumpTable:
	#include "jumptable.h"
	goto _Label;
}

void _GauntletData(_u32 StartAddress)
{
	static _u32	JumpTable[(0x1000 >> 2)];
	static _u32	BuildJumpTable = 0;

	if (!BuildJumpTable)
	{
		BuildJumpTable = 1;
		goto _BuildJumpTable;
	}

	_Label:
	StartAddress = JumpTable[(StartAddress & 0x0FFF) >> 2];
	__asm mov eax, StartAddress
	__asm jmp eax


_04001000:	// 4001000: <09000419>	J         04001064
	state.r[AT] = 0 + 0x0FC0;
	goto _04001064;


_04001004:	// 4001004: <20010fc0>	ADDI      AT = R0 + 0fc0
	state.r[AT] = 0 + 0x0FC0;


_04001008:	// 4001008: <8c220010>	LW        V0 = [AT+0010]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000010) & 0xfff);


_0400100C:	// 400100c: <20030f7f>	ADDI      V1 = R0 + 0f7f
	state.r[V1] = 0 + 0x0F7F;


_04001010:	// 4001010: <20071080>	ADDI      A3 = R0 + 1080
	state.r[A3] = 0 + 0x1080;


_04001014:	// 4001014: <40870000>	MTC0      SP memory address = A3
	DMEM_Address = state.r[A3];


_04001018:	// 4001018: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_0400101C:	// 400101c: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x04001020;
	_GauntletData(0x04001020);
	return;


_04001020:	// 4001020: <40043000>	MFC0      A2 = SP status
	state.r[A0] = 0;


_04001024:	// 4001024: <1480fffe>	BNE       (R0!=A0) --> 1020
	sp_reg_pc = 0x04001024;
	if (state.r[A0] != 0)
	{
		goto _04001020;
	}


_04001028:	// 4001028: <00000000>	NOP       


_0400102C:	// 400102c: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x0400102C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_04001030:	// 4001030: <00000000>	NOP       


_04001034:	// 4001034: <00e00008>	JR        A3
	{
		_u32	temp = ((state.r[A3] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001038:	// 4001038: <40803800>	MTC0      SP semaphore = R0


_0400103C:	// 400103c: <40082000>	MFC0      A0 = DP CMD DMA start
	state.r[T0] = 0;


_04001040:	// 4001040: <31080080>	ANDI      T0 = T0 & 0080
	state.r[T0] = (state.r[T0] & 0x00000080);


_04001044:	// 4001044: <15000002>	BNE       (R0!=T0) --> 1050
	sp_reg_pc = 0x04001044;
	if (state.r[T0] != 0)
	{
		goto _04001050;
	}


_04001048:	// 4001048: <00000000>	NOP       


_0400104C:	// 400104c: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001050:	// 4001050: <40803800>	MTC0      SP semaphore = R0


_04001054:	// 4001054: <34085200>	ORI       T0 = R0 | 0x5200
	state.r[T0] = (0 | 0x00005200);


_04001058:	// 4001058: <40882000>	MTC0      SP status = T0


_0400105C:	// 400105c: <0000000d>	BREAK
	state.halt = 1;
	return;


_04001060:	// 4001060: <00000000>	NOP       


_04001064:	// 4001064: <8c220004>	LW        V0 = [AT+0004]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000004) & 0xfff);


_04001068:	// 4001068: <30420002>	ANDI      V0 = V0 & 0002
	state.r[V0] = (state.r[V0] & 0x00000002);


_0400106C:	// 400106c: <10400007>	BEQ       (R0==V0) --> 108c
	sp_reg_pc = 0x0400106C;
	if (state.r[V0] == 0)
	{
		goto _0400108C;
	}


_04001070:	// 4001070: <00000000>	NOP       


_04001074:	// 4001074: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x04001074;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_04001078:	// 4001078: <00000000>	NOP       


_0400107C:	// 400107c: <40025800>	MFC0      T3 = SP read DMA length
	state.r[V0] = 0;


_04001080:	// 4001080: <40065800>	MFC0      T3 = SP DMA busy
	state.r[A2] = 0;


_04001084:	// 4001084: <30c50001>	ANDI      A1 = A2 & 0001
	state.r[A1] = (state.r[A2] & 0x00000001);


_04001088:	// 4001088: <10a00007>	BEQ       (R0==A1) --> 10a8
	sp_reg_pc = 0x04001088;
	if (state.r[A1] == 0)
	{
		state.r[A1] = (state.r[A2] & 0x00000100);
		goto _040010A8;
	}


_0400108C:	// 400108c: <30c50100>	ANDI      A1 = A2 & 0100
	state.r[A1] = (state.r[A2] & 0x00000100);


_04001090:	// 4001090: <10a00005>	BEQ       (R0==A1) --> 10a8
	sp_reg_pc = 0x04001090;
	if (state.r[A1] == 0)
	{
		goto _040010A8;
	}


_04001094:	// 4001094: <00000000>	NOP       


_04001098:	// 4001098: <40055800>	MFC0      T3 = SP DMA full
	state.r[A1] = 0;


_0400109C:	// 400109c: <30a50100>	ANDI      A1 = A1 & 0100
	state.r[A1] = (state.r[A1] & 0x00000100);


_040010A0:	// 40010a0: <1ca0fffd>	BGTZ      (R0>0) --> 1098
	sp_reg_pc = 0x040010A0;
	if((_s32)state.r[A1] > 0)
	{
		goto _04001098;
	}


_040010A4:	// 40010a4: <00000000>	NOP       


_040010A8:	// 40010a8: <4a00002c>	VXOR      vec00 = vec00 xor vec00[<none>]
	rsp_cop2_vxor(&state.v[0], &state.v[0], &state.v[0]);


_040010AC:	// 40010ac: <8c240030>	LW        A0 = [AT+0030]
	state.r[A0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000030) & 0xfff);


_040010B0:	// 40010b0: <8c230034>	LW        V1 = [AT+0034]
	state.r[V1] = (_s32)Load32_DMEM((state.r[AT] + 0x00000034) & 0xfff);


_040010B4:	// 40010b4: <00042825>	OR        A1 = R0 | A0
	state.r[A1] = (0 | state.r[A0]);


_040010B8:	// 40010b8: <34060250>	ORI       A2 = R0 | 0x0250
	state.r[A2] = (0 | 0x00000250);


_040010BC:	// 40010bc: <0d0004fa>	JAL	    040013e8
	state.r[A3] = (0 | 0x0000000F);
	sp_reg_pc = 0x040010BC;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040013E8;


_040010C0:	// 40010c0: <3407000f>	ORI       A3 = R0 | 0x000f
	state.r[A3] = (0 | 0x0000000F);


_040010C4:	// 40010c4: <8c050258>	LW        A1 = [R0+0258]
	state.r[A1] = (_s32)Load32_DMEM((0 + 0x00000258) & 0xfff);


_040010C8:	// 40010c8: <34060bc0>	ORI       A2 = R0 | 0x0bc0
	state.r[A2] = (0 | 0x00000BC0);


_040010CC:	// 40010cc: <34070197>	ORI       A3 = R0 | 0x0197
	state.r[A3] = (0 | 0x00000197);


_040010D0:	// 40010d0: <0d0004fa>	JAL	    040013e8
	state.r[A1] = state.r[A1] + 0x0100;
	sp_reg_pc = 0x040010D0;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040013E8;


_040010D4:	// 40010d4: <24a50100>	ADDIU     A1 = A1 + 0100
	state.r[A1] = state.r[A1] + 0x0100;


_040010D8:	// 40010d8: <0d00063d>	JAL	    040018f4
	Save32_DMEM((_u32)state.r[A0], (0 + 0x00000D5C) & 0xfff);
	sp_reg_pc = 0x040010D8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040018F4;


_040010DC:	// 40010dc: <ac040d5c>	SW        [R0+0d5c] = A0
	Save32_DMEM((_u32)state.r[A0], (0 + 0x00000D5C) & 0xfff);


_040010E0:	// 40010e0: <0d000727>	JAL	    04001c9c
	state.r[A0] = state.r[A0] + 0x0010;
	sp_reg_pc = 0x040010E0;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001C9C;


_040010E4:	// 40010e4: <24840010>	ADDIU     A0 = A0 + 0010
	state.r[A0] = state.r[A0] + 0x0010;


_040010E8:	// 40010e8: <a0000d58>	SB        [R0+0d58] = R0
	Save8_DMEM((_u8)0, (0 + 0x00000D58) & 0xfff);


_040010EC:	// 40010ec: <34020260>	ORI       V0 = R0 | 0x0260
	state.r[V0] = (0 | 0x00000260);


_040010F0:	// 40010f0: <a0000d59>	SB        [R0+0d59] = R0
	Save8_DMEM((_u8)0, (0 + 0x00000D59) & 0xfff);


_040010F4:	// 40010f4: <00042825>	OR        A1 = R0 | A0
	state.r[A1] = (0 | state.r[A0]);


_040010F8:	// 40010f8: <00023025>	OR        A2 = R0 | V0
	state.r[A2] = (0 | state.r[V0]);


_040010FC:	// 40010fc: <0d000506>	JAL	    04001418
	state.r[A3] = (0 | 0x0000004F);
	sp_reg_pc = 0x040010FC;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001418;


_04001100:	// 4001100: <3407004f>	ORI       A3 = R0 | 0x004f
	state.r[A3] = (0 | 0x0000004F);


_04001104:	// 4001104: <0d00065d>	JAL	    04001974
	sp_reg_pc = 0x04001104;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001974;


_04001108:	// 4001108: <00000000>	NOP       


_0400110C:	// 400110c: <0d00050f>	JAL	    0400143c
	state.r[A2] = (_s32)(_u16)Load16_DMEM((state.r[V0] + 0x0000002C) & 0xfff);
	sp_reg_pc = 0x0400110C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400143C;


_04001110:	// 4001110: <9446002c>	LHU       A2 = [V0+002c]
	state.r[A2] = (_s32)(_u16)Load16_DMEM((state.r[V0] + 0x0000002C) & 0xfff);


_04001114:	// 4001114: <10c0006c>	BEQ       (R0==A2) --> 12c8
	sp_reg_pc = 0x04001114;
	if (state.r[A2] == 0)
	{
		state.r[A1] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003C) & 0xfff) ^ 3];
		goto _040012C8;
	}


_04001118:	// 4001118: <9045003c>	LBU       A1 = [V0+003c]
	state.r[A1] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003C) & 0xfff) ^ 3];


_0400111C:	// 400111c: <10a00003>	BEQ       (R0==A1) --> 112c
	sp_reg_pc = 0x0400111C;
	if (state.r[A1] == 0)
	{
		goto _0400112C;
	}


_04001120:	// 4001120: <00000000>	NOP       


_04001124:	// 4001124: <0d0004e1>	JAL	    04001384
	state.r[A1] = (0 | state.r[V0]);
	sp_reg_pc = 0x04001124;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001384;


_04001128:	// 4001128: <00022825>	OR        A1 = R0 | V0
	state.r[A1] = (0 | state.r[V0]);


_0400112C:	// 400112c: <9047003c>	LBU       A3 = [V0+003c]
	state.r[A3] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003C) & 0xfff) ^ 3];


_04001130:	// 4001130: <14e00016>	BNE       (R0!=A3) --> 118c
	sp_reg_pc = 0x04001130;
	if (state.r[A3] != 0)
	{
		state.r[A0] = state.r[A0] + 0x0050;
		goto _0400118C;
	}


_04001134:	// 4001134: <24840050>	ADDIU     A0 = A0 + 0050
	state.r[A0] = state.r[A0] + 0x0050;


_04001138:	// 4001138: <94470040>	LHU       A3 = [V0+0040]
	state.r[A3] = (_s32)(_u16)Load16_DMEM((state.r[V0] + 0x00000040) & 0xfff);


_0400113C:	// 400113c: <9048003e>	LBU       T0 = [V0+003e]
	state.r[T0] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003E) & 0xfff) ^ 3];


_04001140:	// 4001140: <34060a00>	ORI       A2 = R0 | 0x0a00
	state.r[A2] = (0 | 0x00000A00);


_04001144:	// 4001144: <00e83821>	ADDU      A3 = A3+T0
	state.r[A3] = (state.r[A3] + state.r[T0]);


_04001148:	// 4001148: <24e70003>	ADDIU     A3 = A3 + 0003
	state.r[A3] = state.r[A3] + 0x0003;


_0400114C:	// 400114c: <30e7fffc>	ANDI      A3 = A3 & fffc
	state.r[A3] = (state.r[A3] & 0x0000FFFC);


_04001150:	// 4001150: <00073840>	SLL       A3 = A3 << 1
	state.r[A3] = ((_u32)state.r[A3] << 1);


_04001154:	// 4001154: <00c73023>	SUBU      A2 = A2-A3
	state.r[A2] = (state.r[A2] - state.r[A3]);


_04001158:	// 4001158: <a4060d5a>	SH        [R0+0d5a] = A2
	Save16_DMEM((_u16)state.r[A2], (0 + 0x00000D5A) & 0xfff);


_0400115C:	// 400115c: <0d0004d0>	JAL	    04001340
	state.r[A1] = state.r[V0] + 0x0024;
	sp_reg_pc = 0x0400115C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001340;


_04001160:	// 4001160: <24450024>	ADDIU     A1 = V0 + 0024
	state.r[A1] = state.r[V0] + 0x0024;


_04001164:	// 4001164: <0d0004e5>	JAL	    04001394
	sp_reg_pc = 0x04001164;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001394;


_04001168:	// 4001168: <00000000>	NOP       


_0400116C:	// 400116c: <0d00050f>	JAL	    0400143c
	state.r[A3] = (_s32)(_u16)Load16_DMEM((state.r[V0] + 0x00000042) & 0xfff);
	sp_reg_pc = 0x0400116C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400143C;


_04001170:	// 4001170: <94470042>	LHU       A3 = [V0+0042]
	state.r[A3] = (_s32)(_u16)Load16_DMEM((state.r[V0] + 0x00000042) & 0xfff);


_04001174:	// 4001174: <10e00003>	BEQ       (R0==A3) --> 1184
	sp_reg_pc = 0x04001174;
	if (state.r[A3] == 0)
	{
		state.r[A2] = (0 | 0x00000600);
		goto _04001184;
	}


_04001178:	// 4001178: <34060600>	ORI       A2 = R0 | 0x0600
	state.r[A2] = (0 | 0x00000600);


_0400117C:	// 400117c: <0d0004d0>	JAL	    04001340
	state.r[A1] = state.r[V0] + 0x0030;
	sp_reg_pc = 0x0400117C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001340;


_04001180:	// 4001180: <24450030>	ADDIU     A1 = V0 + 0030
	state.r[A1] = state.r[V0] + 0x0030;


_04001184:	// 4001184: <09000480>	J         04001200
	state.r[A1] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003E) & 0xfff) ^ 3];
	goto _04001200;


_04001188:	// 4001188: <9045003e>	LBU       A1 = [V0+003e]
	state.r[A1] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003E) & 0xfff) ^ 3];


_0400118C:	// 400118c: <0d00050f>	JAL	    0400143c
	state.r[A2] = (0 | 0x00000A00);
	sp_reg_pc = 0x0400118C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400143C;


_04001190:	// 4001190: <34060a00>	ORI       A2 = R0 | 0x0a00
	state.r[A2] = (0 | 0x00000A00);


_04001194:	// 4001194: <0d0004d0>	JAL	    04001340
	state.r[A1] = state.r[V0] + 0x0024;
	sp_reg_pc = 0x04001194;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001340;


_04001198:	// 4001198: <24450024>	ADDIU     A1 = V0 + 0024
	state.r[A1] = state.r[V0] + 0x0024;


_0400119C:	// 400119c: <0d0004e5>	JAL	    04001394
	sp_reg_pc = 0x0400119C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001394;


_040011A0:	// 40011a0: <00000000>	NOP       


_040011A4:	// 40011a4: <904f003c>	LBU       T7 = [V0+003c]
	state.r[T7] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003C) & 0xfff) ^ 3];


_040011A8:	// 40011a8: <9045003e>	LBU       A1 = [V0+003e]
	state.r[A1] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003E) & 0xfff) ^ 3];


_040011AC:	// 40011ac: <340c0a00>	ORI       T4 = R0 | 0x0a00
	state.r[T4] = (0 | 0x00000A00);


_040011B0:	// 40011b0: <000f3980>	SLL       A3 = T7 << 6
	state.r[A3] = ((_u32)state.r[T7] << 6);


_040011B4:	// 40011b4: <01876023>	SUBU      T4 = T4-A3
	state.r[T4] = (state.r[T4] - state.r[A3]);


_040011B8:	// 40011b8: <00052942>	SRL       A1 = A1 >> 5
	state.r[A1] = ((_u32)state.r[A1] >> 5);


_040011BC:	// 40011bc: <340b0a00>	ORI       T3 = R0 | 0x0a00
	state.r[T3] = (0 | 0x00000A00);


_040011C0:	// 40011c0: <0d000684>	JAL	    04001a10
	Save16_DMEM((_u16)state.r[T4], (0 + 0x00000D5A) & 0xfff);
	sp_reg_pc = 0x040011C0;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001A10;


_040011C4:	// 40011c4: <a40c0d5a>	SH        [R0+0d5a] = T4
	Save16_DMEM((_u16)state.r[T4], (0 + 0x00000D5A) & 0xfff);


_040011C8:	// 40011c8: <0d00050f>	JAL	    0400143c
	state.r[A3] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003D) & 0xfff) ^ 3];
	sp_reg_pc = 0x040011C8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400143C;


_040011CC:	// 40011cc: <9047003d>	LBU       A3 = [V0+003d]
	state.r[A3] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003D) & 0xfff) ^ 3];


_040011D0:	// 40011d0: <10e00009>	BEQ       (R0==A3) --> 11f8
	sp_reg_pc = 0x040011D0;
	if (state.r[A3] == 0)
	{
		state.r[A2] = (0 | 0x00000A00);
		goto _040011F8;
	}


_040011D4:	// 40011d4: <34060a00>	ORI       A2 = R0 | 0x0a00
	state.r[A2] = (0 | 0x00000A00);


_040011D8:	// 40011d8: <0d0004d0>	JAL	    04001340
	state.r[A1] = state.r[V0] + 0x0030;
	sp_reg_pc = 0x040011D8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001340;


_040011DC:	// 40011dc: <24450030>	ADDIU     A1 = V0 + 0030
	state.r[A1] = state.r[V0] + 0x0030;


_040011E0:	// 40011e0: <9045003f>	LBU       A1 = [V0+003f]
	state.r[A1] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003F) & 0xfff) ^ 3];


_040011E4:	// 40011e4: <904f003d>	LBU       T7 = [V0+003d]
	state.r[T7] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003D) & 0xfff) ^ 3];


_040011E8:	// 40011e8: <340b0a00>	ORI       T3 = R0 | 0x0a00
	state.r[T3] = (0 | 0x00000A00);


_040011EC:	// 40011ec: <00052942>	SRL       A1 = A1 >> 5
	state.r[A1] = ((_u32)state.r[A1] >> 5);


_040011F0:	// 40011f0: <0d000684>	JAL	    04001a10
	state.r[T4] = (0 | 0x00000600);
	sp_reg_pc = 0x040011F0;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001A10;


_040011F4:	// 40011f4: <340c0600>	ORI       T4 = R0 | 0x0600
	state.r[T4] = (0 | 0x00000600);


_040011F8:	// 40011f8: <9045003e>	LBU       A1 = [V0+003e]
	state.r[A1] = (_s32)(_u8)pDMEM[((state.r[V0] + 0x0000003E) & 0xfff) ^ 3];


_040011FC:	// 40011fc: <30a5001f>	ANDI      A1 = A1 & 001f
	state.r[A1] = (state.r[A1] & 0x0000001F);


_04001200:	// 4001200: <00055825>	OR        T3 = R0 | A1
	state.r[T3] = (0 | state.r[A1]);


_04001204:	// 4001204: <90070d58>	LBU       A3 = [R0+0d58]
	state.r[A3] = (_s32)(_u8)pDMEM[((0 + 0x00000D58) & 0xfff) ^ 3];


_04001208:	// 4001208: <24e80001>	ADDIU     T0 = A3 + 0001
	state.r[T0] = state.r[A3] + 0x0001;


_0400120C:	// 400120c: <10e0000b>	BEQ       (R0==A3) --> 123c
	sp_reg_pc = 0x0400120C;
	if (state.r[A3] == 0)
	{
		Save8_DMEM((_u8)state.r[T0], (0 + 0x00000D58) & 0xfff);
		goto _0400123C;
	}


_04001210:	// 4001210: <a0080d58>	SB        [R0+0d58] = T0
	Save8_DMEM((_u8)state.r[T0], (0 + 0x00000D58) & 0xfff);


_04001214:	// 4001214: <30e5000f>	ANDI      A1 = A3 & 000f
	state.r[A1] = (state.r[A3] & 0x0000000F);


_04001218:	// 4001218: <14a00008>	BNE       (R0!=A1) --> 123c
	sp_reg_pc = 0x04001218;
	if (state.r[A1] != 0)
	{
		state.r[A3] = (state.r[A3] & 0x000000F0);
		goto _0400123C;
	}


_0400121C:	// 400121c: <30e700f0>	ANDI      A3 = A3 & 00f0
	state.r[A3] = (state.r[A3] & 0x000000F0);


_04001220:	// 4001220: <24e7fff0>	ADDIU     A3 = A3 + fff0
	state.r[A3] = state.r[A3] + 0xFFFFFFF0;


_04001224:	// 4001224: <8c060258>	LW        A2 = [R0+0258]
	state.r[A2] = (_s32)Load32_DMEM((0 + 0x00000258) & 0xfff);


_04001228:	// 4001228: <000738c0>	SLL       A3 = A3 << 3
	state.r[A3] = ((_u32)state.r[A3] << 3);


_0400122C:	// 400122c: <34050b40>	ORI       A1 = R0 | 0x0b40
	state.r[A1] = (0 | 0x00000B40);


_04001230:	// 4001230: <00c73021>	ADDU      A2 = A2+A3
	state.r[A2] = (state.r[A2] + state.r[A3]);


_04001234:	// 4001234: <0d0004ec>	JAL	    040013b0
	state.r[A3] = (0 | 0x0000007F);
	sp_reg_pc = 0x04001234;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040013B0;


_04001238:	// 4001238: <3407007f>	ORI       A3 = R0 | 0x007f
	state.r[A3] = (0 | 0x0000007F);


_0400123C:	// 400123c: <8c450044>	LW        A1 = [V0+0044]
	state.r[A1] = (_s32)Load32_DMEM((state.r[V0] + 0x00000044) & 0xfff);


_04001240:	// 4001240: <14a00009>	BNE       (R0!=A1) --> 1268
	sp_reg_pc = 0x04001240;
	if (state.r[A1] != 0)
	{
		state.r[A1] = (_s32)(_u8)pDMEM[((0 + 0x00000D59) & 0xfff) ^ 3];
		goto _04001268;
	}


_04001244:	// 4001244: <90050d59>	LBU       A1 = [R0+0d59]
	state.r[A1] = (_s32)(_u8)pDMEM[((0 + 0x00000D59) & 0xfff) ^ 3];


_04001248:	// 4001248: <14a00002>	BNE       (R0!=A1) --> 1254
	sp_reg_pc = 0x04001248;
	if (state.r[A1] != 0)
	{
		state.r[A1] = (0 | 0x00000260);
		goto _04001254;
	}


_0400124C:	// 400124c: <34050260>	ORI       A1 = R0 | 0x0260
	state.r[A1] = (0 | 0x00000260);


_04001250:	// 4001250: <340502b0>	ORI       A1 = R0 | 0x02b0
	state.r[A1] = (0 | 0x000002B0);


_04001254:	// 4001254: <90a6003c>	LBU       A2 = [A1+003c]
	state.r[A2] = (_s32)(_u8)pDMEM[((state.r[A1] + 0x0000003C) & 0xfff) ^ 3];


_04001258:	// 4001258: <10c00003>	BEQ       (R0==A2) --> 1268
	sp_reg_pc = 0x04001258;
	if (state.r[A2] == 0)
	{
		goto _04001268;
	}


_0400125C:	// 400125c: <00000000>	NOP       


_04001260:	// 4001260: <0d0004e1>	JAL	    04001384
	sp_reg_pc = 0x04001260;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001384;


_04001264:	// 4001264: <00000000>	NOP       


_04001268:	// 4001268: <0d000514>	JAL	    04001450
	state.r[A1] = (0 | state.r[T3]);
	sp_reg_pc = 0x04001268;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001450;


_0400126C:	// 400126c: <000b2825>	OR        A1 = R0 | T3
	state.r[A1] = (0 | state.r[T3]);


_04001270:	// 4001270: <8c460044>	LW        A2 = [V0+0044]
	state.r[A2] = (_s32)Load32_DMEM((state.r[V0] + 0x00000044) & 0xfff);


_04001274:	// 4001274: <14c00007>	BNE       (R0!=A2) --> 1294
	sp_reg_pc = 0x04001274;
	if (state.r[A2] != 0)
	{
		state.r[A1] = (_s32)(_u8)pDMEM[((0 + 0x00000D59) & 0xfff) ^ 3];
		goto _04001294;
	}


_04001278:	// 4001278: <90050d59>	LBU       A1 = [R0+0d59]
	state.r[A1] = (_s32)(_u8)pDMEM[((0 + 0x00000D59) & 0xfff) ^ 3];


_0400127C:	// 400127c: <38a50001>	XORI      A1 = A1 xor 0x0001
	state.r[A1] = (state.r[A1] ^ 0x00000001);


_04001280:	// 4001280: <a0050d59>	SB        [R0+0d59] = A1
	Save8_DMEM((_u8)state.r[A1], (0 + 0x00000D59) & 0xfff);


_04001284:	// 4001284: <10a0ffa9>	BEQ       (R0==A1) --> 112c
	sp_reg_pc = 0x04001284;
	if (state.r[A1] == 0)
	{
		state.r[V0] = (0 | 0x00000260);
		goto _0400112C;
	}


_04001288:	// 4001288: <34020260>	ORI       V0 = R0 | 0x0260
	state.r[V0] = (0 | 0x00000260);


_0400128C:	// 400128c: <0900044b>	J         0400112c
	state.r[V0] = (0 | 0x000002B0);
	goto _0400112C;


_04001290:	// 4001290: <340202b0>	ORI       V0 = R0 | 0x02b0
	state.r[V0] = (0 | 0x000002B0);


_04001294:	// 4001294: <90080d58>	LBU       T0 = [R0+0d58]
	state.r[T0] = (_s32)(_u8)pDMEM[((0 + 0x00000D58) & 0xfff) ^ 3];


_04001298:	// 4001298: <3107000f>	ANDI      A3 = T0 & 000f
	state.r[A3] = (state.r[T0] & 0x0000000F);


_0400129C:	// 400129c: <14e00003>	BNE       (R0!=A3) --> 12ac
	sp_reg_pc = 0x0400129C;
	if (state.r[A3] != 0)
	{
		state.r[T0] = (state.r[T0] & 0x000000F0);
		goto _040012AC;
	}


_040012A0:	// 40012a0: <310800f0>	ANDI      T0 = T0 & 00f0
	state.r[T0] = (state.r[T0] & 0x000000F0);


_040012A4:	// 40012a4: <34e70010>	ORI       A3 = A3 | 0x0010
	state.r[A3] = (state.r[A3] | 0x00000010);


_040012A8:	// 40012a8: <2508fff0>	ADDIU     T0 = T0 + fff0
	state.r[T0] = state.r[T0] + 0xFFFFFFF0;


_040012AC:	// 40012ac: <8c060258>	LW        A2 = [R0+0258]
	state.r[A2] = (_s32)Load32_DMEM((0 + 0x00000258) & 0xfff);


_040012B0:	// 40012b0: <000840c0>	SLL       T0 = T0 << 3
	state.r[T0] = ((_u32)state.r[T0] << 3);


_040012B4:	// 40012b4: <34050b40>	ORI       A1 = R0 | 0x0b40
	state.r[A1] = (0 | 0x00000B40);


_040012B8:	// 40012b8: <00c83021>	ADDU      A2 = A2+T0
	state.r[A2] = (state.r[A2] + state.r[T0]);


_040012BC:	// 40012bc: <000738c0>	SLL       A3 = A3 << 3
	state.r[A3] = ((_u32)state.r[A3] << 3);


_040012C0:	// 40012c0: <0d0004ec>	JAL	    040013b0
	state.r[A3] = state.r[A3] + 0xFFFFFFFF;
	sp_reg_pc = 0x040012C0;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040013B0;


_040012C4:	// 40012c4: <24e7ffff>	ADDIU     A3 = A3 + ffff
	state.r[A3] = state.r[A3] + 0xFFFFFFFF;


_040012C8:	// 40012c8: <0d000749>	JAL	    04001d24
	sp_reg_pc = 0x040012C8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001D24;


_040012CC:	// 40012cc: <00000000>	NOP       


_040012D0:	// 40012d0: <34050300>	ORI       A1 = R0 | 0x0300
	state.r[A1] = (0 | 0x00000300);


_040012D4:	// 40012d4: <34060480>	ORI       A2 = R0 | 0x0480
	state.r[A2] = (0 | 0x00000480);


_040012D8:	// 40012d8: <0d000600>	JAL	    04001800
	state.r[A3] = (0 | 0x00000600);
	sp_reg_pc = 0x040012D8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001800;


_040012DC:	// 40012dc: <34070600>	ORI       A3 = R0 | 0x0600
	state.r[A3] = (0 | 0x00000600);


_040012E0:	// 40012e0: <34050600>	ORI       A1 = R0 | 0x0600
	state.r[A1] = (0 | 0x00000600);


_040012E4:	// 40012e4: <8c460044>	LW        A2 = [V0+0044]
	state.r[A2] = (_s32)Load32_DMEM((state.r[V0] + 0x00000044) & 0xfff);


_040012E8:	// 40012e8: <0d0004ec>	JAL	    040013b0
	state.r[A3] = (0 | 0x000002FF);
	sp_reg_pc = 0x040012E8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040013B0;


_040012EC:	// 40012ec: <340702ff>	ORI       A3 = R0 | 0x02ff
	state.r[A3] = (0 | 0x000002FF);


_040012F0:	// 40012f0: <8c040d5c>	LW        A0 = [R0+0d5c]
	state.r[A0] = (_s32)Load32_DMEM((0 + 0x00000D5C) & 0xfff);


_040012F4:	// 40012f4: <2463ffff>	ADDIU     V1 = V1 + ffff
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;


_040012F8:	// 40012f8: <10600006>	BEQ       (R0==V1) --> 1314
	sp_reg_pc = 0x040012F8;
	if (state.r[V1] == 0)
	{
		state.r[A0] = state.r[A0] + 0x0A10;
		goto _04001314;
	}


_040012FC:	// 40012fc: <24840a10>	ADDIU     A0 = A0 + 0a10
	state.r[A0] = state.r[A0] + 0x0A10;


_04001300:	// 4001300: <00042825>	OR        A1 = R0 | A0
	state.r[A1] = (0 | state.r[A0]);


_04001304:	// 4001304: <34060250>	ORI       A2 = R0 | 0x0250
	state.r[A2] = (0 | 0x00000250);


_04001308:	// 4001308: <3407000f>	ORI       A3 = R0 | 0x000f
	state.r[A3] = (0 | 0x0000000F);


_0400130C:	// 400130c: <090004fa>	J         040013e8
	state.r[RA] = (0 | 0x000010D8);
	goto _040013E8;


_04001310:	// 4001310: <341f10d8>	ORI       RA = R0 | 0x10d8
	state.r[RA] = (0 | 0x000010D8);


_04001314:	// 4001314: <8c060258>	LW        A2 = [R0+0258]
	state.r[A2] = (_s32)Load32_DMEM((0 + 0x00000258) & 0xfff);


_04001318:	// 4001318: <34050bc0>	ORI       A1 = R0 | 0x0bc0
	state.r[A1] = (0 | 0x00000BC0);


_0400131C:	// 400131c: <34070197>	ORI       A3 = R0 | 0x0197
	state.r[A3] = (0 | 0x00000197);


_04001320:	// 4001320: <0d0004ec>	JAL	    040013b0
	state.r[A2] = state.r[A2] + 0x0100;
	sp_reg_pc = 0x04001320;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040013B0;


_04001324:	// 4001324: <24c60100>	ADDIU     A2 = A2 + 0100
	state.r[A2] = state.r[A2] + 0x0100;


_04001328:	// 4001328: <34054000>	ORI       A1 = R0 | 0x4000
	state.r[A1] = (0 | 0x00004000);


_0400132C:	// 400132c: <40852000>	MTC0      SP status = A1


_04001330:	// 4001330: <0000000d>	BREAK
	state.halt = 1;
	return;


_04001334:	// 4001334: <00000000>	NOP       


_04001338:	// 4001338: <1000ffff>	BEQ       (R0==R0) --> 1338
	sp_reg_pc = 0x04001338;
	if (0 == 0)
	{
		goto _04001338;
	}


_0400133C:	// 400133c: <00000000>	NOP       


_04001340:	// 4001340: <001ff025>	OR        S8 = R0 | RA
	state.r[S8] = (0 | state.r[RA]);


_04001344:	// 4001344: <00055825>	OR        T3 = R0 | A1
	state.r[T3] = (0 | state.r[A1]);


_04001348:	// 4001348: <00065025>	OR        T2 = R0 | A2
	state.r[T2] = (0 | state.r[A2]);


_0400134C:	// 400134c: <95670008>	LHU       A3 = [T3+0008]
	state.r[A3] = (_s32)(_u16)Load16_DMEM((state.r[T3] + 0x00000008) & 0xfff);


_04001350:	// 4001350: <8d650000>	LW        A1 = [T3+0000]
	state.r[A1] = (_s32)Load32_DMEM((state.r[T3] + 0x00000000) & 0xfff);


_04001354:	// 4001354: <01475021>	ADDU      T2 = T2+A3
	state.r[T2] = (state.r[T2] + state.r[A3]);


_04001358:	// 4001358: <0d0004fa>	JAL	    040013e8
	state.r[A3] = state.r[A3] + 0xFFFFFFFF;
	sp_reg_pc = 0x04001358;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040013E8;


_0400135C:	// 400135c: <24e7ffff>	ADDIU     A3 = A3 + ffff
	state.r[A3] = state.r[A3] + 0xFFFFFFFF;


_04001360:	// 4001360: <9567000a>	LHU       A3 = [T3+000a]
	state.r[A3] = (_s32)(_u16)Load16_DMEM((state.r[T3] + 0x0000000A) & 0xfff);


_04001364:	// 4001364: <8d650004>	LW        A1 = [T3+0004]
	state.r[A1] = (_s32)Load32_DMEM((state.r[T3] + 0x00000004) & 0xfff);


_04001368:	// 4001368: <10e00004>	BEQ       (R0==A3) --> 137c
	sp_reg_pc = 0x04001368;
	if (state.r[A3] == 0)
	{
		state.r[RA] = (0 | state.r[S8]);
		goto _0400137C;
	}


_0400136C:	// 400136c: <001ef825>	OR        RA = R0 | S8
	state.r[RA] = (0 | state.r[S8]);


_04001370:	// 4001370: <000a3025>	OR        A2 = R0 | T2
	state.r[A2] = (0 | state.r[T2]);


_04001374:	// 4001374: <090004fa>	J         040013e8
	state.r[A3] = state.r[A3] + 0xFFFFFFFF;
	goto _040013E8;


_04001378:	// 4001378: <24e7ffff>	ADDIU     A3 = A3 + ffff
	state.r[A3] = state.r[A3] + 0xFFFFFFFF;


_0400137C:	// 400137c: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001380:	// 4001380: <00000000>	NOP       


_04001384:	// 4001384: <8ca50040>	LW        A1 = [A1+0040]
	state.r[A1] = (_s32)Load32_DMEM((state.r[A1] + 0x00000040) & 0xfff);


_04001388:	// 4001388: <34060ee0>	ORI       A2 = R0 | 0x0ee0
	state.r[A2] = (0 | 0x00000EE0);


_0400138C:	// 400138c: <09000506>	J         04001418
	state.r[A3] = (0 | 0x000000FF);
	goto _04001418;


_04001390:	// 4001390: <340700ff>	ORI       A3 = R0 | 0x00ff
	state.r[A3] = (0 | 0x000000FF);


_04001394:	// 4001394: <90060d59>	LBU       A2 = [R0+0d59]
	state.r[A2] = (_s32)(_u8)pDMEM[((0 + 0x00000D59) & 0xfff) ^ 3];


_04001398:	// 4001398: <00042825>	OR        A1 = R0 | A0
	state.r[A1] = (0 | state.r[A0]);


_0400139C:	// 400139c: <14c00002>	BNE       (R0!=A2) --> 13a8
	sp_reg_pc = 0x0400139C;
	if (state.r[A2] != 0)
	{
		state.r[A2] = (0 | 0x00000260);
		goto _040013A8;
	}


_040013A0:	// 40013a0: <34060260>	ORI       A2 = R0 | 0x0260
	state.r[A2] = (0 | 0x00000260);


_040013A4:	// 40013a4: <340602b0>	ORI       A2 = R0 | 0x02b0
	state.r[A2] = (0 | 0x000002B0);


_040013A8:	// 40013a8: <09000506>	J         04001418
	state.r[A3] = (0 | 0x0000004F);
	goto _04001418;


_040013AC:	// 40013ac: <3407004f>	ORI       A3 = R0 | 0x004f
	state.r[A3] = (0 | 0x0000004F);


_040013B0:	// 40013b0: <40083800>	MFC0      A3 = DP CMD DMA start
	state.r[T0] = 0;


_040013B4:	// 40013b4: <1500fffe>	BNE       (R0!=T0) --> 13b0
	sp_reg_pc = 0x040013B4;
	if (state.r[T0] != 0)
	{
		goto _040013B0;
	}


_040013B8:	// 40013b8: <00000000>	NOP       


_040013BC:	// 40013bc: <40082800>	MFC0      A1 = DP CMD DMA start
	state.r[T0] = 0;


_040013C0:	// 40013c0: <1500fffe>	BNE       (R0!=T0) --> 13bc
	sp_reg_pc = 0x040013C0;
	if (state.r[T0] != 0)
	{
		goto _040013BC;
	}


_040013C4:	// 40013c4: <00000000>	NOP       


_040013C8:	// 40013c8: <40850000>	MTC0      SP memory address = A1
	DMEM_Address = state.r[A1];


_040013CC:	// 40013cc: <40860800>	MTC0      SP DRAM DMA address = A2
	RDRAM_Address = (state.r[A2] & 0xFFFFFF);


_040013D0:	// 40013d0: <40871800>	MTC0      SP write DMA length = A3
	DMAWrite(state.r[A3]);


_040013D4:	// 40013d4: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_040013D8:	// 40013d8: <14a0fffe>	BNE       (R0!=A1) --> 13d4
	sp_reg_pc = 0x040013D8;
	if (state.r[A1] != 0)
	{
		goto _040013D4;
	}


_040013DC:	// 40013dc: <00000000>	NOP       


_040013E0:	// 40013e0: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_040013E4:	// 40013e4: <40803800>	MTC0      SP semaphore = R0


_040013E8:	// 40013e8: <40083800>	MFC0      A3 = DP CMD DMA start
	state.r[T0] = 0;


_040013EC:	// 40013ec: <1500fffe>	BNE       (R0!=T0) --> 13e8
	sp_reg_pc = 0x040013EC;
	if (state.r[T0] != 0)
	{
		state.r[T0] = 0;
		goto _040013E8;
	}


_040013F0:	// 40013f0: <40082800>	MFC0      A1 = DP CMD DMA start
	state.r[T0] = 0;


_040013F4:	// 40013f4: <1500fffe>	BNE       (R0!=T0) --> 13f0
	sp_reg_pc = 0x040013F4;
	if (state.r[T0] != 0)
	{
		goto _040013F0;
	}


_040013F8:	// 40013f8: <00000000>	NOP       


_040013FC:	// 40013fc: <40860000>	MTC0      SP memory address = A2
	DMEM_Address = state.r[A2];


_04001400:	// 4001400: <40850800>	MTC0      SP DRAM DMA address = A1
	RDRAM_Address = (state.r[A1] & 0xFFFFFF);


_04001404:	// 4001404: <40871000>	MTC0      SP read DMA length = A3
	sp_reg_pc = 0x04001404;
	DMARead(state.r[A3]);


_04001408:	// 4001408: <14e0ffff>	BNE       (R0!=A3) --> 1408
	sp_reg_pc = 0x04001408;
	if (state.r[A3] != 0)
	{
		state.r[A3] = 0;
		goto _04001408;
	}


_0400140C:	// 400140c: <40073000>	MFC0      A2 = SP semaphore
	state.r[A3] = 0;


_04001410:	// 4001410: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001414:	// 4001414: <40803800>	MTC0      SP semaphore = R0


_04001418:	// 4001418: <40083800>	MFC0      A3 = DP CMD DMA start
	state.r[T0] = 0;


_0400141C:	// 400141c: <1500fffe>	BNE       (R0!=T0) --> 1418
	sp_reg_pc = 0x0400141C;
	if (state.r[T0] != 0)
	{
		state.r[T0] = 0;
		goto _04001418;
	}


_04001420:	// 4001420: <40082800>	MFC0      A1 = DP CMD DMA start
	state.r[T0] = 0;


_04001424:	// 4001424: <1500fffe>	BNE       (R0!=T0) --> 1420
	sp_reg_pc = 0x04001424;
	if (state.r[T0] != 0)
	{
		goto _04001420;
	}


_04001428:	// 4001428: <00000000>	NOP       


_0400142C:	// 400142c: <40860000>	MTC0      SP memory address = A2
	DMEM_Address = state.r[A2];


_04001430:	// 4001430: <40850800>	MTC0      SP DRAM DMA address = A1
	RDRAM_Address = (state.r[A1] & 0xFFFFFF);


_04001434:	// 4001434: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		sp_reg_pc = 0x04001438;
		DMARead(state.r[A3]);
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001438:	// 4001438: <40871000>	MTC0      SP read DMA length = A3
	sp_reg_pc = 0x04001438;
	DMARead(state.r[A3]);


_0400143C:	// 400143c: <400a3000>	MFC0      A2 = DP CMD DMA current
	state.r[T2] = 0;


_04001440:	// 4001440: <1540fffe>	BNE       (R0!=T2) --> 143c
	sp_reg_pc = 0x04001440;
	if (state.r[T2] != 0)
	{
		goto _0400143C;
	}


_04001444:	// 4001444: <00000000>	NOP       


_04001448:	// 4001448: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_0400144C:	// 400144c: <40803800>	MTC0      SP semaphore = R0


_04001450:	// 4001450: <001ff025>	OR        S8 = R0 | RA
	state.r[S8] = (0 | state.r[RA]);


_04001454:	// 4001454: <34070028>	ORI       A3 = R0 | 0x0028
	state.r[A3] = (0 | 0x00000028);


_04001458:	// 4001458: <4887f800>	MTC2      vec31 <00> = A3
	state.v[31].U16[7] = (_u16)state.r[A3];


_0400145C:	// 400145c: <94460022>	LHU       A2 = [V0+0022]
	state.r[A2] = (_s32)(_u16)Load16_DMEM((state.r[V0] + 0x00000022) & 0xfff);


_04001460:	// 4001460: <94070d5a>	LHU       A3 = [R0+0d5a]
	state.r[A3] = (_s32)(_u16)Load16_DMEM((0 + 0x00000D5A) & 0xfff);


_04001464:	// 4001464: <9448004e>	LHU       T0 = [V0+004e]
	state.r[T0] = (_s32)(_u16)Load16_DMEM((state.r[V0] + 0x0000004E) & 0xfff);


_04001468:	// 4001468: <945d0020>	LHU       SP = [V0+0020]
	state.r[SP] = (_s32)(_u16)Load16_DMEM((state.r[V0] + 0x00000020) & 0xfff);


_0400146C:	// 400146c: <000631c0>	SLL       A2 = A2 << 7
	state.r[A2] = ((_u32)state.r[A2] << 7);


_04001470:	// 4001470: <48863900>	MTC2      vec7 <02> = A2
	state.v[7].U16[6] = (_u16)state.r[A2];


_04001474:	// 4001474: <00063402>	SRL       A2 = A2 >> 16
	state.r[A2] = ((_u32)state.r[A2] >> 16);


_04001478:	// 4001478: <48863800>	MTC2      vec7 <00> = A2
	state.v[7].U16[7] = (_u16)state.r[A2];


_0400147C:	// 400147c: <01054021>	ADDU      T0 = T0+A1
	state.r[T0] = (state.r[T0] + state.r[A1]);


_04001480:	// 4001480: <00073842>	SRL       A3 = A3 >> 1
	state.r[A3] = ((_u32)state.r[A3] >> 1);


_04001484:	// 4001484: <01074021>	ADDU      T0 = T0+A3
	state.r[T0] = (state.r[T0] + state.r[A3]);


_04001488:	// 4001488: <00084400>	SLL       T0 = T0 << 16
	state.r[T0] = ((_u32)state.r[T0] << 16);


_0400148C:	// 400148c: <03a8e825>	OR        SP = SP | T0
	state.r[SP] = (state.r[SP] | state.r[T0]);


_04001490:	// 4001490: <94460048>	LHU       A2 = [V0+0048]
	state.r[A2] = (_s32)(_u16)Load16_DMEM((state.r[V0] + 0x00000048) & 0xfff);


_04001494:	// 4001494: <9445004a>	LHU       A1 = [V0+004a]
	state.r[A1] = (_s32)(_u16)Load16_DMEM((state.r[V0] + 0x0000004A) & 0xfff);


_04001498:	// 4001498: <00c73021>	ADDU      A2 = A2+A3
	state.r[A2] = (state.r[A2] + state.r[A3]);


_0400149C:	// 400149c: <30a88000>	ANDI      T0 = A1 & 8000
	state.r[T0] = (state.r[A1] & 0x00008000);


_040014A0:	// 40014a0: <30a57fff>	ANDI      A1 = A1 & 7fff
	state.r[A1] = (state.r[A1] & 0x00007FFF);


_040014A4:	// 40014a4: <11000002>	BEQ       (R0==T0) --> 14b0
	sp_reg_pc = 0x040014A4;
	if (state.r[T0] == 0)
	{
		state.r[A3] = (state.r[A1] + state.r[A3]);
		goto _040014B0;
	}


_040014A8:	// 40014a8: <00a73821>	ADDU      A3 = A1+A3
	state.r[A3] = (state.r[A1] + state.r[A3]);


_040014AC:	// 40014ac: <24a70300>	ADDIU     A3 = A1 + 0300
	state.r[A3] = state.r[A1] + 0x0300;


_040014B0:	// 40014b0: <4886f900>	MTC2      vec31 <02> = A2
	state.v[31].U16[6] = (_u16)state.r[A2];


_040014B4:	// 40014b4: <4887fa00>	MTC2      vec31 <04> = A3
	state.v[31].U16[5] = (_u16)state.r[A3];


_040014B8:	// 40014b8: <34050002>	ORI       A1 = R0 | 0x0002
	state.r[A1] = (0 | 0x00000002);


_040014BC:	// 40014bc: <4885fb00>	MTC2      vec31 <06> = A1
	state.v[31].U16[4] = (_u16)state.r[A1];


_040014C0:	// 40014c0: <34050008>	ORI       A1 = R0 | 0x0008
	state.r[A1] = (0 | 0x00000008);


_040014C4:	// 40014c4: <4885fc00>	MTC2      vec31 <08> = A1
	state.v[31].U16[3] = (_u16)state.r[A1];


_040014C8:	// 40014c8: <34050040>	ORI       A1 = R0 | 0x0040
	state.r[A1] = (0 | 0x00000040);


_040014CC:	// 40014cc: <4885fd00>	MTC2      vec31 <10> = A1
	state.v[31].U16[2] = (_u16)state.r[A1];


_040014D0:	// 40014d0: <34050001>	ORI       A1 = R0 | 0x0001
	state.r[A1] = (0 | 0x00000001);


_040014D4:	// 40014d4: <4885e000>	MTC2      vec28 <00> = A1
	state.v[28].U16[7] = (_u16)state.r[A1];


_040014D8:	// 40014d8: <0d0005e5>	JAL	    04001794
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[28].U16[7];
		VADD_operation(0, state.v[28].U16[0], state.v[0].U16[0], s2value, 1, 1, 1, 1)
		VADD_operation(1, state.v[28].U16[1], state.v[0].U16[1], s2value, 1, 1, 1, 1)
		VADD_operation(2, state.v[28].U16[2], state.v[0].U16[2], s2value, 1, 1, 1, 1)
		VADD_operation(3, state.v[28].U16[3], state.v[0].U16[3], s2value, 1, 1, 1, 1)
		VADD_operation(4, state.v[28].U16[4], state.v[0].U16[4], s2value, 1, 1, 1, 1)
		VADD_operation(5, state.v[28].U16[5], state.v[0].U16[5], s2value, 1, 1, 1, 1)
		VADD_operation(6, state.v[28].U16[6], state.v[0].U16[6], s2value, 1, 1, 1, 1)
		VADD_operation(7, state.v[28].U16[7], state.v[0].U16[7], s2value, 1, 1, 1, 1)
		state.flag[0] = 0x0000;
	}
	sp_reg_pc = 0x040014D8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001794;


_040014DC:	// 40014dc: <4b1c0710>	VADD      vec28 = vec00 + vec28[0]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[28].U16[7];
		VADD_operation(0, state.v[28].U16[0], state.v[0].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[28].U16[1], state.v[0].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[28].U16[2], state.v[0].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[28].U16[3], state.v[0].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[28].U16[4], state.v[0].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[28].U16[5], state.v[0].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[28].U16[6], state.v[0].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[28].U16[7], state.v[0].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040014E0:	// 40014e0: <94460022>	LHU       A2 = [V0+0022]
	state.r[A2] = (_s32)(_u16)Load16_DMEM((state.r[V0] + 0x00000022) & 0xfff);


_040014E4:	// 40014e4: <001d2825>	OR        A1 = R0 | SP
	state.r[A1] = (0 | state.r[SP]);


_040014E8:	// 40014e8: <0d0005f2>	JAL	    040017c8
	state.r[A2] = ((_u32)state.r[A2] << 4);
	sp_reg_pc = 0x040014E8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040017C8;


_040014EC:	// 40014ec: <00063100>	SLL       A2 = A2 << 4
	state.r[A2] = ((_u32)state.r[A2] << 4);


_040014F0:	// 40014f0: <4a001890>	VADD      vec02 = vec03 + vec00[<none>]
	{
		_u16		flag0 = state.flag[0];
		VADD_operation(0, state.v[2].U16[0], state.v[3].U16[0], state.v[0].U16[0], 1, 0, 0, 1)
		VADD_operation(1, state.v[2].U16[1], state.v[3].U16[1], state.v[0].U16[1], 1, 0, 0, 1)
		VADD_operation(2, state.v[2].U16[2], state.v[3].U16[2], state.v[0].U16[2], 1, 0, 0, 1)
		VADD_operation(3, state.v[2].U16[3], state.v[3].U16[3], state.v[0].U16[3], 1, 0, 0, 1)
		VADD_operation(4, state.v[2].U16[4], state.v[3].U16[4], state.v[0].U16[4], 1, 0, 0, 1)
		VADD_operation(5, state.v[2].U16[5], state.v[3].U16[5], state.v[0].U16[5], 1, 0, 0, 1)
		VADD_operation(6, state.v[2].U16[6], state.v[3].U16[6], state.v[0].U16[6], 1, 0, 0, 1)
		VADD_operation(7, state.v[2].U16[7], state.v[3].U16[7], state.v[0].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040014F4:	// 40014f4: <4a002050>	VADD      vec01 = vec04 + vec00[<none>]
	{
		_u16		flag0 = state.flag[0];
		VADD_operation(0, state.v[1].U16[0], state.v[4].U16[0], state.v[0].U16[0], 1, 0, 0, 1)
		VADD_operation(1, state.v[1].U16[1], state.v[4].U16[1], state.v[0].U16[1], 1, 0, 0, 1)
		VADD_operation(2, state.v[1].U16[2], state.v[4].U16[2], state.v[0].U16[2], 1, 0, 0, 1)
		VADD_operation(3, state.v[1].U16[3], state.v[4].U16[3], state.v[0].U16[3], 1, 0, 0, 1)
		VADD_operation(4, state.v[1].U16[4], state.v[4].U16[4], state.v[0].U16[4], 1, 0, 0, 1)
		VADD_operation(5, state.v[1].U16[5], state.v[4].U16[5], state.v[0].U16[5], 1, 0, 0, 1)
		VADD_operation(6, state.v[1].U16[6], state.v[4].U16[6], state.v[0].U16[6], 1, 0, 0, 1)
		VADD_operation(7, state.v[1].U16[7], state.v[4].U16[7], state.v[0].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040014F8:	// 40014f8: <4b3f08d1>	VSUB      vec03 = vec01 - vec31[1]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[31].U16[6];
		VSUB_operation(0, state.v[3].U16[0], state.v[1].U16[0], s2value, 1, 0, 0, 1)
		VSUB_operation(1, state.v[3].U16[1], state.v[1].U16[1], s2value, 1, 0, 0, 1)
		VSUB_operation(2, state.v[3].U16[2], state.v[1].U16[2], s2value, 1, 0, 0, 1)
		VSUB_operation(3, state.v[3].U16[3], state.v[1].U16[3], s2value, 1, 0, 0, 1)
		VSUB_operation(4, state.v[3].U16[4], state.v[1].U16[4], s2value, 1, 0, 0, 1)
		VSUB_operation(5, state.v[3].U16[5], state.v[1].U16[5], s2value, 1, 0, 0, 1)
		VSUB_operation(6, state.v[3].U16[6], state.v[1].U16[6], s2value, 1, 0, 0, 1)
		VSUB_operation(7, state.v[3].U16[7], state.v[1].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040014FC:	// 40014fc: <4b5f18d0>	VADD      vec03 = vec03 + vec31[2]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[31].U16[5];
		VADD_operation(0, state.v[3].U16[0], state.v[3].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[3].U16[1], state.v[3].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[3].U16[2], state.v[3].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[3].U16[3], state.v[3].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[3].U16[4], state.v[3].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[3].U16[5], state.v[3].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[3].U16[6], state.v[3].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[3].U16[7], state.v[3].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001500:	// 4001500: <4b3f0860>	VLT ?-?
	rsp_cop2_vlt_element(&state.v[1], &state.v[1], &state.v[31].U16[6]);


_04001504:	// 4001504: <4a030867>	VMRG ?-?
	rsp_cop2_vmrg(&state.v[1], &state.v[1], &state.v[3]);


_04001508:	// 4001508: <4b7f08c6>	VMUDN     vec03 = ( acc = vec01 * vec31[3]      ) >> 16
	{
		_u16		s2value = state.v[31].U16[4];
		VMUDN_operation(0, state.v[3].U16[0], state.v[1].U16[0], s2value, 1, 0, 0, 1)
		VMUDN_operation(1, state.v[3].U16[1], state.v[1].U16[1], s2value, 1, 0, 0, 1)
		VMUDN_operation(2, state.v[3].U16[2], state.v[1].U16[2], s2value, 1, 0, 0, 1)
		VMUDN_operation(3, state.v[3].U16[3], state.v[1].U16[3], s2value, 1, 0, 0, 1)
		VMUDN_operation(4, state.v[3].U16[4], state.v[1].U16[4], s2value, 1, 0, 0, 1)
		VMUDN_operation(5, state.v[3].U16[5], state.v[1].U16[5], s2value, 1, 0, 0, 1)
		VMUDN_operation(6, state.v[3].U16[6], state.v[1].U16[6], s2value, 1, 0, 0, 1)
		VMUDN_operation(7, state.v[3].U16[7], state.v[1].U16[7], s2value, 1, 0, 0, 1)
	}


_0400150C:	// 400150c: <4bbf1104>	VMUDL     vec04 = ( acc = (vec02 * vec31[5] >> 16)      )
	{
		_u16		s2value = state.v[31].U16[2];
		VMUDL_operation(0, state.v[4].U16[0], state.v[2].U16[0], s2value, 1, 0, 0, 1)
		VMUDL_operation(1, state.v[4].U16[1], state.v[2].U16[1], s2value, 1, 0, 0, 1)
		VMUDL_operation(2, state.v[4].U16[2], state.v[2].U16[2], s2value, 1, 0, 0, 1)
		VMUDL_operation(3, state.v[4].U16[3], state.v[2].U16[3], s2value, 1, 0, 0, 1)
		VMUDL_operation(4, state.v[4].U16[4], state.v[2].U16[4], s2value, 1, 0, 0, 1)
		VMUDL_operation(5, state.v[4].U16[5], state.v[2].U16[5], s2value, 1, 0, 0, 1)
		VMUDL_operation(6, state.v[4].U16[6], state.v[2].U16[6], s2value, 1, 0, 0, 1)
		VMUDL_operation(7, state.v[4].U16[7], state.v[2].U16[7], s2value, 1, 0, 0, 1)
	}


_04001510:	// 4001510: <4b9f2106>	VMUDN     vec04 = ( acc = vec04 * vec31[4]      ) >> 16
	{
		_u16		s2value = state.v[31].U16[3];
		VMUDN_operation(0, state.v[4].U16[0], state.v[4].U16[0], s2value, 0, 1, 1, 1)
		VMUDN_operation(1, state.v[4].U16[1], state.v[4].U16[1], s2value, 0, 1, 1, 1)
		VMUDN_operation(2, state.v[4].U16[2], state.v[4].U16[2], s2value, 0, 1, 1, 1)
		VMUDN_operation(3, state.v[4].U16[3], state.v[4].U16[3], s2value, 0, 1, 1, 1)
		VMUDN_operation(4, state.v[4].U16[4], state.v[4].U16[4], s2value, 0, 1, 1, 1)
		VMUDN_operation(5, state.v[4].U16[5], state.v[4].U16[5], s2value, 0, 1, 1, 1)
		VMUDN_operation(6, state.v[4].U16[6], state.v[4].U16[6], s2value, 0, 1, 1, 1)
		VMUDN_operation(7, state.v[4].U16[7], state.v[4].U16[7], s2value, 0, 1, 1, 1)
	}


_04001514:	// 4001514: <4b1fe10e>	VMADN     vec04 = ( acc+= vec28 * vec31[0] )
	{
		_u16		s2value = state.v[31].U16[7];
		VMADN_operation(0, state.v[4].U16[0], state.v[28].U16[0], s2value, 1, 1, 1, 1)
		VMADN_operation(1, state.v[4].U16[1], state.v[28].U16[1], s2value, 1, 1, 1, 1)
		VMADN_operation(2, state.v[4].U16[2], state.v[28].U16[2], s2value, 1, 1, 1, 1)
		VMADN_operation(3, state.v[4].U16[3], state.v[28].U16[3], s2value, 1, 1, 1, 1)
		VMADN_operation(4, state.v[4].U16[4], state.v[28].U16[4], s2value, 1, 1, 1, 1)
		VMADN_operation(5, state.v[4].U16[5], state.v[28].U16[5], s2value, 1, 1, 1, 1)
		VMADN_operation(6, state.v[4].U16[6], state.v[28].U16[6], s2value, 1, 1, 1, 1)
		VMADN_operation(7, state.v[4].U16[7], state.v[28].U16[7], s2value, 1, 1, 1, 1)
	}


_04001518:	// 4001518: <34010230>	ORI       AT = R0 | 0x0230
	state.r[AT] = (0 | 0x00000230);


_0400151C:	// 400151c: <e8232000>	SQV       [AT + 0x00] = vec03 <00>
	{
		_u32    addr = (0x00000000 + state.r[AT]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[3].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[3].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[3].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[3].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[3].U64[0] & temp1);
			value2 |= (state.v[3].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001520:	// 4001520: <e8242001>	SQV       [AT + 0x10] = vec04 <00>
	{
		_u32    addr = (0x00000010 + state.r[AT]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[4].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[4].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[4].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[4].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[4].U64[0] & temp1);
			value2 |= (state.v[4].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001524:	// 4001524: <94290000>	LHU       T1 = [AT+0000]
	state.r[T1] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000000) & 0xfff);


_04001528:	// 4001528: <942a0002>	LHU       T2 = [AT+0002]
	state.r[T2] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000002) & 0xfff);


_0400152C:	// 400152c: <942b0004>	LHU       T3 = [AT+0004]
	state.r[T3] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000004) & 0xfff);


_04001530:	// 4001530: <942c0006>	LHU       T4 = [AT+0006]
	state.r[T4] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000006) & 0xfff);


_04001534:	// 4001534: <942d0008>	LHU       T5 = [AT+0008]
	state.r[T5] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000008) & 0xfff);


_04001538:	// 4001538: <942e000a>	LHU       T6 = [AT+000a]
	state.r[T6] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000000A) & 0xfff);


_0400153C:	// 400153c: <942f000c>	LHU       T7 = [AT+000c]
	state.r[T7] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000000C) & 0xfff);


_04001540:	// 4001540: <9430000e>	LHU       S0 = [AT+000e]
	state.r[S0] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000000E) & 0xfff);


_04001544:	// 4001544: <94310010>	LHU       S1 = [AT+0010]
	state.r[S1] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000010) & 0xfff);


_04001548:	// 4001548: <94320012>	LHU       S2 = [AT+0012]
	state.r[S2] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000012) & 0xfff);


_0400154C:	// 400154c: <94330014>	LHU       S3 = [AT+0014]
	state.r[S3] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000014) & 0xfff);


_04001550:	// 4001550: <94340016>	LHU       S4 = [AT+0016]
	state.r[S4] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000016) & 0xfff);


_04001554:	// 4001554: <94350018>	LHU       S5 = [AT+0018]
	state.r[S5] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000018) & 0xfff);


_04001558:	// 4001558: <9436001a>	LHU       S6 = [AT+001a]
	state.r[S6] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000001A) & 0xfff);


_0400155C:	// 400155c: <9437001c>	LHU       S7 = [AT+001c]
	state.r[S7] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000001C) & 0xfff);


_04001560:	// 4001560: <9438001e>	LHU       T8 = [AT+001e]
	state.r[T8] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000001E) & 0xfff);


_04001564:	// 4001564: <34190480>	ORI       T9 = R0 | 0x0480
	state.r[T9] = (0 | 0x00000480);


_04001568:	// 4001568: <341a0300>	ORI       K0 = R0 | 0x0300
	state.r[K0] = (0 | 0x00000300);


_0400156C:	// 400156c: <341b0bd0>	ORI       K1 = R0 | 0x0bd0
	state.r[K1] = (0 | 0x00000BD0);


_04001570:	// 4001570: <341c0d60>	ORI       GP = R0 | 0x0d60
	state.r[GP] = (0 | 0x00000D60);


_04001574:	// 4001574: <275d0180>	ADDIU     SP = K0 + 0180
	state.r[SP] = state.r[K0] + 0x0180;


_04001578:	// 4001578: <8c450000>	LW        A1 = [V0+0000]
	state.r[A1] = (_s32)Load32_DMEM((state.r[V0] + 0x00000000) & 0xfff);


_0400157C:	// 400157c: <0d0005f2>	JAL	    040017c8
	state.r[A2] = (_s32)Load32_DMEM((state.r[V0] + 0x00000010) & 0xfff);
	sp_reg_pc = 0x0400157C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040017C8;


_04001580:	// 4001580: <8c460010>	LW        A2 = [V0+0010]
	state.r[A2] = (_s32)Load32_DMEM((state.r[V0] + 0x00000010) & 0xfff);


_04001584:	// 4001584: <4a001b90>	VADD      vec14 = vec03 + vec00[<none>]
	{
		_u16		flag0 = state.flag[0];
		VADD_operation(0, state.v[14].U16[0], state.v[3].U16[0], state.v[0].U16[0], 1, 0, 0, 1)
		VADD_operation(1, state.v[14].U16[1], state.v[3].U16[1], state.v[0].U16[1], 1, 0, 0, 1)
		VADD_operation(2, state.v[14].U16[2], state.v[3].U16[2], state.v[0].U16[2], 1, 0, 0, 1)
		VADD_operation(3, state.v[14].U16[3], state.v[3].U16[3], state.v[0].U16[3], 1, 0, 0, 1)
		VADD_operation(4, state.v[14].U16[4], state.v[3].U16[4], state.v[0].U16[4], 1, 0, 0, 1)
		VADD_operation(5, state.v[14].U16[5], state.v[3].U16[5], state.v[0].U16[5], 1, 0, 0, 1)
		VADD_operation(6, state.v[14].U16[6], state.v[3].U16[6], state.v[0].U16[6], 1, 0, 0, 1)
		VADD_operation(7, state.v[14].U16[7], state.v[3].U16[7], state.v[0].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001588:	// 4001588: <4a002310>	VADD      vec12 = vec04 + vec00[<none>]
	{
		_u16		flag0 = state.flag[0];
		VADD_operation(0, state.v[12].U16[0], state.v[4].U16[0], state.v[0].U16[0], 1, 0, 0, 1)
		VADD_operation(1, state.v[12].U16[1], state.v[4].U16[1], state.v[0].U16[1], 1, 0, 0, 1)
		VADD_operation(2, state.v[12].U16[2], state.v[4].U16[2], state.v[0].U16[2], 1, 0, 0, 1)
		VADD_operation(3, state.v[12].U16[3], state.v[4].U16[3], state.v[0].U16[3], 1, 0, 0, 1)
		VADD_operation(4, state.v[12].U16[4], state.v[4].U16[4], state.v[0].U16[4], 1, 0, 0, 1)
		VADD_operation(5, state.v[12].U16[5], state.v[4].U16[5], state.v[0].U16[5], 1, 0, 0, 1)
		VADD_operation(6, state.v[12].U16[6], state.v[4].U16[6], state.v[0].U16[6], 1, 0, 0, 1)
		VADD_operation(7, state.v[12].U16[7], state.v[4].U16[7], state.v[0].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_0400158C:	// 400158c: <000630c0>	SLL       A2 = A2 << 3
	state.r[A2] = ((_u32)state.r[A2] << 3);


_04001590:	// 4001590: <4886a800>	MTC2      vec21 <00> = A2
	state.v[21].U16[7] = (_u16)state.r[A2];


_04001594:	// 4001594: <00063403>	SRA       A2 = A2 >> 16
	state.r[A2] = ((_s32)state.r[A2] >> 16);


_04001598:	// 4001598: <4886a000>	MTC2      vec20 <00> = A2
	state.v[20].U16[7] = (_u16)state.r[A2];


_0400159C:	// 400159c: <8c450004>	LW        A1 = [V0+0004]
	state.r[A1] = (_s32)Load32_DMEM((state.r[V0] + 0x00000004) & 0xfff);


_040015A0:	// 40015a0: <0d0005f2>	JAL	    040017c8
	state.r[A2] = (_s32)Load32_DMEM((state.r[V0] + 0x00000014) & 0xfff);
	sp_reg_pc = 0x040015A0;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040017C8;


_040015A4:	// 40015a4: <8c460014>	LW        A2 = [V0+0014]
	state.r[A2] = (_s32)Load32_DMEM((state.r[V0] + 0x00000014) & 0xfff);


_040015A8:	// 40015a8: <4a001bd0>	VADD      vec15 = vec03 + vec00[<none>]
	{
		_u16		flag0 = state.flag[0];
		VADD_operation(0, state.v[15].U16[0], state.v[3].U16[0], state.v[0].U16[0], 1, 0, 0, 1)
		VADD_operation(1, state.v[15].U16[1], state.v[3].U16[1], state.v[0].U16[1], 1, 0, 0, 1)
		VADD_operation(2, state.v[15].U16[2], state.v[3].U16[2], state.v[0].U16[2], 1, 0, 0, 1)
		VADD_operation(3, state.v[15].U16[3], state.v[3].U16[3], state.v[0].U16[3], 1, 0, 0, 1)
		VADD_operation(4, state.v[15].U16[4], state.v[3].U16[4], state.v[0].U16[4], 1, 0, 0, 1)
		VADD_operation(5, state.v[15].U16[5], state.v[3].U16[5], state.v[0].U16[5], 1, 0, 0, 1)
		VADD_operation(6, state.v[15].U16[6], state.v[3].U16[6], state.v[0].U16[6], 1, 0, 0, 1)
		VADD_operation(7, state.v[15].U16[7], state.v[3].U16[7], state.v[0].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040015AC:	// 40015ac: <4a002350>	VADD      vec13 = vec04 + vec00[<none>]
	{
		_u16		flag0 = state.flag[0];
		VADD_operation(0, state.v[13].U16[0], state.v[4].U16[0], state.v[0].U16[0], 1, 0, 0, 1)
		VADD_operation(1, state.v[13].U16[1], state.v[4].U16[1], state.v[0].U16[1], 1, 0, 0, 1)
		VADD_operation(2, state.v[13].U16[2], state.v[4].U16[2], state.v[0].U16[2], 1, 0, 0, 1)
		VADD_operation(3, state.v[13].U16[3], state.v[4].U16[3], state.v[0].U16[3], 1, 0, 0, 1)
		VADD_operation(4, state.v[13].U16[4], state.v[4].U16[4], state.v[0].U16[4], 1, 0, 0, 1)
		VADD_operation(5, state.v[13].U16[5], state.v[4].U16[5], state.v[0].U16[5], 1, 0, 0, 1)
		VADD_operation(6, state.v[13].U16[6], state.v[4].U16[6], state.v[0].U16[6], 1, 0, 0, 1)
		VADD_operation(7, state.v[13].U16[7], state.v[4].U16[7], state.v[0].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040015B0:	// 40015b0: <000630c0>	SLL       A2 = A2 << 3
	state.r[A2] = ((_u32)state.r[A2] << 3);


_040015B4:	// 40015b4: <4886a900>	MTC2      vec21 <02> = A2
	state.v[21].U16[6] = (_u16)state.r[A2];


_040015B8:	// 40015b8: <00063403>	SRA       A2 = A2 >> 16
	state.r[A2] = ((_s32)state.r[A2] >> 16);


_040015BC:	// 40015bc: <4886a100>	MTC2      vec20 <02> = A2
	state.v[20].U16[6] = (_u16)state.r[A2];


_040015C0:	// 40015c0: <8c450008>	LW        A1 = [V0+0008]
	state.r[A1] = (_s32)Load32_DMEM((state.r[V0] + 0x00000008) & 0xfff);


_040015C4:	// 40015c4: <0d0005f2>	JAL	    040017c8
	state.r[A2] = (_s32)Load32_DMEM((state.r[V0] + 0x00000018) & 0xfff);
	sp_reg_pc = 0x040015C4;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040017C8;


_040015C8:	// 40015c8: <8c460018>	LW        A2 = [V0+0018]
	state.r[A2] = (_s32)Load32_DMEM((state.r[V0] + 0x00000018) & 0xfff);


_040015CC:	// 40015cc: <4a001c50>	VADD      vec17 = vec03 + vec00[<none>]
	{
		_u16		flag0 = state.flag[0];
		VADD_operation(0, state.v[17].U16[0], state.v[3].U16[0], state.v[0].U16[0], 1, 0, 0, 1)
		VADD_operation(1, state.v[17].U16[1], state.v[3].U16[1], state.v[0].U16[1], 1, 0, 0, 1)
		VADD_operation(2, state.v[17].U16[2], state.v[3].U16[2], state.v[0].U16[2], 1, 0, 0, 1)
		VADD_operation(3, state.v[17].U16[3], state.v[3].U16[3], state.v[0].U16[3], 1, 0, 0, 1)
		VADD_operation(4, state.v[17].U16[4], state.v[3].U16[4], state.v[0].U16[4], 1, 0, 0, 1)
		VADD_operation(5, state.v[17].U16[5], state.v[3].U16[5], state.v[0].U16[5], 1, 0, 0, 1)
		VADD_operation(6, state.v[17].U16[6], state.v[3].U16[6], state.v[0].U16[6], 1, 0, 0, 1)
		VADD_operation(7, state.v[17].U16[7], state.v[3].U16[7], state.v[0].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040015D0:	// 40015d0: <4a002410>	VADD      vec16 = vec04 + vec00[<none>]
	{
		_u16		flag0 = state.flag[0];
		VADD_operation(0, state.v[16].U16[0], state.v[4].U16[0], state.v[0].U16[0], 1, 0, 0, 1)
		VADD_operation(1, state.v[16].U16[1], state.v[4].U16[1], state.v[0].U16[1], 1, 0, 0, 1)
		VADD_operation(2, state.v[16].U16[2], state.v[4].U16[2], state.v[0].U16[2], 1, 0, 0, 1)
		VADD_operation(3, state.v[16].U16[3], state.v[4].U16[3], state.v[0].U16[3], 1, 0, 0, 1)
		VADD_operation(4, state.v[16].U16[4], state.v[4].U16[4], state.v[0].U16[4], 1, 0, 0, 1)
		VADD_operation(5, state.v[16].U16[5], state.v[4].U16[5], state.v[0].U16[5], 1, 0, 0, 1)
		VADD_operation(6, state.v[16].U16[6], state.v[4].U16[6], state.v[0].U16[6], 1, 0, 0, 1)
		VADD_operation(7, state.v[16].U16[7], state.v[4].U16[7], state.v[0].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040015D4:	// 40015d4: <000630c0>	SLL       A2 = A2 << 3
	state.r[A2] = ((_u32)state.r[A2] << 3);


_040015D8:	// 40015d8: <4886aa00>	MTC2      vec21 <04> = A2
	state.v[21].U16[5] = (_u16)state.r[A2];


_040015DC:	// 40015dc: <00063403>	SRA       A2 = A2 >> 16
	state.r[A2] = ((_s32)state.r[A2] >> 16);


_040015E0:	// 40015e0: <4886a200>	MTC2      vec20 <04> = A2
	state.v[20].U16[5] = (_u16)state.r[A2];


_040015E4:	// 40015e4: <8c45000c>	LW        A1 = [V0+000c]
	state.r[A1] = (_s32)Load32_DMEM((state.r[V0] + 0x0000000C) & 0xfff);


_040015E8:	// 40015e8: <0d0005f2>	JAL	    040017c8
	state.r[A2] = (_s32)Load32_DMEM((state.r[V0] + 0x0000001C) & 0xfff);
	sp_reg_pc = 0x040015E8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040017C8;


_040015EC:	// 40015ec: <8c46001c>	LW        A2 = [V0+001c]
	state.r[A2] = (_s32)Load32_DMEM((state.r[V0] + 0x0000001C) & 0xfff);


_040015F0:	// 40015f0: <4a001cd0>	VADD      vec19 = vec03 + vec00[<none>]
	{
		_u16		flag0 = state.flag[0];
		VADD_operation(0, state.v[19].U16[0], state.v[3].U16[0], state.v[0].U16[0], 1, 0, 0, 1)
		VADD_operation(1, state.v[19].U16[1], state.v[3].U16[1], state.v[0].U16[1], 1, 0, 0, 1)
		VADD_operation(2, state.v[19].U16[2], state.v[3].U16[2], state.v[0].U16[2], 1, 0, 0, 1)
		VADD_operation(3, state.v[19].U16[3], state.v[3].U16[3], state.v[0].U16[3], 1, 0, 0, 1)
		VADD_operation(4, state.v[19].U16[4], state.v[3].U16[4], state.v[0].U16[4], 1, 0, 0, 1)
		VADD_operation(5, state.v[19].U16[5], state.v[3].U16[5], state.v[0].U16[5], 1, 0, 0, 1)
		VADD_operation(6, state.v[19].U16[6], state.v[3].U16[6], state.v[0].U16[6], 1, 0, 0, 1)
		VADD_operation(7, state.v[19].U16[7], state.v[3].U16[7], state.v[0].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040015F4:	// 40015f4: <4a002490>	VADD      vec18 = vec04 + vec00[<none>]
	{
		_u16		flag0 = state.flag[0];
		VADD_operation(0, state.v[18].U16[0], state.v[4].U16[0], state.v[0].U16[0], 1, 0, 0, 1)
		VADD_operation(1, state.v[18].U16[1], state.v[4].U16[1], state.v[0].U16[1], 1, 0, 0, 1)
		VADD_operation(2, state.v[18].U16[2], state.v[4].U16[2], state.v[0].U16[2], 1, 0, 0, 1)
		VADD_operation(3, state.v[18].U16[3], state.v[4].U16[3], state.v[0].U16[3], 1, 0, 0, 1)
		VADD_operation(4, state.v[18].U16[4], state.v[4].U16[4], state.v[0].U16[4], 1, 0, 0, 1)
		VADD_operation(5, state.v[18].U16[5], state.v[4].U16[5], state.v[0].U16[5], 1, 0, 0, 1)
		VADD_operation(6, state.v[18].U16[6], state.v[4].U16[6], state.v[0].U16[6], 1, 0, 0, 1)
		VADD_operation(7, state.v[18].U16[7], state.v[4].U16[7], state.v[0].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040015F8:	// 40015f8: <000630c0>	SLL       A2 = A2 << 3
	state.r[A2] = ((_u32)state.r[A2] << 3);


_040015FC:	// 40015fc: <4886ab00>	MTC2      vec21 <06> = A2
	state.v[21].U16[4] = (_u16)state.r[A2];


_04001600:	// 4001600: <00063403>	SRA       A2 = A2 >> 16
	state.r[A2] = ((_s32)state.r[A2] >> 16);


_04001604:	// 4001604: <4886a300>	MTC2      vec20 <06> = A2
	state.v[20].U16[4] = (_u16)state.r[A2];


_04001608:	// 4001608: <4b271094>	VADDC	vec02 = vec02 + vec07[1]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[7].U16[6];
		VADDC_operation(0, state.v[2].U16[0], state.v[2].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[2].U16[1], state.v[2].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[2].U16[2], state.v[2].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[2].U16[3], state.v[2].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[2].U16[4], state.v[2].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[2].U16[5], state.v[2].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[2].U16[6], state.v[2].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[2].U16[7], state.v[2].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_0400160C:	// 400160c: <c9231800>	LDV       vec03 <00> = [T1 + 0x00]
	rsp_ldv_compiler((state.r[T1] & 0xFFF), 3, 8);


_04001610:	// 4001610: <4b070850>	VADD      vec01 = vec01 + vec07[0]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[7].U16[7];
		VADD_operation(0, state.v[1].U16[0], state.v[1].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[1].U16[1], state.v[1].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[1].U16[2], state.v[1].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[1].U16[3], state.v[1].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[1].U16[4], state.v[1].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[1].U16[5], state.v[1].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[1].U16[6], state.v[1].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[1].U16[7], state.v[1].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001614:	// 4001614: <c9a31c00>	LDV       vec03 <08> = [T5 + 0x00]
	rsp_ldv_compiler((state.r[T5] & 0xFFF), 3, 0);


_04001618:	// 4001618: <4b3f0ed1>	VSUB      vec27 = vec01 - vec31[1]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[31].U16[6];
		VSUB_operation(0, state.v[27].U16[0], state.v[1].U16[0], s2value, 1, 0, 0, 1)
		VSUB_operation(1, state.v[27].U16[1], state.v[1].U16[1], s2value, 1, 0, 0, 1)
		VSUB_operation(2, state.v[27].U16[2], state.v[1].U16[2], s2value, 1, 0, 0, 1)
		VSUB_operation(3, state.v[27].U16[3], state.v[1].U16[3], s2value, 1, 0, 0, 1)
		VSUB_operation(4, state.v[27].U16[4], state.v[1].U16[4], s2value, 1, 0, 0, 1)
		VSUB_operation(5, state.v[27].U16[5], state.v[1].U16[5], s2value, 1, 0, 0, 1)
		VSUB_operation(6, state.v[27].U16[6], state.v[1].U16[6], s2value, 1, 0, 0, 1)
		VSUB_operation(7, state.v[27].U16[7], state.v[1].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_0400161C:	// 400161c: <c9441800>	LDV       vec04 <00> = [T2 + 0x00]
	rsp_ldv_compiler((state.r[T2] & 0xFFF), 4, 8);


_04001620:	// 4001620: <c9c41c00>	LDV       vec04 <08> = [T6 + 0x00]
	rsp_ldv_compiler((state.r[T6] & 0xFFF), 4, 0);


_04001624:	// 4001624: <c9651800>	LDV       vec05 <00> = [T3 + 0x00]
	rsp_ldv_compiler((state.r[T3] & 0xFFF), 5, 8);


_04001628:	// 4001628: <c9e51c00>	LDV       vec05 <08> = [T7 + 0x00]
	rsp_ldv_compiler((state.r[T7] & 0xFFF), 5, 0);


_0400162C:	// 400162c: <4b5fded0>	VADD      vec27 = vec27 + vec31[2]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[31].U16[5];
		VADD_operation(0, state.v[27].U16[0], state.v[27].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[27].U16[1], state.v[27].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[27].U16[2], state.v[27].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[27].U16[3], state.v[27].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[27].U16[4], state.v[27].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[27].U16[5], state.v[27].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[27].U16[6], state.v[27].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[27].U16[7], state.v[27].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001630:	// 4001630: <c9861800>	LDV       vec06 <00> = [T4 + 0x00]
	rsp_ldv_compiler((state.r[T4] & 0xFFF), 6, 8);


_04001634:	// 4001634: <ca061c00>	LDV       vec06 <08> = [S0 + 0x00]
	rsp_ldv_compiler((state.r[S0] & 0xFFF), 6, 0);


_04001638:	// 4001638: <ca391800>	LDV       vec25 <00> = [S1 + 0x00]
	rsp_ldv_compiler((state.r[S1] & 0xFFF), 25, 8);


_0400163C:	// 400163c: <4b3f0860>	VLT ?-?
	rsp_cop2_vlt_element(&state.v[1], &state.v[1], &state.v[31].U16[6]);


_04001640:	// 4001640: <cab91c00>	LDV       vec25 <08> = [S5 + 0x00]
	rsp_ldv_compiler((state.r[S5] & 0xFFF), 25, 0);


_04001644:	// 4001644: <4a1b0867>	VMRG ?-?
	rsp_cop2_vmrg(&state.v[1], &state.v[1], &state.v[27]);


_04001648:	// 4001648: <ca581800>	LDV       vec24 <00> = [S2 + 0x00]
	rsp_ldv_compiler((state.r[S2] & 0xFFF), 24, 8);


_0400164C:	// 400164c: <cad81c00>	LDV       vec24 <08> = [S6 + 0x00]
	rsp_ldv_compiler((state.r[S6] & 0xFFF), 24, 0);


_04001650:	// 4001650: <ca7d1800>	LDV       vec29 <00> = [S3 + 0x00]
	rsp_ldv_compiler((state.r[S3] & 0xFFF), 29, 8);


_04001654:	// 4001654: <cafd1c00>	LDV       vec29 <08> = [S7 + 0x00]
	rsp_ldv_compiler((state.r[S7] & 0xFFF), 29, 0);


_04001658:	// 4001658: <4b7f0ec6>	VMUDN     vec27 = ( acc = vec01 * vec31[3]      ) >> 16
	{
		_u16		s2value = state.v[31].U16[4];
		VMUDN_operation(0, state.v[27].U16[0], state.v[1].U16[0], s2value, 1, 0, 0, 1)
		VMUDN_operation(1, state.v[27].U16[1], state.v[1].U16[1], s2value, 1, 0, 0, 1)
		VMUDN_operation(2, state.v[27].U16[2], state.v[1].U16[2], s2value, 1, 0, 0, 1)
		VMUDN_operation(3, state.v[27].U16[3], state.v[1].U16[3], s2value, 1, 0, 0, 1)
		VMUDN_operation(4, state.v[27].U16[4], state.v[1].U16[4], s2value, 1, 0, 0, 1)
		VMUDN_operation(5, state.v[27].U16[5], state.v[1].U16[5], s2value, 1, 0, 0, 1)
		VMUDN_operation(6, state.v[27].U16[6], state.v[1].U16[6], s2value, 1, 0, 0, 1)
		VMUDN_operation(7, state.v[27].U16[7], state.v[1].U16[7], s2value, 1, 0, 0, 1)
	}


_0400165C:	// 400165c: <ca9e1800>	LDV       vec30 <00> = [S4 + 0x00]
	rsp_ldv_compiler((state.r[S4] & 0xFFF), 30, 8);


_04001660:	// 4001660: <4bbf1684>	VMUDL     vec26 = ( acc = (vec02 * vec31[5] >> 16)      )
	{
		_u16		s2value = state.v[31].U16[2];
		VMUDL_operation(0, state.v[26].U16[0], state.v[2].U16[0], s2value, 1, 0, 0, 1)
		VMUDL_operation(1, state.v[26].U16[1], state.v[2].U16[1], s2value, 1, 0, 0, 1)
		VMUDL_operation(2, state.v[26].U16[2], state.v[2].U16[2], s2value, 1, 0, 0, 1)
		VMUDL_operation(3, state.v[26].U16[3], state.v[2].U16[3], s2value, 1, 0, 0, 1)
		VMUDL_operation(4, state.v[26].U16[4], state.v[2].U16[4], s2value, 1, 0, 0, 1)
		VMUDL_operation(5, state.v[26].U16[5], state.v[2].U16[5], s2value, 1, 0, 0, 1)
		VMUDL_operation(6, state.v[26].U16[6], state.v[2].U16[6], s2value, 1, 0, 0, 1)
		VMUDL_operation(7, state.v[26].U16[7], state.v[2].U16[7], s2value, 1, 0, 0, 1)
	}


_04001664:	// 4001664: <cb1e1c00>	LDV       vec30 <08> = [T8 + 0x00]
	rsp_ldv_compiler((state.r[T8] & 0xFFF), 30, 0);


_04001668:	// 4001668: <4b9fd686>	VMUDN     vec26 = ( acc = vec26 * vec31[4]      ) >> 16
	{
		_u16		s2value = state.v[31].U16[3];
		VMUDN_operation(0, state.v[26].U16[0], state.v[26].U16[0], s2value, 0, 1, 1, 1)
		VMUDN_operation(1, state.v[26].U16[1], state.v[26].U16[1], s2value, 0, 1, 1, 1)
		VMUDN_operation(2, state.v[26].U16[2], state.v[26].U16[2], s2value, 0, 1, 1, 1)
		VMUDN_operation(3, state.v[26].U16[3], state.v[26].U16[3], s2value, 0, 1, 1, 1)
		VMUDN_operation(4, state.v[26].U16[4], state.v[26].U16[4], s2value, 0, 1, 1, 1)
		VMUDN_operation(5, state.v[26].U16[5], state.v[26].U16[5], s2value, 0, 1, 1, 1)
		VMUDN_operation(6, state.v[26].U16[6], state.v[26].U16[6], s2value, 0, 1, 1, 1)
		VMUDN_operation(7, state.v[26].U16[7], state.v[26].U16[7], s2value, 0, 1, 1, 1)
	}


_0400166C:	// 400166c: <4b1fe68e>	VMADN     vec26 = ( acc+= vec28 * vec31[0] )
	{
		_u16		s2value = state.v[31].U16[7];
		VMADN_operation(0, state.v[26].U16[0], state.v[28].U16[0], s2value, 1, 0, 0, 1)
		VMADN_operation(1, state.v[26].U16[1], state.v[28].U16[1], s2value, 1, 0, 0, 1)
		VMADN_operation(2, state.v[26].U16[2], state.v[28].U16[2], s2value, 1, 0, 0, 1)
		VMADN_operation(3, state.v[26].U16[3], state.v[28].U16[3], s2value, 1, 0, 0, 1)
		VMADN_operation(4, state.v[26].U16[4], state.v[28].U16[4], s2value, 1, 0, 0, 1)
		VMADN_operation(5, state.v[26].U16[5], state.v[28].U16[5], s2value, 1, 0, 0, 1)
		VMADN_operation(6, state.v[26].U16[6], state.v[28].U16[6], s2value, 1, 0, 0, 1)
		VMADN_operation(7, state.v[26].U16[7], state.v[28].U16[7], s2value, 1, 0, 0, 1)
	}


_04001670:	// 4001670: <e83b2000>	SQV       [AT + 0x00] = vec27 <00>
	{
		_u32    addr = (0x00000000 + state.r[AT]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[27].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[27].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[27].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[27].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[27].U64[0] & temp1);
			value2 |= (state.v[27].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001674:	// 4001674: <e83a2001>	SQV       [AT + 0x10] = vec26 <00>
	{
		_u32    addr = (0x00000010 + state.r[AT]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[26].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[26].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[26].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[26].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[26].U64[0] & temp1);
			value2 |= (state.v[26].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001678:	// 4001678: <4a1918c0>	VMULF     vec03 = ( acc = (vec03 * vec25[<none>]) << 1 ) >> 16
	{
		VMULF_operation(0, state.v[3].U16[0], state.v[3].U16[0], state.v[25].U16[0], 1, 0, 0, 1)
		VMULF_operation(1, state.v[3].U16[1], state.v[3].U16[1], state.v[25].U16[1], 1, 0, 0, 1)
		VMULF_operation(2, state.v[3].U16[2], state.v[3].U16[2], state.v[25].U16[2], 1, 0, 0, 1)
		VMULF_operation(3, state.v[3].U16[3], state.v[3].U16[3], state.v[25].U16[3], 1, 0, 0, 1)
		VMULF_operation(4, state.v[3].U16[4], state.v[3].U16[4], state.v[25].U16[4], 1, 0, 0, 1)
		VMULF_operation(5, state.v[3].U16[5], state.v[3].U16[5], state.v[25].U16[5], 1, 0, 0, 1)
		VMULF_operation(6, state.v[3].U16[6], state.v[3].U16[6], state.v[25].U16[6], 1, 0, 0, 1)
		VMULF_operation(7, state.v[3].U16[7], state.v[3].U16[7], state.v[25].U16[7], 1, 0, 0, 1)
	}


_0400167C:	// 400167c: <94290000>	LHU       T1 = [AT+0000]
	state.r[T1] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000000) & 0xfff);


_04001680:	// 4001680: <4a182100>	VMULF     vec04 = ( acc = (vec04 * vec24[<none>]) << 1 ) >> 16
	{
		VMULF_operation(0, state.v[4].U16[0], state.v[4].U16[0], state.v[24].U16[0], 1, 0, 0, 1)
		VMULF_operation(1, state.v[4].U16[1], state.v[4].U16[1], state.v[24].U16[1], 1, 0, 0, 1)
		VMULF_operation(2, state.v[4].U16[2], state.v[4].U16[2], state.v[24].U16[2], 1, 0, 0, 1)
		VMULF_operation(3, state.v[4].U16[3], state.v[4].U16[3], state.v[24].U16[3], 1, 0, 0, 1)
		VMULF_operation(4, state.v[4].U16[4], state.v[4].U16[4], state.v[24].U16[4], 1, 0, 0, 1)
		VMULF_operation(5, state.v[4].U16[5], state.v[4].U16[5], state.v[24].U16[5], 1, 0, 0, 1)
		VMULF_operation(6, state.v[4].U16[6], state.v[4].U16[6], state.v[24].U16[6], 1, 0, 0, 1)
		VMULF_operation(7, state.v[4].U16[7], state.v[4].U16[7], state.v[24].U16[7], 1, 0, 0, 1)
	}


_04001684:	// 4001684: <942a0002>	LHU       T2 = [AT+0002]
	state.r[T2] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000002) & 0xfff);


_04001688:	// 4001688: <4a1d2940>	VMULF     vec05 = ( acc = (vec05 * vec29[<none>]) << 1 ) >> 16
	{
		VMULF_operation(0, state.v[5].U16[0], state.v[5].U16[0], state.v[29].U16[0], 1, 0, 0, 1)
		VMULF_operation(1, state.v[5].U16[1], state.v[5].U16[1], state.v[29].U16[1], 1, 0, 0, 1)
		VMULF_operation(2, state.v[5].U16[2], state.v[5].U16[2], state.v[29].U16[2], 1, 0, 0, 1)
		VMULF_operation(3, state.v[5].U16[3], state.v[5].U16[3], state.v[29].U16[3], 1, 0, 0, 1)
		VMULF_operation(4, state.v[5].U16[4], state.v[5].U16[4], state.v[29].U16[4], 1, 0, 0, 1)
		VMULF_operation(5, state.v[5].U16[5], state.v[5].U16[5], state.v[29].U16[5], 1, 0, 0, 1)
		VMULF_operation(6, state.v[5].U16[6], state.v[5].U16[6], state.v[29].U16[6], 1, 0, 0, 1)
		VMULF_operation(7, state.v[5].U16[7], state.v[5].U16[7], state.v[29].U16[7], 1, 0, 0, 1)
	}


_0400168C:	// 400168c: <942b0004>	LHU       T3 = [AT+0004]
	state.r[T3] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000004) & 0xfff);


_04001690:	// 4001690: <4a1e3180>	VMULF     vec06 = ( acc = (vec06 * vec30[<none>]) << 1 ) >> 16
	{
		VMULF_operation(0, state.v[6].U16[0], state.v[6].U16[0], state.v[30].U16[0], 1, 0, 0, 1)
		VMULF_operation(1, state.v[6].U16[1], state.v[6].U16[1], state.v[30].U16[1], 1, 0, 0, 1)
		VMULF_operation(2, state.v[6].U16[2], state.v[6].U16[2], state.v[30].U16[2], 1, 0, 0, 1)
		VMULF_operation(3, state.v[6].U16[3], state.v[6].U16[3], state.v[30].U16[3], 1, 0, 0, 1)
		VMULF_operation(4, state.v[6].U16[4], state.v[6].U16[4], state.v[30].U16[4], 1, 0, 0, 1)
		VMULF_operation(5, state.v[6].U16[5], state.v[6].U16[5], state.v[30].U16[5], 1, 0, 0, 1)
		VMULF_operation(6, state.v[6].U16[6], state.v[6].U16[6], state.v[30].U16[6], 1, 0, 0, 1)
		VMULF_operation(7, state.v[6].U16[7], state.v[6].U16[7], state.v[30].U16[7], 1, 0, 0, 1)
	}


_04001694:	// 4001694: <942c0006>	LHU       T4 = [AT+0006]
	state.r[T4] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000006) & 0xfff);


_04001698:	// 4001698: <4a6318d0>	VADD      vec03 = vec03 + vec03[1q]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[3].U16[0];
		VADD_operation(0, state.v[3].U16[0], state.v[3].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[3].U16[1], state.v[3].U16[1], s2value, 1, 0, 0, 1)
		s2value = state.v[3].U16[2];
		VADD_operation(2, state.v[3].U16[2], state.v[3].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[3].U16[3], state.v[3].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[3].U16[4];
		VADD_operation(4, state.v[3].U16[4], state.v[3].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[3].U16[5], state.v[3].U16[5], s2value, 1, 0, 0, 1)
		s2value = state.v[3].U16[6];
		VADD_operation(6, state.v[3].U16[6], state.v[3].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[3].U16[7], state.v[3].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_0400169C:	// 400169c: <942d0008>	LHU       T5 = [AT+0008]
	state.r[T5] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000008) & 0xfff);


_040016A0:	// 40016a0: <4a642110>	VADD      vec04 = vec04 + vec04[1q]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[4].U16[0];
		VADD_operation(0, state.v[4].U16[0], state.v[4].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[4].U16[1], state.v[4].U16[1], s2value, 1, 0, 0, 1)
		s2value = state.v[4].U16[2];
		VADD_operation(2, state.v[4].U16[2], state.v[4].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[4].U16[3], state.v[4].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[4].U16[4];
		VADD_operation(4, state.v[4].U16[4], state.v[4].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[4].U16[5], state.v[4].U16[5], s2value, 1, 0, 0, 1)
		s2value = state.v[4].U16[6];
		VADD_operation(6, state.v[4].U16[6], state.v[4].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[4].U16[7], state.v[4].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040016A4:	// 40016a4: <942e000a>	LHU       T6 = [AT+000a]
	state.r[T6] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000000A) & 0xfff);


_040016A8:	// 40016a8: <4a652950>	VADD      vec05 = vec05 + vec05[1q]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[5].U16[0];
		VADD_operation(0, state.v[5].U16[0], state.v[5].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[5].U16[1], state.v[5].U16[1], s2value, 1, 0, 0, 1)
		s2value = state.v[5].U16[2];
		VADD_operation(2, state.v[5].U16[2], state.v[5].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[5].U16[3], state.v[5].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[5].U16[4];
		VADD_operation(4, state.v[5].U16[4], state.v[5].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[5].U16[5], state.v[5].U16[5], s2value, 1, 0, 0, 1)
		s2value = state.v[5].U16[6];
		VADD_operation(6, state.v[5].U16[6], state.v[5].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[5].U16[7], state.v[5].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040016AC:	// 40016ac: <942f000c>	LHU       T7 = [AT+000c]
	state.r[T7] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000000C) & 0xfff);


_040016B0:	// 40016b0: <4a663190>	VADD      vec06 = vec06 + vec06[1q]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[6].U16[0];
		VADD_operation(0, state.v[6].U16[0], state.v[6].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[6].U16[1], state.v[6].U16[1], s2value, 1, 0, 0, 1)
		s2value = state.v[6].U16[2];
		VADD_operation(2, state.v[6].U16[2], state.v[6].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[6].U16[3], state.v[6].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[6].U16[4];
		VADD_operation(4, state.v[6].U16[4], state.v[6].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[6].U16[5], state.v[6].U16[5], s2value, 1, 0, 0, 1)
		s2value = state.v[6].U16[6];
		VADD_operation(6, state.v[6].U16[6], state.v[6].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[6].U16[7], state.v[6].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040016B4:	// 40016b4: <9430000e>	LHU       S0 = [AT+000e]
	state.r[S0] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000000E) & 0xfff);


_040016B8:	// 40016b8: <4ac318d0>	VADD      vec03 = vec03 + vec03[2h]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[3].U16[1];
		VADD_operation(0, state.v[3].U16[0], state.v[3].U16[0], s2value, 0, 0, 0, 1)
		VADD_operation(1, state.v[3].U16[1], state.v[3].U16[1], s2value, 0, 0, 0, 1)
		VADD_operation(2, state.v[3].U16[2], state.v[3].U16[2], s2value, 0, 0, 0, 1)
		VADD_operation(3, state.v[3].U16[3], state.v[3].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[3].U16[5];
		VADD_operation(4, state.v[3].U16[4], state.v[3].U16[4], s2value, 0, 0, 0, 1)
		VADD_operation(5, state.v[3].U16[5], state.v[3].U16[5], s2value, 0, 0, 0, 1)
		VADD_operation(6, state.v[3].U16[6], state.v[3].U16[6], s2value, 0, 0, 0, 1)
		VADD_operation(7, state.v[3].U16[7], state.v[3].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040016BC:	// 40016bc: <94310010>	LHU       S1 = [AT+0010]
	state.r[S1] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000010) & 0xfff);


_040016C0:	// 40016c0: <4ac42110>	VADD      vec04 = vec04 + vec04[2h]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[4].U16[1];
		VADD_operation(0, state.v[4].U16[0], state.v[4].U16[0], s2value, 0, 0, 0, 1)
		VADD_operation(1, state.v[4].U16[1], state.v[4].U16[1], s2value, 0, 0, 0, 1)
		VADD_operation(2, state.v[4].U16[2], state.v[4].U16[2], s2value, 0, 0, 0, 1)
		VADD_operation(3, state.v[4].U16[3], state.v[4].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[4].U16[5];
		VADD_operation(4, state.v[4].U16[4], state.v[4].U16[4], s2value, 0, 0, 0, 1)
		VADD_operation(5, state.v[4].U16[5], state.v[4].U16[5], s2value, 0, 0, 0, 1)
		VADD_operation(6, state.v[4].U16[6], state.v[4].U16[6], s2value, 0, 0, 0, 1)
		VADD_operation(7, state.v[4].U16[7], state.v[4].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040016C4:	// 40016c4: <94320012>	LHU       S2 = [AT+0012]
	state.r[S2] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000012) & 0xfff);


_040016C8:	// 40016c8: <4ac52950>	VADD      vec05 = vec05 + vec05[2h]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[5].U16[1];
		VADD_operation(0, state.v[5].U16[0], state.v[5].U16[0], s2value, 0, 0, 0, 1)
		VADD_operation(1, state.v[5].U16[1], state.v[5].U16[1], s2value, 0, 0, 0, 1)
		VADD_operation(2, state.v[5].U16[2], state.v[5].U16[2], s2value, 0, 0, 0, 1)
		VADD_operation(3, state.v[5].U16[3], state.v[5].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[5].U16[5];
		VADD_operation(4, state.v[5].U16[4], state.v[5].U16[4], s2value, 0, 0, 0, 1)
		VADD_operation(5, state.v[5].U16[5], state.v[5].U16[5], s2value, 0, 0, 0, 1)
		VADD_operation(6, state.v[5].U16[6], state.v[5].U16[6], s2value, 0, 0, 0, 1)
		VADD_operation(7, state.v[5].U16[7], state.v[5].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040016CC:	// 40016cc: <94330014>	LHU       S3 = [AT+0014]
	state.r[S3] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000014) & 0xfff);


_040016D0:	// 40016d0: <4ac63190>	VADD      vec06 = vec06 + vec06[2h]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[6].U16[1];
		VADD_operation(0, state.v[6].U16[0], state.v[6].U16[0], s2value, 0, 0, 0, 1)
		VADD_operation(1, state.v[6].U16[1], state.v[6].U16[1], s2value, 0, 0, 0, 1)
		VADD_operation(2, state.v[6].U16[2], state.v[6].U16[2], s2value, 0, 0, 0, 1)
		VADD_operation(3, state.v[6].U16[3], state.v[6].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[6].U16[5];
		VADD_operation(4, state.v[6].U16[4], state.v[6].U16[4], s2value, 0, 0, 0, 1)
		VADD_operation(5, state.v[6].U16[5], state.v[6].U16[5], s2value, 0, 0, 0, 1)
		VADD_operation(6, state.v[6].U16[6], state.v[6].U16[6], s2value, 0, 0, 0, 1)
		VADD_operation(7, state.v[6].U16[7], state.v[6].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040016D4:	// 40016d4: <94340016>	LHU       S4 = [AT+0016]
	state.r[S4] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000016) & 0xfff);


_040016D8:	// 40016d8: <4a8340c6>	VMUDN     vec03 = ( acc = vec08 * vec03[0h]      ) >> 16
	{
		_u16		s2value;
		s2value = state.v[3].U16[3];
		VMUDN_operation(0, state.v[3].U16[0], state.v[8].U16[0], s2value, 0, 1, 1, 1)
		VMUDN_operation(1, state.v[3].U16[1], state.v[8].U16[1], s2value, 0, 1, 1, 1)
		VMUDN_operation(2, state.v[3].U16[2], state.v[8].U16[2], s2value, 0, 1, 1, 1)
		VMUDN_operation(3, state.v[3].U16[3], state.v[8].U16[3], s2value, 0, 1, 1, 1)
		s2value = state.v[3].U16[7];
		VMUDN_operation(4, state.v[3].U16[4], state.v[8].U16[4], s2value, 0, 1, 1, 1)
		VMUDN_operation(5, state.v[3].U16[5], state.v[8].U16[5], s2value, 0, 1, 1, 1)
		VMUDN_operation(6, state.v[3].U16[6], state.v[8].U16[6], s2value, 0, 1, 1, 1)
		VMUDN_operation(7, state.v[3].U16[7], state.v[8].U16[7], s2value, 0, 1, 1, 1)
	}


_040016DC:	// 40016dc: <94350018>	LHU       S5 = [AT+0018]
	state.r[S5] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x00000018) & 0xfff);


_040016E0:	// 40016e0: <4a8448ce>	VMADN     vec03 = ( acc+= vec09 * vec04[0h] )
	{
		_u16		s2value;
		s2value = state.v[4].U16[3];
		VMADN_operation(0, state.v[3].U16[0], state.v[9].U16[0], s2value, 0, 1, 1, 1)
		VMADN_operation(1, state.v[3].U16[1], state.v[9].U16[1], s2value, 0, 1, 1, 1)
		VMADN_operation(2, state.v[3].U16[2], state.v[9].U16[2], s2value, 0, 1, 1, 1)
		VMADN_operation(3, state.v[3].U16[3], state.v[9].U16[3], s2value, 0, 1, 1, 1)
		s2value = state.v[4].U16[7];
		VMADN_operation(4, state.v[3].U16[4], state.v[9].U16[4], s2value, 0, 1, 1, 1)
		VMADN_operation(5, state.v[3].U16[5], state.v[9].U16[5], s2value, 0, 1, 1, 1)
		VMADN_operation(6, state.v[3].U16[6], state.v[9].U16[6], s2value, 0, 1, 1, 1)
		VMADN_operation(7, state.v[3].U16[7], state.v[9].U16[7], s2value, 0, 1, 1, 1)
	}


_040016E4:	// 40016e4: <9436001a>	LHU       S6 = [AT+001a]
	state.r[S6] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000001A) & 0xfff);


_040016E8:	// 40016e8: <4a8550ce>	VMADN     vec03 = ( acc+= vec10 * vec05[0h] )
	{
		_u16		s2value;
		s2value = state.v[5].U16[3];
		VMADN_operation(0, state.v[3].U16[0], state.v[10].U16[0], s2value, 0, 1, 1, 1)
		VMADN_operation(1, state.v[3].U16[1], state.v[10].U16[1], s2value, 0, 1, 1, 1)
		VMADN_operation(2, state.v[3].U16[2], state.v[10].U16[2], s2value, 0, 1, 1, 1)
		VMADN_operation(3, state.v[3].U16[3], state.v[10].U16[3], s2value, 0, 1, 1, 1)
		s2value = state.v[5].U16[7];
		VMADN_operation(4, state.v[3].U16[4], state.v[10].U16[4], s2value, 0, 1, 1, 1)
		VMADN_operation(5, state.v[3].U16[5], state.v[10].U16[5], s2value, 0, 1, 1, 1)
		VMADN_operation(6, state.v[3].U16[6], state.v[10].U16[6], s2value, 0, 1, 1, 1)
		VMADN_operation(7, state.v[3].U16[7], state.v[10].U16[7], s2value, 0, 1, 1, 1)
	}


_040016EC:	// 40016ec: <9437001c>	LHU       S7 = [AT+001c]
	state.r[S7] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000001C) & 0xfff);


_040016F0:	// 40016f0: <4a8658ce>	VMADN     vec03 = ( acc+= vec11 * vec06[0h] )
	{
		_u16		s2value;
		s2value = state.v[6].U16[3];
		VMADN_operation(0, state.v[3].U16[0], state.v[11].U16[0], s2value, 1, 0, 0, 1)
		VMADN_operation(1, state.v[3].U16[1], state.v[11].U16[1], s2value, 1, 0, 0, 1)
		VMADN_operation(2, state.v[3].U16[2], state.v[11].U16[2], s2value, 1, 0, 0, 1)
		VMADN_operation(3, state.v[3].U16[3], state.v[11].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[6].U16[7];
		VMADN_operation(4, state.v[3].U16[4], state.v[11].U16[4], s2value, 1, 0, 0, 1)
		VMADN_operation(5, state.v[3].U16[5], state.v[11].U16[5], s2value, 1, 0, 0, 1)
		VMADN_operation(6, state.v[3].U16[6], state.v[11].U16[6], s2value, 1, 0, 0, 1)
		VMADN_operation(7, state.v[3].U16[7], state.v[11].U16[7], s2value, 1, 0, 0, 1)
	}


_040016F4:	// 40016f4: <9438001e>	LHU       T8 = [AT+001e]
	state.r[T8] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000001E) & 0xfff);


_040016F8:	// 40016f8: <cb9a2000>	LQV       vec26 <00> = [GP + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[GP]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[26].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[26].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[26].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[26].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[26].U64[0] = state.v[26].U64[0] & ~temp1;
			state.v[26].U64[1] = state.v[26].U64[1] & ~temp2;
			state.v[26].U64[0] = state.v[26].U64[0] | value1;
			state.v[26].U64[1] = state.v[26].U64[1] | value2;
		}
	}


_040016FC:	// 40016fc: <cb7b2000>	LQV       vec27 <00> = [K1 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[K1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
			state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
			state.v[27].U64[0] = state.v[27].U64[0] | value1;
			state.v[27].U64[1] = state.v[27].U64[1] | value2;
		}
	}


_04001700:	// 4001700: <4a121980>	VMULF     vec06 = ( acc = (vec03 * vec18[<none>]) << 1 ) >> 16
	{
		VMULF_operation(0, state.v[6].U16[0], state.v[3].U16[0], state.v[18].U16[0], 1, 1, 0, 1)
		VMULF_operation(1, state.v[6].U16[1], state.v[3].U16[1], state.v[18].U16[1], 1, 1, 0, 1)
		VMULF_operation(2, state.v[6].U16[2], state.v[3].U16[2], state.v[18].U16[2], 1, 1, 0, 1)
		VMULF_operation(3, state.v[6].U16[3], state.v[3].U16[3], state.v[18].U16[3], 1, 1, 0, 1)
		VMULF_operation(4, state.v[6].U16[4], state.v[3].U16[4], state.v[18].U16[4], 1, 1, 0, 1)
		VMULF_operation(5, state.v[6].U16[5], state.v[3].U16[5], state.v[18].U16[5], 1, 1, 0, 1)
		VMULF_operation(6, state.v[6].U16[6], state.v[3].U16[6], state.v[18].U16[6], 1, 1, 0, 1)
		VMULF_operation(7, state.v[6].U16[7], state.v[3].U16[7], state.v[18].U16[7], 1, 1, 0, 1)
	}


_04001704:	// 4001704: <279c0010>	ADDIU     GP = GP + 0010
	state.r[GP] = state.r[GP] + 0x0010;


_04001708:	// 4001708: <4a1cd68f>	VMADH     vec26 = ( acc+= (vec26 * vec28[<none>]) << 16) >> 16
	{
		VMADH_operation(0, state.v[26].U16[0], state.v[26].U16[0], state.v[28].U16[0], 1, 0, 0, 1)
		VMADH_operation(1, state.v[26].U16[1], state.v[26].U16[1], state.v[28].U16[1], 1, 0, 0, 1)
		VMADH_operation(2, state.v[26].U16[2], state.v[26].U16[2], state.v[28].U16[2], 1, 0, 0, 1)
		VMADH_operation(3, state.v[26].U16[3], state.v[26].U16[3], state.v[28].U16[3], 1, 0, 0, 1)
		VMADH_operation(4, state.v[26].U16[4], state.v[26].U16[4], state.v[28].U16[4], 1, 0, 0, 1)
		VMADH_operation(5, state.v[26].U16[5], state.v[26].U16[5], state.v[28].U16[5], 1, 0, 0, 1)
		VMADH_operation(6, state.v[26].U16[6], state.v[26].U16[6], state.v[28].U16[6], 1, 0, 0, 1)
		VMADH_operation(7, state.v[26].U16[7], state.v[26].U16[7], state.v[28].U16[7], 1, 0, 0, 1)
	}


_0400170C:	// 400170c: <4a101940>	VMULF     vec05 = ( acc = (vec03 * vec16[<none>]) << 1 ) >> 16
	{
		VMULF_operation(0, state.v[5].U16[0], state.v[3].U16[0], state.v[16].U16[0], 1, 1, 0, 1)
		VMULF_operation(1, state.v[5].U16[1], state.v[3].U16[1], state.v[16].U16[1], 1, 1, 0, 1)
		VMULF_operation(2, state.v[5].U16[2], state.v[3].U16[2], state.v[16].U16[2], 1, 1, 0, 1)
		VMULF_operation(3, state.v[5].U16[3], state.v[3].U16[3], state.v[16].U16[3], 1, 1, 0, 1)
		VMULF_operation(4, state.v[5].U16[4], state.v[3].U16[4], state.v[16].U16[4], 1, 1, 0, 1)
		VMULF_operation(5, state.v[5].U16[5], state.v[3].U16[5], state.v[16].U16[5], 1, 1, 0, 1)
		VMULF_operation(6, state.v[5].U16[6], state.v[3].U16[6], state.v[16].U16[6], 1, 1, 0, 1)
		VMULF_operation(7, state.v[5].U16[7], state.v[3].U16[7], state.v[16].U16[7], 1, 1, 0, 1)
	}


_04001710:	// 4001710: <277b0010>	ADDIU     K1 = K1 + 0010
	state.r[K1] = state.r[K1] + 0x0010;


_04001714:	// 4001714: <4a1cdecf>	VMADH     vec27 = ( acc+= (vec27 * vec28[<none>]) << 16) >> 16
	{
		VMADH_operation(0, state.v[27].U16[0], state.v[27].U16[0], state.v[28].U16[0], 1, 0, 0, 1)
		VMADH_operation(1, state.v[27].U16[1], state.v[27].U16[1], state.v[28].U16[1], 1, 0, 0, 1)
		VMADH_operation(2, state.v[27].U16[2], state.v[27].U16[2], state.v[28].U16[2], 1, 0, 0, 1)
		VMADH_operation(3, state.v[27].U16[3], state.v[27].U16[3], state.v[28].U16[3], 1, 0, 0, 1)
		VMADH_operation(4, state.v[27].U16[4], state.v[27].U16[4], state.v[28].U16[4], 1, 0, 0, 1)
		VMADH_operation(5, state.v[27].U16[5], state.v[27].U16[5], state.v[28].U16[5], 1, 0, 0, 1)
		VMADH_operation(6, state.v[27].U16[6], state.v[27].U16[6], state.v[28].U16[6], 1, 0, 0, 1)
		VMADH_operation(7, state.v[27].U16[7], state.v[27].U16[7], state.v[28].U16[7], 1, 0, 0, 1)
	}


_04001718:	// 4001718: <cb392000>	LQV       vec25 <00> = [T9 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[T9]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[25].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[25].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[25].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[25].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[25].U64[0] = state.v[25].U64[0] & ~temp1;
			state.v[25].U64[1] = state.v[25].U64[1] & ~temp2;
			state.v[25].U64[0] = state.v[25].U64[0] | value1;
			state.v[25].U64[1] = state.v[25].U64[1] | value2;
		}
	}


_0400171C:	// 400171c: <cb582000>	LQV       vec24 <00> = [K0 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[K0]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[24].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[24].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[24].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[24].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[24].U64[0] = state.v[24].U64[0] & ~temp1;
			state.v[24].U64[1] = state.v[24].U64[1] & ~temp2;
			state.v[24].U64[0] = state.v[24].U64[0] | value1;
			state.v[24].U64[1] = state.v[24].U64[1] | value2;
		}
	}


_04001720:	// 4001720: <4a0d1900>	VMULF     vec04 = ( acc = (vec03 * vec13[<none>]) << 1 ) >> 16
	{
		VMULF_operation(0, state.v[4].U16[0], state.v[3].U16[0], state.v[13].U16[0], 1, 1, 0, 1)
		VMULF_operation(1, state.v[4].U16[1], state.v[3].U16[1], state.v[13].U16[1], 1, 1, 0, 1)
		VMULF_operation(2, state.v[4].U16[2], state.v[3].U16[2], state.v[13].U16[2], 1, 1, 0, 1)
		VMULF_operation(3, state.v[4].U16[3], state.v[3].U16[3], state.v[13].U16[3], 1, 1, 0, 1)
		VMULF_operation(4, state.v[4].U16[4], state.v[3].U16[4], state.v[13].U16[4], 1, 1, 0, 1)
		VMULF_operation(5, state.v[4].U16[5], state.v[3].U16[5], state.v[13].U16[5], 1, 1, 0, 1)
		VMULF_operation(6, state.v[4].U16[6], state.v[3].U16[6], state.v[13].U16[6], 1, 1, 0, 1)
		VMULF_operation(7, state.v[4].U16[7], state.v[3].U16[7], state.v[13].U16[7], 1, 1, 0, 1)
	}


_04001724:	// 4001724: <27390010>	ADDIU     T9 = T9 + 0010
	state.r[T9] = state.r[T9] + 0x0010;


_04001728:	// 4001728: <4a1cce4f>	VMADH     vec25 = ( acc+= (vec25 * vec28[<none>]) << 16) >> 16
	{
		VMADH_operation(0, state.v[25].U16[0], state.v[25].U16[0], state.v[28].U16[0], 1, 0, 0, 1)
		VMADH_operation(1, state.v[25].U16[1], state.v[25].U16[1], state.v[28].U16[1], 1, 0, 0, 1)
		VMADH_operation(2, state.v[25].U16[2], state.v[25].U16[2], state.v[28].U16[2], 1, 0, 0, 1)
		VMADH_operation(3, state.v[25].U16[3], state.v[25].U16[3], state.v[28].U16[3], 1, 0, 0, 1)
		VMADH_operation(4, state.v[25].U16[4], state.v[25].U16[4], state.v[28].U16[4], 1, 0, 0, 1)
		VMADH_operation(5, state.v[25].U16[5], state.v[25].U16[5], state.v[28].U16[5], 1, 0, 0, 1)
		VMADH_operation(6, state.v[25].U16[6], state.v[25].U16[6], state.v[28].U16[6], 1, 0, 0, 1)
		VMADH_operation(7, state.v[25].U16[7], state.v[25].U16[7], state.v[28].U16[7], 1, 0, 0, 1)
	}


_0400172C:	// 400172c: <275a0010>	ADDIU     K0 = K0 + 0010
	state.r[K0] = state.r[K0] + 0x0010;


_04001730:	// 4001730: <4a0c18c0>	VMULF     vec03 = ( acc = (vec03 * vec12[<none>]) << 1 ) >> 16
	{
		VMULF_operation(0, state.v[3].U16[0], state.v[3].U16[0], state.v[12].U16[0], 1, 1, 1, 1)
		VMULF_operation(1, state.v[3].U16[1], state.v[3].U16[1], state.v[12].U16[1], 1, 1, 1, 1)
		VMULF_operation(2, state.v[3].U16[2], state.v[3].U16[2], state.v[12].U16[2], 1, 1, 1, 1)
		VMULF_operation(3, state.v[3].U16[3], state.v[3].U16[3], state.v[12].U16[3], 1, 1, 1, 1)
		VMULF_operation(4, state.v[3].U16[4], state.v[3].U16[4], state.v[12].U16[4], 1, 1, 1, 1)
		VMULF_operation(5, state.v[3].U16[5], state.v[3].U16[5], state.v[12].U16[5], 1, 1, 1, 1)
		VMULF_operation(6, state.v[3].U16[6], state.v[3].U16[6], state.v[12].U16[6], 1, 1, 1, 1)
		VMULF_operation(7, state.v[3].U16[7], state.v[3].U16[7], state.v[12].U16[7], 1, 1, 1, 1)
	}


_04001734:	// 4001734: <4a1cc60f>	VMADH     vec24 = ( acc+= (vec24 * vec28[<none>]) << 16) >> 16
	{
		VMADH_operation(0, state.v[24].U16[0], state.v[24].U16[0], state.v[28].U16[0], 1, 1, 0, 1)
		VMADH_operation(1, state.v[24].U16[1], state.v[24].U16[1], state.v[28].U16[1], 1, 1, 0, 1)
		VMADH_operation(2, state.v[24].U16[2], state.v[24].U16[2], state.v[28].U16[2], 1, 1, 0, 1)
		VMADH_operation(3, state.v[24].U16[3], state.v[24].U16[3], state.v[28].U16[3], 1, 1, 0, 1)
		VMADH_operation(4, state.v[24].U16[4], state.v[24].U16[4], state.v[28].U16[4], 1, 1, 0, 1)
		VMADH_operation(5, state.v[24].U16[5], state.v[24].U16[5], state.v[28].U16[5], 1, 1, 0, 1)
		VMADH_operation(6, state.v[24].U16[6], state.v[24].U16[6], state.v[28].U16[6], 1, 1, 0, 1)
		VMADH_operation(7, state.v[24].U16[7], state.v[24].U16[7], state.v[28].U16[7], 1, 1, 0, 1)
	}


_04001738:	// 4001738: <4b759cd4>	VADDC	vec19 = vec19 + vec21[3]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[21].U16[4];
		VADDC_operation(0, state.v[19].U16[0], state.v[19].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[19].U16[1], state.v[19].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[19].U16[2], state.v[19].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[19].U16[3], state.v[19].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[19].U16[4], state.v[19].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[19].U16[5], state.v[19].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[19].U16[6], state.v[19].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[19].U16[7], state.v[19].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_0400173C:	// 400173c: <4b749490>	VADD      vec18 = vec18 + vec20[3]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[20].U16[4];
		VADD_operation(0, state.v[18].U16[0], state.v[18].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[18].U16[1], state.v[18].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[18].U16[2], state.v[18].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[18].U16[3], state.v[18].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[18].U16[4], state.v[18].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[18].U16[5], state.v[18].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[18].U16[6], state.v[18].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[18].U16[7], state.v[18].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001740:	// 4001740: <4b357bd4>	VADDC	vec15 = vec15 + vec21[1]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[21].U16[6];
		VADDC_operation(0, state.v[15].U16[0], state.v[15].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[15].U16[1], state.v[15].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[15].U16[2], state.v[15].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[15].U16[3], state.v[15].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[15].U16[4], state.v[15].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[15].U16[5], state.v[15].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[15].U16[6], state.v[15].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[15].U16[7], state.v[15].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_04001744:	// 4001744: <eb9a207f>	SQV       [GP + 0xf0] = vec26 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[GP]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[26].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[26].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[26].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[26].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[26].U64[0] & temp1);
			value2 |= (state.v[26].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001748:	// 4001748: <4b346b50>	VADD      vec13 = vec13 + vec20[1]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[20].U16[6];
		VADD_operation(0, state.v[13].U16[0], state.v[13].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[13].U16[1], state.v[13].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[13].U16[2], state.v[13].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[13].U16[3], state.v[13].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[13].U16[4], state.v[13].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[13].U16[5], state.v[13].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[13].U16[6], state.v[13].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[13].U16[7], state.v[13].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_0400174C:	// 400174c: <eb39207f>	SQV       [T9 + 0xf0] = vec25 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[T9]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[25].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[25].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[25].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[25].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[25].U64[0] & temp1);
			value2 |= (state.v[25].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001750:	// 4001750: <4b157394>	VADDC	vec14 = vec14 + vec21[0]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[21].U16[7];
		VADDC_operation(0, state.v[14].U16[0], state.v[14].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[14].U16[1], state.v[14].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[14].U16[2], state.v[14].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[14].U16[3], state.v[14].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[14].U16[4], state.v[14].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[14].U16[5], state.v[14].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[14].U16[6], state.v[14].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[14].U16[7], state.v[14].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_04001754:	// 4001754: <eb58207f>	SQV       [K0 + 0xf0] = vec24 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[K0]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[24].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[24].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[24].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[24].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[24].U64[0] & temp1);
			value2 |= (state.v[24].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001758:	// 4001758: <4b146310>	VADD      vec12 = vec12 + vec20[0]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[20].U16[7];
		VADD_operation(0, state.v[12].U16[0], state.v[12].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[12].U16[1], state.v[12].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[12].U16[2], state.v[12].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[12].U16[3], state.v[12].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[12].U16[4], state.v[12].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[12].U16[5], state.v[12].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[12].U16[6], state.v[12].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[12].U16[7], state.v[12].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_0400175C:	// 400175c: <eb7b207f>	SQV       [K1 + 0xf0] = vec27 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[K1]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[27].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[27].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[27].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[27].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[27].U64[0] & temp1);
			value2 |= (state.v[27].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001760:	// 4001760: <4b558c54>	VADDC	vec17 = vec17 + vec21[2]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[21].U16[5];
		VADDC_operation(0, state.v[17].U16[0], state.v[17].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[17].U16[1], state.v[17].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[17].U16[2], state.v[17].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[17].U16[3], state.v[17].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[17].U16[4], state.v[17].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[17].U16[5], state.v[17].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[17].U16[6], state.v[17].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[17].U16[7], state.v[17].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_04001764:	// 4001764: <175dffa8>	BNE       (SP!=K0) --> 1608
	sp_reg_pc = 0x04001764;
	if (state.r[K0] != state.r[SP])
	{
		{
			_u16		flag0 = state.flag[0];
			_u16		s2value = state.v[20].U16[5];
			VADD_operation(0, state.v[16].U16[0], state.v[16].U16[0], s2value, 1, 1, 1, 1)
			VADD_operation(1, state.v[16].U16[1], state.v[16].U16[1], s2value, 1, 1, 1, 1)
			VADD_operation(2, state.v[16].U16[2], state.v[16].U16[2], s2value, 1, 1, 1, 1)
			VADD_operation(3, state.v[16].U16[3], state.v[16].U16[3], s2value, 1, 1, 1, 1)
			VADD_operation(4, state.v[16].U16[4], state.v[16].U16[4], s2value, 1, 1, 1, 1)
			VADD_operation(5, state.v[16].U16[5], state.v[16].U16[5], s2value, 1, 1, 1, 1)
			VADD_operation(6, state.v[16].U16[6], state.v[16].U16[6], s2value, 1, 1, 1, 1)
			VADD_operation(7, state.v[16].U16[7], state.v[16].U16[7], s2value, 1, 1, 1, 1)
			state.flag[0] = 0x0000;
		}
		goto _04001608;
	}


_04001768:	// 4001768: <4b548410>	VADD      vec16 = vec16 + vec20[2]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[20].U16[5];
		VADD_operation(0, state.v[16].U16[0], state.v[16].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[16].U16[1], state.v[16].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[16].U16[2], state.v[16].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[16].U16[3], state.v[16].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[16].U16[4], state.v[16].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[16].U16[5], state.v[16].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[16].U16[6], state.v[16].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[16].U16[7], state.v[16].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_0400176C:	// 400176c: <90050d58>	LBU       A1 = [R0+0d58]
	state.r[A1] = (_s32)(_u8)pDMEM[((0 + 0x00000D58) & 0xfff) ^ 3];


_04001770:	// 4001770: <24a5ffff>	ADDIU     A1 = A1 + ffff
	state.r[A1] = state.r[A1] + 0xFFFFFFFF;


_04001774:	// 4001774: <30a5000f>	ANDI      A1 = A1 & 000f
	state.r[A1] = (state.r[A1] & 0x0000000F);


_04001778:	// 4001778: <000528c0>	SLL       A1 = A1 << 3
	state.r[A1] = ((_u32)state.r[A1] << 3);


_0400177C:	// 400177c: <24a50b40>	ADDIU     A1 = A1 + 0b40
	state.r[A1] = state.r[A1] + 0x0B40;


_04001780:	// 4001780: <e8a30f00>	SSV       [A1 + 0x00] = vec03 <14>
	Save16_DMEM(state.v[3].U16[0], (0x00000000 + state.r[A1]) & 0xfff);


_04001784:	// 4001784: <e8a40f01>	SSV       [A1 + 0x02] = vec04 <14>
	Save16_DMEM(state.v[4].U16[0], (0x00000002 + state.r[A1]) & 0xfff);


_04001788:	// 4001788: <e8a50f02>	SSV       [A1 + 0x04] = vec05 <14>
	Save16_DMEM(state.v[5].U16[0], (0x00000004 + state.r[A1]) & 0xfff);


_0400178C:	// 400178c: <03c00008>	JR        S8
	{
		_u32	temp = ((state.r[S8] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		Save16_DMEM(state.v[6].U16[0], (0x00000006 + state.r[A1]) & 0xfff);
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001790:	// 4001790: <e8a60f03>	SSV       [A1 + 0x06] = vec06 <14>
	Save16_DMEM(state.v[6].U16[0], (0x00000006 + state.r[A1]) & 0xfff);


_04001794:	// 4001794: <4a08422c>	VXOR      vec08 = vec08 xor vec08[<none>]
	rsp_cop2_vxor(&state.v[8], &state.v[8], &state.v[8]);


_04001798:	// 4001798: <48854000>	MTC2      vec8 <00> = A1
	state.v[8].U16[7] = (_u16)state.r[A1];


_0400179C:	// 400179c: <48854400>	MTC2      vec8 <08> = A1
	state.v[8].U16[3] = (_u16)state.r[A1];


_040017A0:	// 40017a0: <4a094a6c>	VXOR      vec09 = vec09 xor vec09[<none>]
	rsp_cop2_vxor(&state.v[9], &state.v[9], &state.v[9]);


_040017A4:	// 40017a4: <48854900>	MTC2      vec9 <02> = A1
	state.v[9].U16[6] = (_u16)state.r[A1];


_040017A8:	// 40017a8: <48854d00>	MTC2      vec9 <10> = A1
	state.v[9].U16[2] = (_u16)state.r[A1];


_040017AC:	// 40017ac: <4a0a52ac>	VXOR      vec10 = vec10 xor vec10[<none>]
	rsp_cop2_vxor(&state.v[10], &state.v[10], &state.v[10]);


_040017B0:	// 40017b0: <48855200>	MTC2      vec10 <04> = A1
	state.v[10].U16[5] = (_u16)state.r[A1];


_040017B4:	// 40017b4: <48855600>	MTC2      vec10 <12> = A1
	state.v[10].U16[1] = (_u16)state.r[A1];


_040017B8:	// 40017b8: <4a0b5aec>	VXOR      vec11 = vec11 xor vec11[<none>]
	rsp_cop2_vxor(&state.v[11], &state.v[11], &state.v[11]);


_040017BC:	// 40017bc: <48855b00>	MTC2      vec11 <06> = A1
	state.v[11].U16[4] = (_u16)state.r[A1];


_040017C0:	// 40017c0: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		state.v[11].U16[0] = (_u16)state.r[A1];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_040017C4:	// 40017c4: <48855f00>	MTC2      vec11 <14> = A1
	state.v[11].U16[0] = (_u16)state.r[A1];


_040017C8:	// 40017c8: <48861800>	MTC2      vec3 <00> = A2
	state.v[3].U16[7] = (_u16)state.r[A2];


_040017CC:	// 40017cc: <00064403>	SRA       T0 = A2 >> 16
	state.r[T0] = ((_s32)state.r[A2] >> 16);


_040017D0:	// 40017d0: <48882000>	MTC2      vec4 <00> = T0
	state.v[4].U16[7] = (_u16)state.r[T0];


_040017D4:	// 40017d4: <c8052001>	LQV       vec05 <00> = [R0 + 0x10]
	{
		_u32 addr = (0x00000010 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[5].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[5].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[5].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[5].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[5].U64[0] = state.v[5].U64[0] & ~temp1;
			state.v[5].U64[1] = state.v[5].U64[1] & ~temp2;
			state.v[5].U64[0] = state.v[5].U64[0] | value1;
			state.v[5].U64[1] = state.v[5].U64[1] | value2;
		}
	}


_040017D8:	// 40017d8: <4b0300d0>	VADD      vec03 = vec00 + vec03[0]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[3].U16[7];
		VADD_operation(0, state.v[3].U16[0], state.v[0].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[3].U16[1], state.v[0].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[3].U16[2], state.v[0].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[3].U16[3], state.v[0].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[3].U16[4], state.v[0].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[3].U16[5], state.v[0].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[3].U16[6], state.v[0].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[3].U16[7], state.v[0].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040017DC:	// 40017dc: <4b040110>	VADD      vec04 = vec00 + vec04[0]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[4].U16[7];
		VADD_operation(0, state.v[4].U16[0], state.v[0].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[4].U16[1], state.v[0].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[4].U16[2], state.v[0].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[4].U16[3], state.v[0].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[4].U16[4], state.v[0].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[4].U16[5], state.v[0].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[4].U16[6], state.v[0].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[4].U16[7], state.v[0].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040017E0:	// 40017e0: <48853000>	MTC2      vec6 <00> = A1
	state.v[6].U16[7] = (_u16)state.r[A1];


_040017E4:	// 40017e4: <00054403>	SRA       T0 = A1 >> 16
	state.r[T0] = ((_s32)state.r[A1] >> 16);


_040017E8:	// 40017e8: <48883100>	MTC2      vec6 <02> = T0
	state.v[6].U16[6] = (_u16)state.r[T0];


_040017EC:	// 40017ec: <4a0518c6>	VMUDN     vec03 = ( acc = vec03 * vec05[<none>]      ) >> 16
	{
		VMUDN_operation(0, state.v[3].U16[0], state.v[3].U16[0], state.v[5].U16[0], 1, 1, 1, 1)
		VMUDN_operation(1, state.v[3].U16[1], state.v[3].U16[1], state.v[5].U16[1], 1, 1, 1, 1)
		VMUDN_operation(2, state.v[3].U16[2], state.v[3].U16[2], state.v[5].U16[2], 1, 1, 1, 1)
		VMUDN_operation(3, state.v[3].U16[3], state.v[3].U16[3], state.v[5].U16[3], 1, 1, 1, 1)
		VMUDN_operation(4, state.v[3].U16[4], state.v[3].U16[4], state.v[5].U16[4], 1, 1, 1, 1)
		VMUDN_operation(5, state.v[3].U16[5], state.v[3].U16[5], state.v[5].U16[5], 1, 1, 1, 1)
		VMUDN_operation(6, state.v[3].U16[6], state.v[3].U16[6], state.v[5].U16[6], 1, 1, 1, 1)
		VMUDN_operation(7, state.v[3].U16[7], state.v[3].U16[7], state.v[5].U16[7], 1, 1, 1, 1)
	}


_040017F0:	// 40017f0: <4a05210f>	VMADH     vec04 = ( acc+= (vec04 * vec05[<none>]) << 16) >> 16
	{
		VMADH_operation(0, state.v[4].U16[0], state.v[4].U16[0], state.v[5].U16[0], 1, 1, 0, 1)
		VMADH_operation(1, state.v[4].U16[1], state.v[4].U16[1], state.v[5].U16[1], 1, 1, 0, 1)
		VMADH_operation(2, state.v[4].U16[2], state.v[4].U16[2], state.v[5].U16[2], 1, 1, 0, 1)
		VMADH_operation(3, state.v[4].U16[3], state.v[4].U16[3], state.v[5].U16[3], 1, 1, 0, 1)
		VMADH_operation(4, state.v[4].U16[4], state.v[4].U16[4], state.v[5].U16[4], 1, 1, 0, 1)
		VMADH_operation(5, state.v[4].U16[5], state.v[4].U16[5], state.v[5].U16[5], 1, 1, 0, 1)
		VMADH_operation(6, state.v[4].U16[6], state.v[4].U16[6], state.v[5].U16[6], 1, 1, 0, 1)
		VMADH_operation(7, state.v[4].U16[7], state.v[4].U16[7], state.v[5].U16[7], 1, 1, 0, 1)
	}


_040017F4:	// 40017f4: <4b0618d4>	VADDC	vec03 = vec03 + vec06[0]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[6].U16[7];
		VADDC_operation(0, state.v[3].U16[0], state.v[3].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[3].U16[1], state.v[3].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[3].U16[2], state.v[3].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[3].U16[3], state.v[3].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[3].U16[4], state.v[3].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[3].U16[5], state.v[3].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[3].U16[6], state.v[3].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[3].U16[7], state.v[3].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_040017F8:	// 40017f8: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		{
			_u16		flag0 = state.flag[0];
			_u16		s2value = state.v[6].U16[6];
			VADD_operation(0, state.v[4].U16[0], state.v[4].U16[0], s2value, 1, 1, 1, 1)
			VADD_operation(1, state.v[4].U16[1], state.v[4].U16[1], s2value, 1, 1, 1, 1)
			VADD_operation(2, state.v[4].U16[2], state.v[4].U16[2], s2value, 1, 1, 1, 1)
			VADD_operation(3, state.v[4].U16[3], state.v[4].U16[3], s2value, 1, 1, 1, 1)
			VADD_operation(4, state.v[4].U16[4], state.v[4].U16[4], s2value, 1, 1, 1, 1)
			VADD_operation(5, state.v[4].U16[5], state.v[4].U16[5], s2value, 1, 1, 1, 1)
			VADD_operation(6, state.v[4].U16[6], state.v[4].U16[6], s2value, 1, 1, 1, 1)
			VADD_operation(7, state.v[4].U16[7], state.v[4].U16[7], s2value, 1, 1, 1, 1)
			state.flag[0] = 0x0000;
		}
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_040017FC:	// 40017fc: <4b262110>	VADD      vec04 = vec04 + vec06[1]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[6].U16[6];
		VADD_operation(0, state.v[4].U16[0], state.v[4].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[4].U16[1], state.v[4].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[4].U16[2], state.v[4].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[4].U16[3], state.v[4].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[4].U16[4], state.v[4].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[4].U16[5], state.v[4].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[4].U16[6], state.v[4].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[4].U16[7], state.v[4].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001800:	// 4001800: <340a0bc0>	ORI       T2 = R0 | 0x0bc0
	state.r[T2] = (0 | 0x00000BC0);


_04001804:	// 4001804: <34080001>	ORI       T0 = R0 | 0x0001
	state.r[T0] = (0 | 0x00000001);


_04001808:	// 4001808: <48881800>	MTC2      vec3 <00> = T0
	state.v[3].U16[7] = (_u16)state.r[T0];


_0400180C:	// 400180c: <954d0000>	LHU       T5 = [T2+0000]
	state.r[T5] = (_s32)(_u16)Load16_DMEM((state.r[T2] + 0x00000000) & 0xfff);


_04001810:	// 4001810: <954e0002>	LHU       T6 = [T2+0002]
	state.r[T6] = (_s32)(_u16)Load16_DMEM((state.r[T2] + 0x00000002) & 0xfff);


_04001814:	// 4001814: <954b0008>	LHU       T3 = [T2+0008]
	state.r[T3] = (_s32)(_u16)Load16_DMEM((state.r[T2] + 0x00000008) & 0xfff);


_04001818:	// 4001818: <954c000a>	LHU       T4 = [T2+000a]
	state.r[T4] = (_s32)(_u16)Load16_DMEM((state.r[T2] + 0x0000000A) & 0xfff);


_0400181C:	// 400181c: <000d6c00>	SLL       T5 = T5 << 16
	state.r[T5] = ((_u32)state.r[T5] << 16);


_04001820:	// 4001820: <000e7400>	SLL       T6 = T6 << 16
	state.r[T6] = ((_u32)state.r[T6] << 16);


_04001824:	// 4001824: <016d5825>	OR        T3 = T3 | T5
	state.r[T3] = (state.r[T3] | state.r[T5]);


_04001828:	// 4001828: <018e6025>	OR        T4 = T4 | T6
	state.r[T4] = (state.r[T4] | state.r[T6]);


_0400182C:	// 400182c: <340d8000>	ORI       T5 = R0 | 0x8000
	state.r[T5] = (0 | 0x00008000);


_04001830:	// 4001830: <240e8000>	ADDIU     T6 = R0 + 8000
	state.r[T6] = 0 + 0xFFFF8000;


_04001834:	// 4001834: <016d402a>	SLT ?-?
	if (state.r[T3] < state.r[T5])
	{
		state.r[T0] = 1;
	}
	else
	{
		state.r[T0] = 0;
	}


_04001838:	// 4001838: <15000002>	BNE       (R0!=T0) --> 1844
	sp_reg_pc = 0x04001838;
	if (state.r[T0] != 0)
	{
		if (state.r[T3] < state.r[T6])
		{
			state.r[T0] = 1;
		}
		else
		{
			state.r[T0] = 0;
		}
		goto _04001844;
	}


_0400183C:	// 400183c: <016e402a>	SLT ?-?
	if (state.r[T3] < state.r[T6])
	{
		state.r[T0] = 1;
	}
	else
	{
		state.r[T0] = 0;
	}


_04001840:	// 4001840: <340b7fff>	ORI       T3 = R0 | 0x7fff
	state.r[T3] = (0 | 0x00007FFF);


_04001844:	// 4001844: <11000002>	BEQ       (R0==T0) --> 1850
	sp_reg_pc = 0x04001844;
	if (state.r[T0] == 0)
	{
		goto _04001850;
	}


_04001848:	// 4001848: <00000000>	NOP       


_0400184C:	// 400184c: <240b8000>	ADDIU     T3 = R0 + 8000
	state.r[T3] = 0 + 0xFFFF8000;


_04001850:	// 4001850: <018d402a>	SLT ?-?
	if (state.r[T4] < state.r[T5])
	{
		state.r[T0] = 1;
	}
	else
	{
		state.r[T0] = 0;
	}


_04001854:	// 4001854: <15000002>	BNE       (R0!=T0) --> 1860
	sp_reg_pc = 0x04001854;
	if (state.r[T0] != 0)
	{
		if (state.r[T4] < state.r[T6])
		{
			state.r[T0] = 1;
		}
		else
		{
			state.r[T0] = 0;
		}
		goto _04001860;
	}


_04001858:	// 4001858: <018e402a>	SLT ?-?
	if (state.r[T4] < state.r[T6])
	{
		state.r[T0] = 1;
	}
	else
	{
		state.r[T0] = 0;
	}


_0400185C:	// 400185c: <340c7fff>	ORI       T4 = R0 | 0x7fff
	state.r[T4] = (0 | 0x00007FFF);


_04001860:	// 4001860: <11000002>	BEQ       (R0==T0) --> 186c
	sp_reg_pc = 0x04001860;
	if (state.r[T0] == 0)
	{
		goto _0400186C;
	}


_04001864:	// 4001864: <00000000>	NOP       


_04001868:	// 4001868: <240c8000>	ADDIU     T4 = R0 + 8000
	state.r[T4] = 0 + 0xFFFF8000;


_0400186C:	// 400186c: <488b1c00>	MTC2      vec3 <08> = T3
	state.v[3].U16[3] = (_u16)state.r[T3];


_04001870:	// 4001870: <488c1d00>	MTC2      vec3 <10> = T4
	state.v[3].U16[2] = (_u16)state.r[T4];


_04001874:	// 4001874: <4b830114>	VADDC	vec04 = vec00 + vec03[4]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[3].U16[3];
		VADDC_operation(0, state.v[4].U16[0], state.v[0].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[4].U16[1], state.v[0].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[4].U16[2], state.v[0].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[4].U16[3], state.v[0].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[4].U16[4], state.v[0].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[4].U16[5], state.v[0].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[4].U16[6], state.v[0].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[4].U16[7], state.v[0].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_04001878:	// 4001878: <4ba30154>	VADDC	vec05 = vec00 + vec03[5]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[3].U16[2];
		VADDC_operation(0, state.v[5].U16[0], state.v[0].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[5].U16[1], state.v[0].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[5].U16[2], state.v[0].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[5].U16[3], state.v[0].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[5].U16[4], state.v[0].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[5].U16[5], state.v[0].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[5].U16[6], state.v[0].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[5].U16[7], state.v[0].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_0400187C:	// 400187c: <34080018>	ORI       T0 = R0 | 0x0018
	state.r[T0] = (0 | 0x00000018);


_04001880:	// 4001880: <c8a12000>	LQV       vec01 <00> = [A1 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[A1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[1].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[1].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[1].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[1].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[1].U64[0] = state.v[1].U64[0] & ~temp1;
			state.v[1].U64[1] = state.v[1].U64[1] & ~temp2;
			state.v[1].U64[0] = state.v[1].U64[0] | value1;
			state.v[1].U64[1] = state.v[1].U64[1] | value2;
		}
	}


_04001884:	// 4001884: <4b032187>	VMUDH     vec06 = ( acc = (vec04 * vec03[0]) << 16) >> 16
	{
		_u16		s2value = state.v[3].U16[7];
		VMUDH_operation(0, state.v[6].U16[0], state.v[4].U16[0], s2value, 0, 1, 0, 1)
		VMUDH_operation(1, state.v[6].U16[1], state.v[4].U16[1], s2value, 0, 1, 0, 1)
		VMUDH_operation(2, state.v[6].U16[2], state.v[4].U16[2], s2value, 0, 1, 0, 1)
		VMUDH_operation(3, state.v[6].U16[3], state.v[4].U16[3], s2value, 0, 1, 0, 1)
		VMUDH_operation(4, state.v[6].U16[4], state.v[4].U16[4], s2value, 0, 1, 0, 1)
		VMUDH_operation(5, state.v[6].U16[5], state.v[4].U16[5], s2value, 0, 1, 0, 1)
		VMUDH_operation(6, state.v[6].U16[6], state.v[4].U16[6], s2value, 0, 1, 0, 1)
		VMUDH_operation(7, state.v[6].U16[7], state.v[4].U16[7], s2value, 0, 1, 0, 1)
	}


_04001888:	// 4001888: <c8c22000>	LQV       vec02 <00> = [A2 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[A2]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[2].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[2].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[2].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[2].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[2].U64[0] = state.v[2].U64[0] & ~temp1;
			state.v[2].U64[1] = state.v[2].U64[1] & ~temp2;
			state.v[2].U64[0] = state.v[2].U64[0] | value1;
			state.v[2].U64[1] = state.v[2].U64[1] | value2;
		}
	}


_0400188C:	// 400188c: <4b03084f>	VMADH     vec01 = ( acc+= (vec01 * vec03[0]) << 16) >> 16
	{
		_u16		s2value = state.v[3].U16[7];
		VMADH_operation(0, state.v[1].U16[0], state.v[1].U16[0], s2value, 1, 0, 0, 1)
		VMADH_operation(1, state.v[1].U16[1], state.v[1].U16[1], s2value, 1, 0, 0, 1)
		VMADH_operation(2, state.v[1].U16[2], state.v[1].U16[2], s2value, 1, 0, 0, 1)
		VMADH_operation(3, state.v[1].U16[3], state.v[1].U16[3], s2value, 1, 0, 0, 1)
		VMADH_operation(4, state.v[1].U16[4], state.v[1].U16[4], s2value, 1, 0, 0, 1)
		VMADH_operation(5, state.v[1].U16[5], state.v[1].U16[5], s2value, 1, 0, 0, 1)
		VMADH_operation(6, state.v[1].U16[6], state.v[1].U16[6], s2value, 1, 0, 0, 1)
		VMADH_operation(7, state.v[1].U16[7], state.v[1].U16[7], s2value, 1, 0, 0, 1)
	}


_04001890:	// 4001890: <24a50010>	ADDIU     A1 = A1 + 0010
	state.r[A1] = state.r[A1] + 0x0010;


_04001894:	// 4001894: <4b032987>	VMUDH     vec06 = ( acc = (vec05 * vec03[0]) << 16) >> 16
	{
		_u16		s2value = state.v[3].U16[7];
		VMUDH_operation(0, state.v[6].U16[0], state.v[5].U16[0], s2value, 1, 1, 1, 1)
		VMUDH_operation(1, state.v[6].U16[1], state.v[5].U16[1], s2value, 1, 1, 1, 1)
		VMUDH_operation(2, state.v[6].U16[2], state.v[5].U16[2], s2value, 1, 1, 1, 1)
		VMUDH_operation(3, state.v[6].U16[3], state.v[5].U16[3], s2value, 1, 1, 1, 1)
		VMUDH_operation(4, state.v[6].U16[4], state.v[5].U16[4], s2value, 1, 1, 1, 1)
		VMUDH_operation(5, state.v[6].U16[5], state.v[5].U16[5], s2value, 1, 1, 1, 1)
		VMUDH_operation(6, state.v[6].U16[6], state.v[5].U16[6], s2value, 1, 1, 1, 1)
		VMUDH_operation(7, state.v[6].U16[7], state.v[5].U16[7], s2value, 1, 1, 1, 1)
	}


_04001898:	// 4001898: <24c60010>	ADDIU     A2 = A2 + 0010
	state.r[A2] = state.r[A2] + 0x0010;


_0400189C:	// 400189c: <4b03108f>	VMADH     vec02 = ( acc+= (vec02 * vec03[0]) << 16) >> 16
	{
		_u16		s2value = state.v[3].U16[7];
		VMADH_operation(0, state.v[2].U16[0], state.v[2].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[2].U16[1], state.v[2].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[2].U16[2], state.v[2].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[2].U16[3], state.v[2].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[2].U16[4], state.v[2].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[2].U16[5], state.v[2].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[2].U16[6], state.v[2].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[2].U16[7], state.v[2].U16[7], s2value, 1, 1, 0, 1)
	}


_040018A0:	// 40018a0: <2508ffff>	ADDIU     T0 = T0 + ffff
	state.r[T0] = state.r[T0] + 0xFFFFFFFF;


_040018A4:	// 40018a4: <24e70020>	ADDIU     A3 = A3 + 0020
	state.r[A3] = state.r[A3] + 0x0020;


_040018A8:	// 40018a8: <e8e10870>	SSV       [A3 + 0x00] = vec01 <00>
	Save16_DMEM(state.v[1].U16[7], (0xFFFFFFE0 + state.r[A3]) & 0xfff);


_040018AC:	// 40018ac: <e8e20871>	SSV       [A3 + 0x02] = vec02 <00>
	Save16_DMEM(state.v[2].U16[7], (0xFFFFFFE2 + state.r[A3]) & 0xfff);


_040018B0:	// 40018b0: <e8e10972>	SSV       [A3 + 0x04] = vec01 <02>
	Save16_DMEM(state.v[1].U16[6], (0xFFFFFFE4 + state.r[A3]) & 0xfff);


_040018B4:	// 40018b4: <e8e20973>	SSV       [A3 + 0x06] = vec02 <02>
	Save16_DMEM(state.v[2].U16[6], (0xFFFFFFE6 + state.r[A3]) & 0xfff);


_040018B8:	// 40018b8: <e8e10a74>	SSV       [A3 + 0x08] = vec01 <04>
	Save16_DMEM(state.v[1].U16[5], (0xFFFFFFE8 + state.r[A3]) & 0xfff);


_040018BC:	// 40018bc: <e8e20a75>	SSV       [A3 + 0x0a] = vec02 <04>
	Save16_DMEM(state.v[2].U16[5], (0xFFFFFFEA + state.r[A3]) & 0xfff);


_040018C0:	// 40018c0: <e8e10b76>	SSV       [A3 + 0x0c] = vec01 <06>
	Save16_DMEM(state.v[1].U16[4], (0xFFFFFFEC + state.r[A3]) & 0xfff);


_040018C4:	// 40018c4: <e8e20b77>	SSV       [A3 + 0x0e] = vec02 <06>
	Save16_DMEM(state.v[2].U16[4], (0xFFFFFFEE + state.r[A3]) & 0xfff);


_040018C8:	// 40018c8: <e8e10c78>	SSV       [A3 + 0x10] = vec01 <08>
	Save16_DMEM(state.v[1].U16[3], (0xFFFFFFF0 + state.r[A3]) & 0xfff);


_040018CC:	// 40018cc: <e8e20c79>	SSV       [A3 + 0x12] = vec02 <08>
	Save16_DMEM(state.v[2].U16[3], (0xFFFFFFF2 + state.r[A3]) & 0xfff);


_040018D0:	// 40018d0: <e8e10d7a>	SSV       [A3 + 0x14] = vec01 <10>
	Save16_DMEM(state.v[1].U16[2], (0xFFFFFFF4 + state.r[A3]) & 0xfff);


_040018D4:	// 40018d4: <e8e20d7b>	SSV       [A3 + 0x16] = vec02 <10>
	Save16_DMEM(state.v[2].U16[2], (0xFFFFFFF6 + state.r[A3]) & 0xfff);


_040018D8:	// 40018d8: <e8e10e7c>	SSV       [A3 + 0x18] = vec01 <12>
	Save16_DMEM(state.v[1].U16[1], (0xFFFFFFF8 + state.r[A3]) & 0xfff);


_040018DC:	// 40018dc: <e8e20e7d>	SSV       [A3 + 0x1a] = vec02 <12>
	Save16_DMEM(state.v[2].U16[1], (0xFFFFFFFA + state.r[A3]) & 0xfff);


_040018E0:	// 40018e0: <e8e10f7e>	SSV       [A3 + 0x1c] = vec01 <14>
	Save16_DMEM(state.v[1].U16[0], (0xFFFFFFFC + state.r[A3]) & 0xfff);


_040018E4:	// 40018e4: <1500ffe6>	BNE       (R0!=T0) --> 1880
	sp_reg_pc = 0x040018E4;
	if (state.r[T0] != 0)
	{
		Save16_DMEM(state.v[2].U16[0], (0xFFFFFFFE + state.r[A3]) & 0xfff);
		goto _04001880;
	}


_040018E8:	// 40018e8: <e8e20f7f>	SSV       [A3 + 0x1e] = vec02 <14>
	Save16_DMEM(state.v[2].U16[0], (0xFFFFFFFE + state.r[A3]) & 0xfff);


_040018EC:	// 40018ec: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_040018F0:	// 40018f0: <00000000>	NOP       


_040018F4:	// 40018f4: <001ff025>	OR        S8 = R0 | RA
	state.r[S8] = (0 | state.r[RA]);


_040018F8:	// 40018f8: <8c050258>	LW        A1 = [R0+0258]
	state.r[A1] = (_s32)Load32_DMEM((0 + 0x00000258) & 0xfff);


_040018FC:	// 40018fc: <34060600>	ORI       A2 = R0 | 0x0600
	state.r[A2] = (0 | 0x00000600);


_04001900:	// 4001900: <0d0004fa>	JAL	    040013e8
	state.r[A3] = (0 | 0x000000FF);
	sp_reg_pc = 0x04001900;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040013E8;


_04001904:	// 4001904: <340700ff>	ORI       A3 = R0 | 0x00ff
	state.r[A3] = (0 | 0x000000FF);


_04001908:	// 4001908: <34050001>	ORI       A1 = R0 | 0x0001
	state.r[A1] = (0 | 0x00000001);


_0400190C:	// 400190c: <3406f850>	ORI       A2 = R0 | 0xf850
	state.r[A2] = (0 | 0x0000F850);


_04001910:	// 4001910: <48852000>	MTC2      vec4 <00> = A1
	state.v[4].U16[7] = (_u16)state.r[A1];


_04001914:	// 4001914: <48862100>	MTC2      vec4 <02> = A2
	state.v[4].U16[6] = (_u16)state.r[A2];


_04001918:	// 4001918: <340d0bc0>	ORI       T5 = R0 | 0x0bc0
	state.r[T5] = (0 | 0x00000BC0);


_0400191C:	// 400191c: <c9a21801>	LDV       vec02 <00> = [T5 + 0x08]
	rsp_ldv_compiler((state.r[T5] + 0x00000008) & 0xFFF, 2, 8);


_04001920:	// 4001920: <c9a31800>	LDV       vec03 <00> = [T5 + 0x00]
	rsp_ldv_compiler((state.r[T5] & 0xFFF), 3, 8);


_04001924:	// 4001924: <4b041146>	VMUDN     vec05 = ( acc = vec02 * vec04[0]      ) >> 16
	{
		_u16		s2value = state.v[4].U16[7];
		VMUDN_operation(0, state.v[5].U16[0], state.v[2].U16[0], s2value, 0, 1, 1, 1)
		VMUDN_operation(1, state.v[5].U16[1], state.v[2].U16[1], s2value, 0, 1, 1, 1)
		VMUDN_operation(2, state.v[5].U16[2], state.v[2].U16[2], s2value, 0, 1, 1, 1)
		VMUDN_operation(3, state.v[5].U16[3], state.v[2].U16[3], s2value, 0, 1, 1, 1)
		VMUDN_operation(4, state.v[5].U16[4], state.v[2].U16[4], s2value, 0, 1, 1, 1)
		VMUDN_operation(5, state.v[5].U16[5], state.v[2].U16[5], s2value, 0, 1, 1, 1)
		VMUDN_operation(6, state.v[5].U16[6], state.v[2].U16[6], s2value, 0, 1, 1, 1)
		VMUDN_operation(7, state.v[5].U16[7], state.v[2].U16[7], s2value, 0, 1, 1, 1)
	}


_04001928:	// 4001928: <4b04194f>	VMADH     vec05 = ( acc+= (vec03 * vec04[0]) << 16) >> 16
	{
		_u16		s2value = state.v[4].U16[7];
		VMADH_operation(0, state.v[5].U16[0], state.v[3].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[5].U16[1], state.v[3].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[5].U16[2], state.v[3].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[5].U16[3], state.v[3].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[5].U16[4], state.v[3].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[5].U16[5], state.v[3].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[5].U16[6], state.v[3].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[5].U16[7], state.v[3].U16[7], s2value, 1, 1, 0, 1)
	}


_0400192C:	// 400192c: <8c0c0254>	LW        T4 = [R0+0254]
	state.r[T4] = (_s32)Load32_DMEM((0 + 0x00000254) & 0xfff);


_04001930:	// 4001930: <340b0001>	ORI       T3 = R0 | 0x0001
	state.r[T3] = (0 | 0x00000001);


_04001934:	// 4001934: <340a0600>	ORI       T2 = R0 | 0x0600
	state.r[T2] = (0 | 0x00000600);


_04001938:	// 4001938: <018b2824>	AND       A1 = T4 & T3
	state.r[A1] = (state.r[T4] & state.r[T3]);


_0400193C:	// 400193c: <10a00003>	BEQ       (R0==A1) --> 194c
	sp_reg_pc = 0x0400193C;
	if (state.r[A1] == 0)
	{
		state.r[T3] = ((_u32)state.r[T3] << 1);
		goto _0400194C;
	}


_04001940:	// 4001940: <000b5840>	SLL       T3 = T3 << 1
	state.r[T3] = ((_u32)state.r[T3] << 1);


_04001944:	// 4001944: <c9411800>	LDV       vec01 <00> = [T2 + 0x00]
	rsp_ldv_compiler((state.r[T2] & 0xFFF), 1, 8);


_04001948:	// 4001948: <4b04094d>	VMADM     vec05 = ( acc+= vec01 * vec04[0] ) >> 16
	{
		_u16		s2value = state.v[4].U16[7];
		VMADM_operation(0, state.v[5].U16[0], state.v[1].U16[0], s2value, 1, 1, 1, 1)
		VMADM_operation(1, state.v[5].U16[1], state.v[1].U16[1], s2value, 1, 1, 1, 1)
		VMADM_operation(2, state.v[5].U16[2], state.v[1].U16[2], s2value, 1, 1, 1, 1)
		VMADM_operation(3, state.v[5].U16[3], state.v[1].U16[3], s2value, 1, 1, 1, 1)
		VMADM_operation(4, state.v[5].U16[4], state.v[1].U16[4], s2value, 1, 1, 1, 1)
		VMADM_operation(5, state.v[5].U16[5], state.v[1].U16[5], s2value, 1, 1, 1, 1)
		VMADM_operation(6, state.v[5].U16[6], state.v[1].U16[6], s2value, 1, 1, 1, 1)
		VMADM_operation(7, state.v[5].U16[7], state.v[1].U16[7], s2value, 1, 1, 1, 1)
	}


_0400194C:	// 400194c: <1560fffa>	BNE       (R0!=T3) --> 1938
	sp_reg_pc = 0x0400194C;
	if (state.r[T3] != 0)
	{
		state.r[T2] = state.r[T2] + 0x0008;
		goto _04001938;
	}


_04001950:	// 4001950: <254a0008>	ADDIU     T2 = T2 + 0008
	state.r[T2] = state.r[T2] + 0x0008;


_04001954:	// 4001954: <4b43289d>	VSAW $v2, $v5, $v3[[2]]
	state.v[2].U16[0] = state.accum[0].U16[1];
	state.v[2].U16[1] = state.accum[1].U16[1];
	state.v[2].U16[2] = state.accum[2].U16[1];
	state.v[2].U16[3] = state.accum[3].U16[1];
	state.v[2].U16[4] = state.accum[4].U16[1];
	state.v[2].U16[5] = state.accum[5].U16[1];
	state.v[2].U16[6] = state.accum[6].U16[1];
	state.v[2].U16[7] = state.accum[7].U16[1];


_04001958:	// 4001958: <4b2328dd>	VSAW $v3, $v5, $v3[[1]]
	state.v[3].U16[0] = state.accum[0].U16[2];
	state.v[3].U16[1] = state.accum[1].U16[2];
	state.v[3].U16[2] = state.accum[2].U16[2];
	state.v[3].U16[3] = state.accum[3].U16[2];
	state.v[3].U16[4] = state.accum[4].U16[2];
	state.v[3].U16[5] = state.accum[5].U16[2];
	state.v[3].U16[6] = state.accum[6].U16[2];
	state.v[3].U16[7] = state.accum[7].U16[2];


_0400195C:	// 400195c: <4b241144>	VMUDL     vec05 = ( acc = (vec02 * vec04[1] >> 16)      )
	{
		_u16		s2value = state.v[4].U16[6];
		VMUDL_operation(0, state.v[5].U16[0], state.v[2].U16[0], s2value, 1, 1, 1, 1)
		VMUDL_operation(1, state.v[5].U16[1], state.v[2].U16[1], s2value, 1, 1, 1, 1)
		VMUDL_operation(2, state.v[5].U16[2], state.v[2].U16[2], s2value, 1, 1, 1, 1)
		VMUDL_operation(3, state.v[5].U16[3], state.v[2].U16[3], s2value, 1, 1, 1, 1)
		VMUDL_operation(4, state.v[5].U16[4], state.v[2].U16[4], s2value, 1, 1, 1, 1)
		VMUDL_operation(5, state.v[5].U16[5], state.v[2].U16[5], s2value, 1, 1, 1, 1)
		VMUDL_operation(6, state.v[5].U16[6], state.v[2].U16[6], s2value, 1, 1, 1, 1)
		VMUDL_operation(7, state.v[5].U16[7], state.v[2].U16[7], s2value, 1, 1, 1, 1)
	}


_04001960:	// 4001960: <4b2418cd>	VMADM     vec03 = ( acc+= vec03 * vec04[1] ) >> 16
	{
		_u16		s2value = state.v[4].U16[6];
		VMADM_operation(0, state.v[3].U16[0], state.v[3].U16[0], s2value, 1, 1, 1, 1)
		VMADM_operation(1, state.v[3].U16[1], state.v[3].U16[1], s2value, 1, 1, 1, 1)
		VMADM_operation(2, state.v[3].U16[2], state.v[3].U16[2], s2value, 1, 1, 1, 1)
		VMADM_operation(3, state.v[3].U16[3], state.v[3].U16[3], s2value, 1, 1, 1, 1)
		VMADM_operation(4, state.v[3].U16[4], state.v[3].U16[4], s2value, 1, 1, 1, 1)
		VMADM_operation(5, state.v[3].U16[5], state.v[3].U16[5], s2value, 1, 1, 1, 1)
		VMADM_operation(6, state.v[3].U16[6], state.v[3].U16[6], s2value, 1, 1, 1, 1)
		VMADM_operation(7, state.v[3].U16[7], state.v[3].U16[7], s2value, 1, 1, 1, 1)
	}


_04001964:	// 4001964: <4a00288e>	VMADN     vec02 = ( acc+= vec05 * vec00[<none>] )
	{
		VMADN_operation(0, state.v[2].U16[0], state.v[5].U16[0], state.v[0].U16[0], 1, 1, 1, 1)
		VMADN_operation(1, state.v[2].U16[1], state.v[5].U16[1], state.v[0].U16[1], 1, 1, 1, 1)
		VMADN_operation(2, state.v[2].U16[2], state.v[5].U16[2], state.v[0].U16[2], 1, 1, 1, 1)
		VMADN_operation(3, state.v[2].U16[3], state.v[5].U16[3], state.v[0].U16[3], 1, 1, 1, 1)
		VMADN_operation(4, state.v[2].U16[4], state.v[5].U16[4], state.v[0].U16[4], 1, 1, 1, 1)
		VMADN_operation(5, state.v[2].U16[5], state.v[5].U16[5], state.v[0].U16[5], 1, 1, 1, 1)
		VMADN_operation(6, state.v[2].U16[6], state.v[5].U16[6], state.v[0].U16[6], 1, 1, 1, 1)
		VMADN_operation(7, state.v[2].U16[7], state.v[5].U16[7], state.v[0].U16[7], 1, 1, 1, 1)
	}


_04001968:	// 4001968: <e9a31800>	SDV       [T5 + 0x00] = vec03 <00>
	{
		_u32	addr = (0x00000000 + state.r[T5]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[3].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[3].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[3].U32[0x00000003];
		}
	}


_0400196C:	// 400196c: <03c00008>	JR        S8
	{
		_u32	temp = ((state.r[S8] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		{
			_u32	addr = (0x00000008 + state.r[T5]);

			if( addr & 3 )
			{
				Save64_DMEM(state.v[2].U64[0x00000001], addr);
			}
			else
			{
				addr &= 0xfff;
				*(_u32 *)&pDMEM[addr+4] = state.v[2].U32[0x00000002];
				*(_u32 *)&pDMEM[addr  ] = state.v[2].U32[0x00000003];
			}
		}
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001970:	// 4001970: <e9a21801>	SDV       [T5 + 0x04] = vec02 <00>
	{
		_u32	addr = (0x00000008 + state.r[T5]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[2].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[2].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[2].U32[0x00000003];
		}
	}


_04001974:	// 4001974: <340f0bc0>	ORI       T7 = R0 | 0x0bc0
	state.r[T7] = (0 | 0x00000BC0);


_04001978:	// 4001978: <34080001>	ORI       T0 = R0 | 0x0001
	state.r[T0] = (0 | 0x00000001);


_0400197C:	// 400197c: <48880800>	MTC2      vec1 <00> = T0
	state.v[1].U16[7] = (_u16)state.r[T0];


_04001980:	// 4001980: <2408ffff>	ADDIU     T0 = R0 + ffff
	state.r[T0] = 0 + 0xFFFFFFFF;


_04001984:	// 4001984: <48880900>	MTC2      vec1 <02> = T0
	state.v[1].U16[6] = (_u16)state.r[T0];


_04001988:	// 4001988: <95eb0004>	LHU       T3 = [T7+0004]
	state.r[T3] = (_s32)(_u16)Load16_DMEM((state.r[T7] + 0x00000004) & 0xfff);


_0400198C:	// 400198c: <95ea000c>	LHU       T2 = [T7+000c]
	state.r[T2] = (_s32)(_u16)Load16_DMEM((state.r[T7] + 0x0000000C) & 0xfff);


_04001990:	// 4001990: <000b5c00>	SLL       T3 = T3 << 16
	state.r[T3] = ((_u32)state.r[T3] << 16);


_04001994:	// 4001994: <014b5025>	OR        T2 = T2 | T3
	state.r[T2] = (state.r[T2] | state.r[T3]);


_04001998:	// 4001998: <34058000>	ORI       A1 = R0 | 0x8000
	state.r[A1] = (0 | 0x00008000);


_0400199C:	// 400199c: <24068000>	ADDIU     A2 = R0 + 8000
	state.r[A2] = 0 + 0xFFFF8000;


_040019A0:	// 40019a0: <0145402a>	SLT ?-?
	if (state.r[T2] < state.r[A1])
	{
		state.r[T0] = 1;
	}
	else
	{
		state.r[T0] = 0;
	}


_040019A4:	// 40019a4: <15000002>	BNE       (R0!=T0) --> 19b0
	sp_reg_pc = 0x040019A4;
	if (state.r[T0] != 0)
	{
		if (state.r[T2] < state.r[A2])
		{
			state.r[T0] = 1;
		}
		else
		{
			state.r[T0] = 0;
		}
		goto _040019B0;
	}


_040019A8:	// 40019a8: <0146402a>	SLT ?-?
	if (state.r[T2] < state.r[A2])
	{
		state.r[T0] = 1;
	}
	else
	{
		state.r[T0] = 0;
	}


_040019AC:	// 40019ac: <340a7fff>	ORI       T2 = R0 | 0x7fff
	state.r[T2] = (0 | 0x00007FFF);


_040019B0:	// 40019b0: <11000002>	BEQ       (R0==T0) --> 19bc
	sp_reg_pc = 0x040019B0;
	if (state.r[T0] == 0)
	{
		goto _040019BC;
	}


_040019B4:	// 40019b4: <00000000>	NOP       


_040019B8:	// 40019b8: <240a8000>	ADDIU     T2 = R0 + 8000
	state.r[T2] = 0 + 0xFFFF8000;


_040019BC:	// 40019bc: <488a0f00>	MTC2      vec1 <14> = T2
	state.v[1].U16[0] = (_u16)state.r[T2];


_040019C0:	// 40019c0: <340c0bd0>	ORI       T4 = R0 | 0x0bd0
	state.r[T4] = (0 | 0x00000BD0);


_040019C4:	// 40019c4: <340d0300>	ORI       T5 = R0 | 0x0300
	state.r[T5] = (0 | 0x00000300);


_040019C8:	// 40019c8: <340e0480>	ORI       T6 = R0 | 0x0480
	state.r[T6] = (0 | 0x00000480);


_040019CC:	// 40019cc: <4be10194>	VADDC	vec06 = vec00 + vec01[7]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[1].U16[0];
		VADDC_operation(0, state.v[6].U16[0], state.v[0].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[6].U16[1], state.v[0].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[6].U16[2], state.v[0].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[6].U16[3], state.v[0].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[6].U16[4], state.v[0].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[6].U16[5], state.v[0].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[6].U16[6], state.v[0].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[6].U16[7], state.v[0].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_040019D0:	// 40019d0: <34050018>	ORI       A1 = R0 | 0x0018
	state.r[A1] = (0 | 0x00000018);


_040019D4:	// 40019d4: <c9822000>	LQV       vec02 <00> = [T4 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[T4]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[2].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[2].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[2].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[2].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[2].U64[0] = state.v[2].U64[0] & ~temp1;
			state.v[2].U64[1] = state.v[2].U64[1] & ~temp2;
			state.v[2].U64[0] = state.v[2].U64[0] | value1;
			state.v[2].U64[1] = state.v[2].U64[1] | value2;
		}
	}


_040019D8:	// 40019d8: <4b011147>	VMUDH     vec05 = ( acc = (vec02 * vec01[0]) << 16) >> 16
	{
		_u16		s2value = state.v[1].U16[7];
		VMUDH_operation(0, state.v[5].U16[0], state.v[2].U16[0], s2value, 0, 1, 0, 1)
		VMUDH_operation(1, state.v[5].U16[1], state.v[2].U16[1], s2value, 0, 1, 0, 1)
		VMUDH_operation(2, state.v[5].U16[2], state.v[2].U16[2], s2value, 0, 1, 0, 1)
		VMUDH_operation(3, state.v[5].U16[3], state.v[2].U16[3], s2value, 0, 1, 0, 1)
		VMUDH_operation(4, state.v[5].U16[4], state.v[2].U16[4], s2value, 0, 1, 0, 1)
		VMUDH_operation(5, state.v[5].U16[5], state.v[2].U16[5], s2value, 0, 1, 0, 1)
		VMUDH_operation(6, state.v[5].U16[6], state.v[2].U16[6], s2value, 0, 1, 0, 1)
		VMUDH_operation(7, state.v[5].U16[7], state.v[2].U16[7], s2value, 0, 1, 0, 1)
	}


_040019DC:	// 40019dc: <258c0010>	ADDIU     T4 = T4 + 0010
	state.r[T4] = state.r[T4] + 0x0010;


_040019E0:	// 40019e0: <4b0130cf>	VMADH     vec03 = ( acc+= (vec06 * vec01[0]) << 16) >> 16
	{
		_u16		s2value = state.v[1].U16[7];
		VMADH_operation(0, state.v[3].U16[0], state.v[6].U16[0], s2value, 1, 0, 0, 1)
		VMADH_operation(1, state.v[3].U16[1], state.v[6].U16[1], s2value, 1, 0, 0, 1)
		VMADH_operation(2, state.v[3].U16[2], state.v[6].U16[2], s2value, 1, 0, 0, 1)
		VMADH_operation(3, state.v[3].U16[3], state.v[6].U16[3], s2value, 1, 0, 0, 1)
		VMADH_operation(4, state.v[3].U16[4], state.v[6].U16[4], s2value, 1, 0, 0, 1)
		VMADH_operation(5, state.v[3].U16[5], state.v[6].U16[5], s2value, 1, 0, 0, 1)
		VMADH_operation(6, state.v[3].U16[6], state.v[6].U16[6], s2value, 1, 0, 0, 1)
		VMADH_operation(7, state.v[3].U16[7], state.v[6].U16[7], s2value, 1, 0, 0, 1)
	}


_040019E4:	// 40019e4: <e980207f>	SQV       [T4 + 0xf0] = vec00 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[T4]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[0].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[0].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[0].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[0].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[0].U64[0] & temp1);
			value2 |= (state.v[0].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_040019E8:	// 40019e8: <4b211147>	VMUDH     vec05 = ( acc = (vec02 * vec01[1]) << 16) >> 16
	{
		_u16		s2value = state.v[1].U16[6];
		VMUDH_operation(0, state.v[5].U16[0], state.v[2].U16[0], s2value, 1, 1, 1, 1)
		VMUDH_operation(1, state.v[5].U16[1], state.v[2].U16[1], s2value, 1, 1, 1, 1)
		VMUDH_operation(2, state.v[5].U16[2], state.v[2].U16[2], s2value, 1, 1, 1, 1)
		VMUDH_operation(3, state.v[5].U16[3], state.v[2].U16[3], s2value, 1, 1, 1, 1)
		VMUDH_operation(4, state.v[5].U16[4], state.v[2].U16[4], s2value, 1, 1, 1, 1)
		VMUDH_operation(5, state.v[5].U16[5], state.v[2].U16[5], s2value, 1, 1, 1, 1)
		VMUDH_operation(6, state.v[5].U16[6], state.v[2].U16[6], s2value, 1, 1, 1, 1)
		VMUDH_operation(7, state.v[5].U16[7], state.v[2].U16[7], s2value, 1, 1, 1, 1)
	}


_040019EC:	// 40019ec: <25ad0010>	ADDIU     T5 = T5 + 0010
	state.r[T5] = state.r[T5] + 0x0010;


_040019F0:	// 40019f0: <4b21310f>	VMADH     vec04 = ( acc+= (vec06 * vec01[1]) << 16) >> 16
	{
		_u16		s2value = state.v[1].U16[6];
		VMADH_operation(0, state.v[4].U16[0], state.v[6].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[4].U16[1], state.v[6].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[4].U16[2], state.v[6].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[4].U16[3], state.v[6].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[4].U16[4], state.v[6].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[4].U16[5], state.v[6].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[4].U16[6], state.v[6].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[4].U16[7], state.v[6].U16[7], s2value, 1, 1, 0, 1)
	}


_040019F4:	// 40019f4: <25ce0010>	ADDIU     T6 = T6 + 0010
	state.r[T6] = state.r[T6] + 0x0010;


_040019F8:	// 40019f8: <e9a3207f>	SQV       [T5 + 0xf0] = vec03 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[T5]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[3].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[3].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[3].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[3].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[3].U64[0] & temp1);
			value2 |= (state.v[3].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_040019FC:	// 40019fc: <24a5ffff>	ADDIU     A1 = A1 + ffff
	state.r[A1] = state.r[A1] + 0xFFFFFFFF;


_04001A00:	// 4001a00: <14a0fff4>	BNE       (R0!=A1) --> 19d4
	sp_reg_pc = 0x04001A00;
	if (state.r[A1] != 0)
	{
		{
			_u32    addr = (0xFFFFFFF0 + state.r[T6]);
			int     shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				*(_u32 *)&pDMEM[addr+12] = state.v[4].U32[0];
				*(_u32 *)&pDMEM[addr+8 ] = state.v[4].U32[1];
				*(_u32 *)&pDMEM[addr+4 ] = state.v[4].U32[2];
				*(_u32 *)&pDMEM[addr   ] = state.v[4].U32[3];
			}
			else
			{
				_u64    value1 = Load64_DMEM(addr+8);
				_u64    value2 = Load64_DMEM(addr);
				_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & ~temp1;
				value2 = value2 & ~temp2;

				value1 |= (state.v[4].U64[0] & temp1);
				value2 |= (state.v[4].U64[1] & temp2);

				Save64_DMEM(value1, addr+8);
				Save64_DMEM(value2, addr  );
			}
		}
		goto _040019D4;
	}


_04001A04:	// 4001a04: <e9c4207f>	SQV       [T6 + 0xf0] = vec04 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[T6]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[4].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[4].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[4].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[4].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[4].U64[0] & temp1);
			value2 |= (state.v[4].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001A08:	// 4001a08: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001A0C:	// 4001a0c: <00000000>	NOP       


_04001A10:	// 4001a10: <256a0008>	ADDIU     T2 = T3 + 0008
	state.r[T2] = state.r[T3] + 0x0008;


_04001A14:	// 4001a14: <10a00004>	BEQ       (R0==A1) --> 1a28
	sp_reg_pc = 0x04001A14;
	if (state.r[A1] == 0)
	{
		state.r[T6] = (0 | 0x00000000);
		goto _04001A28;
	}


_04001A18:	// 4001a18: <340e0000>	ORI       T6 = R0 | 0x0000
	state.r[T6] = (0 | 0x00000000);


_04001A1C:	// 4001a1c: <254a0010>	ADDIU     T2 = T2 + 0010
	state.r[T2] = state.r[T2] + 0x0010;


_04001A20:	// 4001a20: <256b0004>	ADDIU     T3 = T3 + 0004
	state.r[T3] = state.r[T3] + 0x0004;


_04001A24:	// 4001a24: <340e0001>	ORI       T6 = R0 | 0x0001
	state.r[T6] = (0 | 0x00000001);


_04001A28:	// 4001a28: <4a01086c>	VXOR      vec01 = vec01 xor vec01[<none>]
	rsp_cop2_vxor(&state.v[1], &state.v[1], &state.v[1]);


_04001A2C:	// 4001a2c: <34050020>	ORI       A1 = R0 | 0x0020
	state.r[A1] = (0 | 0x00000020);


_04001A30:	// 4001a30: <4a0210ac>	VXOR      vec02 = vec02 xor vec02[<none>]
	rsp_cop2_vxor(&state.v[2], &state.v[2], &state.v[2]);


_04001A34:	// 4001a34: <34060800>	ORI       A2 = R0 | 0x0800
	state.r[A2] = (0 | 0x00000800);


_04001A38:	// 4001a38: <48859b00>	MTC2      vec19 <06> = A1
	state.v[19].U16[4] = (_u16)state.r[A1];


_04001A3C:	// 4001a3c: <48869c00>	MTC2      vec19 <08> = A2
	state.v[19].U16[3] = (_u16)state.r[A2];


_04001A40:	// 4001a40: <c8011804>	LDV       vec01 <00> = [R0 + 0x20]
	rsp_ldv_compiler((0 + 0x00000020) & 0xFFF, 1, 8);


_04001A44:	// 4001a44: <c8021c04>	LDV       vec02 <08> = [R0 + 0x20]
	rsp_ldv_compiler((0 + 0x00000020) & 0xFFF, 2, 0);


_04001A48:	// 4001a48: <c8032000>	LQV       vec03 <00> = [R0 + 0x00]
	{
		_u32 addr = (0x00000000 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[3].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[3].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[3].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[3].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[3].U64[0] = state.v[3].U64[0] & ~temp1;
			state.v[3].U64[1] = state.v[3].U64[1] & ~temp2;
			state.v[3].U64[0] = state.v[3].U64[0] | value1;
			state.v[3].U64[1] = state.v[3].U64[1] | value2;
		}
	}


_04001A4C:	// 4001a4c: <4a05296c>	VXOR      vec05 = vec05 xor vec05[<none>]
	rsp_cop2_vxor(&state.v[5], &state.v[5], &state.v[5]);


_04001A50:	// 4001a50: <c9541800>	LDV       vec20 <00> = [T2 + 0x00]
	rsp_ldv_compiler((state.r[T2] & 0xFFF), 20, 8);


_04001A54:	// 4001a54: <4a0631ac>	VXOR      vec06 = vec06 xor vec06[<none>]
	rsp_cop2_vxor(&state.v[6], &state.v[6], &state.v[6]);


_04001A58:	// 4001a58: <91460000>	LBU       A2 = [T2+0000]
	state.r[A2] = (_s32)(_u8)pDMEM[((state.r[T2] + 0x00000000) & 0xfff) ^ 3];


_04001A5C:	// 4001a5c: <4a0739ec>	VXOR      vec07 = vec07 xor vec07[<none>]
	rsp_cop2_vxor(&state.v[7], &state.v[7], &state.v[7]);


_04001A60:	// 4001a60: <c9731000>	LLV       vec19 <00> = [T3 + 0x00]
	state.v[19].U32[3] = Load32_DMEM(0x00000000 + state.r[T3]);


_04001A64:	// 4001a64: <4a08422c>	VXOR      vec08 = vec08 xor vec08[<none>]
	rsp_cop2_vxor(&state.v[8], &state.v[8], &state.v[8]);


_04001A68:	// 4001a68: <30c500f0>	ANDI      A1 = A2 & 00f0
	state.r[A1] = (state.r[A2] & 0x000000F0);


_04001A6C:	// 4001a6c: <4a094a6c>	VXOR      vec09 = vec09 xor vec09[<none>]
	rsp_cop2_vxor(&state.v[9], &state.v[9], &state.v[9]);


_04001A70:	// 4001a70: <00052840>	SLL       A1 = A1 << 1
	state.r[A1] = ((_u32)state.r[A1] << 1);


_04001A74:	// 4001a74: <4a0a52ac>	VXOR      vec10 = vec10 xor vec10[<none>]
	rsp_cop2_vxor(&state.v[10], &state.v[10], &state.v[10]);


_04001A78:	// 4001a78: <24ad0ee0>	ADDIU     T5 = A1 + 0ee0
	state.r[T5] = state.r[A1] + 0x0EE0;


_04001A7C:	// 4001a7c: <4a0b5aec>	VXOR      vec11 = vec11 xor vec11[<none>]
	rsp_cop2_vxor(&state.v[11], &state.v[11], &state.v[11]);


_04001A80:	// 4001a80: <4a0c632c>	VXOR      vec12 = vec12 xor vec12[<none>]
	rsp_cop2_vxor(&state.v[12], &state.v[12], &state.v[12]);


_04001A84:	// 4001a84: <4a0d6b6c>	VXOR      vec13 = vec13 xor vec13[<none>]
	rsp_cop2_vxor(&state.v[13], &state.v[13], &state.v[13]);


_04001A88:	// 4001a88: <4b140be8>	VAND      vec15 = vec01 and vec20[0]
	rsp_cop2_vand_element(&state.v[15], &state.v[1], &state.v[20].U16[7]);


_04001A8C:	// 4001a8c: <4b341428>	VAND      vec16 = vec02 and vec20[1]
	rsp_cop2_vand_element(&state.v[16], &state.v[2], &state.v[20].U16[6]);


_04001A90:	// 4001a90: <4b540c68>	VAND      vec17 = vec01 and vec20[2]
	rsp_cop2_vand_element(&state.v[17], &state.v[1], &state.v[20].U16[5]);


_04001A94:	// 4001a94: <4b7414a8>	VAND      vec18 = vec02 and vec20[3]
	rsp_cop2_vand_element(&state.v[18], &state.v[2], &state.v[20].U16[4]);


_04001A98:	// 4001a98: <4a037bc6>	VMUDN     vec15 = ( acc = vec15 * vec03[<none>]      ) >> 16
	{
		VMUDN_operation(0, state.v[15].U16[0], state.v[15].U16[0], state.v[3].U16[0], 0, 1, 1, 1)
		VMUDN_operation(1, state.v[15].U16[1], state.v[15].U16[1], state.v[3].U16[1], 0, 1, 1, 1)
		VMUDN_operation(2, state.v[15].U16[2], state.v[15].U16[2], state.v[3].U16[2], 0, 1, 1, 1)
		VMUDN_operation(3, state.v[15].U16[3], state.v[15].U16[3], state.v[3].U16[3], 0, 1, 1, 1)
		VMUDN_operation(4, state.v[15].U16[4], state.v[15].U16[4], state.v[3].U16[4], 0, 1, 1, 1)
		VMUDN_operation(5, state.v[15].U16[5], state.v[15].U16[5], state.v[3].U16[5], 0, 1, 1, 1)
		VMUDN_operation(6, state.v[15].U16[6], state.v[15].U16[6], state.v[3].U16[6], 0, 1, 1, 1)
		VMUDN_operation(7, state.v[15].U16[7], state.v[15].U16[7], state.v[3].U16[7], 0, 1, 1, 1)
	}


_04001A9C:	// 4001a9c: <c9541801>	LDV       vec20 <00> = [T2 + 0x08]
	rsp_ldv_compiler((state.r[T2] + 0x00000008) & 0xFFF, 20, 8);


_04001AA0:	// 4001aa0: <4a0385ce>	VMADN     vec23 = ( acc+= vec16 * vec03[<none>] )
	{
		VMADN_operation(0, state.v[23].U16[0], state.v[16].U16[0], state.v[3].U16[0], 1, 0, 0, 1)
		VMADN_operation(1, state.v[23].U16[1], state.v[16].U16[1], state.v[3].U16[1], 1, 0, 0, 1)
		VMADN_operation(2, state.v[23].U16[2], state.v[16].U16[2], state.v[3].U16[2], 1, 0, 0, 1)
		VMADN_operation(3, state.v[23].U16[3], state.v[16].U16[3], state.v[3].U16[3], 1, 0, 0, 1)
		VMADN_operation(4, state.v[23].U16[4], state.v[16].U16[4], state.v[3].U16[4], 1, 0, 0, 1)
		VMADN_operation(5, state.v[23].U16[5], state.v[16].U16[5], state.v[3].U16[5], 1, 0, 0, 1)
		VMADN_operation(6, state.v[23].U16[6], state.v[16].U16[6], state.v[3].U16[6], 1, 0, 0, 1)
		VMADN_operation(7, state.v[23].U16[7], state.v[16].U16[7], state.v[3].U16[7], 1, 0, 0, 1)
	}


_04001AA4:	// 4001aa4: <4a038c46>	VMUDN     vec17 = ( acc = vec17 * vec03[<none>]      ) >> 16
	{
		VMUDN_operation(0, state.v[17].U16[0], state.v[17].U16[0], state.v[3].U16[0], 0, 1, 1, 1)
		VMUDN_operation(1, state.v[17].U16[1], state.v[17].U16[1], state.v[3].U16[1], 0, 1, 1, 1)
		VMUDN_operation(2, state.v[17].U16[2], state.v[17].U16[2], state.v[3].U16[2], 0, 1, 1, 1)
		VMUDN_operation(3, state.v[17].U16[3], state.v[17].U16[3], state.v[3].U16[3], 0, 1, 1, 1)
		VMUDN_operation(4, state.v[17].U16[4], state.v[17].U16[4], state.v[3].U16[4], 0, 1, 1, 1)
		VMUDN_operation(5, state.v[17].U16[5], state.v[17].U16[5], state.v[3].U16[5], 0, 1, 1, 1)
		VMUDN_operation(6, state.v[17].U16[6], state.v[17].U16[6], state.v[3].U16[6], 0, 1, 1, 1)
		VMUDN_operation(7, state.v[17].U16[7], state.v[17].U16[7], state.v[3].U16[7], 0, 1, 1, 1)
	}


_04001AA8:	// 4001aa8: <4a03960e>	VMADN     vec24 = ( acc+= vec18 * vec03[<none>] )
	{
		VMADN_operation(0, state.v[24].U16[0], state.v[18].U16[0], state.v[3].U16[0], 1, 0, 0, 1)
		VMADN_operation(1, state.v[24].U16[1], state.v[18].U16[1], state.v[3].U16[1], 1, 0, 0, 1)
		VMADN_operation(2, state.v[24].U16[2], state.v[18].U16[2], state.v[3].U16[2], 1, 0, 0, 1)
		VMADN_operation(3, state.v[24].U16[3], state.v[18].U16[3], state.v[3].U16[3], 1, 0, 0, 1)
		VMADN_operation(4, state.v[24].U16[4], state.v[18].U16[4], state.v[3].U16[4], 1, 0, 0, 1)
		VMADN_operation(5, state.v[24].U16[5], state.v[18].U16[5], state.v[3].U16[5], 1, 0, 0, 1)
		VMADN_operation(6, state.v[24].U16[6], state.v[18].U16[6], state.v[3].U16[6], 1, 0, 0, 1)
		VMADN_operation(7, state.v[24].U16[7], state.v[18].U16[7], state.v[3].U16[7], 1, 0, 0, 1)
	}


_04001AAC:	// 4001aac: <4b140be8>	VAND      vec15 = vec01 and vec20[0]
	rsp_cop2_vand_element(&state.v[15], &state.v[1], &state.v[20].U16[7]);


_04001AB0:	// 4001ab0: <30c6000f>	ANDI      A2 = A2 & 000f
	state.r[A2] = (state.r[A2] & 0x0000000F);


_04001AB4:	// 4001ab4: <4b341428>	VAND      vec16 = vec02 and vec20[1]
	rsp_cop2_vand_element(&state.v[16], &state.v[2], &state.v[20].U16[6]);


_04001AB8:	// 4001ab8: <24c6ffff>	ADDIU     A2 = A2 + ffff
	state.r[A2] = state.r[A2] + 0xFFFFFFFF;


_04001ABC:	// 4001abc: <4b540c68>	VAND      vec17 = vec01 and vec20[2]
	rsp_cop2_vand_element(&state.v[17], &state.v[1], &state.v[20].U16[5]);


_04001AC0:	// 4001ac0: <34058000>	ORI       A1 = R0 | 0x8000
	state.r[A1] = (0 | 0x00008000);


_04001AC4:	// 4001ac4: <4b7414a8>	VAND      vec18 = vec02 and vec20[3]
	rsp_cop2_vand_element(&state.v[18], &state.v[2], &state.v[20].U16[4]);


_04001AC8:	// 4001ac8: <00c52806>	SRLV      A1 = A1 >> A2
	state.r[A1] = ((_u32)state.r[A1] >> (state.r[A2] & 0x1F));


_04001ACC:	// 4001acc: <4a037bc6>	VMUDN     vec15 = ( acc = vec15 * vec03[<none>]      ) >> 16
	{
		VMUDN_operation(0, state.v[15].U16[0], state.v[15].U16[0], state.v[3].U16[0], 1, 1, 1, 1)
		VMUDN_operation(1, state.v[15].U16[1], state.v[15].U16[1], state.v[3].U16[1], 1, 1, 1, 1)
		VMUDN_operation(2, state.v[15].U16[2], state.v[15].U16[2], state.v[3].U16[2], 1, 1, 1, 1)
		VMUDN_operation(3, state.v[15].U16[3], state.v[15].U16[3], state.v[3].U16[3], 1, 1, 1, 1)
		VMUDN_operation(4, state.v[15].U16[4], state.v[15].U16[4], state.v[3].U16[4], 1, 1, 1, 1)
		VMUDN_operation(5, state.v[15].U16[5], state.v[15].U16[5], state.v[3].U16[5], 1, 1, 1, 1)
		VMUDN_operation(6, state.v[15].U16[6], state.v[15].U16[6], state.v[3].U16[6], 1, 1, 1, 1)
		VMUDN_operation(7, state.v[15].U16[7], state.v[15].U16[7], state.v[3].U16[7], 1, 1, 1, 1)
	}


_04001AD0:	// 4001ad0: <48859a00>	MTC2      vec19 <04> = A1
	state.v[19].U16[5] = (_u16)state.r[A1];


_04001AD4:	// 4001ad4: <4a03864e>	VMADN     vec25 = ( acc+= vec16 * vec03[<none>] )
	{
		VMADN_operation(0, state.v[25].U16[0], state.v[16].U16[0], state.v[3].U16[0], 1, 0, 0, 1)
		VMADN_operation(1, state.v[25].U16[1], state.v[16].U16[1], state.v[3].U16[1], 1, 0, 0, 1)
		VMADN_operation(2, state.v[25].U16[2], state.v[16].U16[2], state.v[3].U16[2], 1, 0, 0, 1)
		VMADN_operation(3, state.v[25].U16[3], state.v[16].U16[3], state.v[3].U16[3], 1, 0, 0, 1)
		VMADN_operation(4, state.v[25].U16[4], state.v[16].U16[4], state.v[3].U16[4], 1, 0, 0, 1)
		VMADN_operation(5, state.v[25].U16[5], state.v[16].U16[5], state.v[3].U16[5], 1, 0, 0, 1)
		VMADN_operation(6, state.v[25].U16[6], state.v[16].U16[6], state.v[3].U16[6], 1, 0, 0, 1)
		VMADN_operation(7, state.v[25].U16[7], state.v[16].U16[7], state.v[3].U16[7], 1, 0, 0, 1)
	}


_04001AD8:	// 4001ad8: <4a038c46>	VMUDN     vec17 = ( acc = vec17 * vec03[<none>]      ) >> 16
	{
		VMUDN_operation(0, state.v[17].U16[0], state.v[17].U16[0], state.v[3].U16[0], 1, 1, 1, 1)
		VMUDN_operation(1, state.v[17].U16[1], state.v[17].U16[1], state.v[3].U16[1], 1, 1, 1, 1)
		VMUDN_operation(2, state.v[17].U16[2], state.v[17].U16[2], state.v[3].U16[2], 1, 1, 1, 1)
		VMUDN_operation(3, state.v[17].U16[3], state.v[17].U16[3], state.v[3].U16[3], 1, 1, 1, 1)
		VMUDN_operation(4, state.v[17].U16[4], state.v[17].U16[4], state.v[3].U16[4], 1, 1, 1, 1)
		VMUDN_operation(5, state.v[17].U16[5], state.v[17].U16[5], state.v[3].U16[5], 1, 1, 1, 1)
		VMUDN_operation(6, state.v[17].U16[6], state.v[17].U16[6], state.v[3].U16[6], 1, 1, 1, 1)
		VMUDN_operation(7, state.v[17].U16[7], state.v[17].U16[7], state.v[3].U16[7], 1, 1, 1, 1)
	}


_04001ADC:	// 4001adc: <04c00005>	BLTZ ?-?
	sp_reg_pc = 0x04001ADC;
	if (state.r[A2] < 0)
	{
		{
			VMADN_operation(0, state.v[26].U16[0], state.v[18].U16[0], state.v[3].U16[0], 1, 1, 1, 1)
			VMADN_operation(1, state.v[26].U16[1], state.v[18].U16[1], state.v[3].U16[1], 1, 1, 1, 1)
			VMADN_operation(2, state.v[26].U16[2], state.v[18].U16[2], state.v[3].U16[2], 1, 1, 1, 1)
			VMADN_operation(3, state.v[26].U16[3], state.v[18].U16[3], state.v[3].U16[3], 1, 1, 1, 1)
			VMADN_operation(4, state.v[26].U16[4], state.v[18].U16[4], state.v[3].U16[4], 1, 1, 1, 1)
			VMADN_operation(5, state.v[26].U16[5], state.v[18].U16[5], state.v[3].U16[5], 1, 1, 1, 1)
			VMADN_operation(6, state.v[26].U16[6], state.v[18].U16[6], state.v[3].U16[6], 1, 1, 1, 1)
			VMADN_operation(7, state.v[26].U16[7], state.v[18].U16[7], state.v[3].U16[7], 1, 1, 1, 1)
		}
		goto _04001AF4;
	}


_04001AE0:	// 4001ae0: <4a03968e>	VMADN     vec26 = ( acc+= vec18 * vec03[<none>] )
	{
		VMADN_operation(0, state.v[26].U16[0], state.v[18].U16[0], state.v[3].U16[0], 1, 0, 0, 1)
		VMADN_operation(1, state.v[26].U16[1], state.v[18].U16[1], state.v[3].U16[1], 1, 0, 0, 1)
		VMADN_operation(2, state.v[26].U16[2], state.v[18].U16[2], state.v[3].U16[2], 1, 0, 0, 1)
		VMADN_operation(3, state.v[26].U16[3], state.v[18].U16[3], state.v[3].U16[3], 1, 0, 0, 1)
		VMADN_operation(4, state.v[26].U16[4], state.v[18].U16[4], state.v[3].U16[4], 1, 0, 0, 1)
		VMADN_operation(5, state.v[26].U16[5], state.v[18].U16[5], state.v[3].U16[5], 1, 0, 0, 1)
		VMADN_operation(6, state.v[26].U16[6], state.v[18].U16[6], state.v[3].U16[6], 1, 0, 0, 1)
		VMADN_operation(7, state.v[26].U16[7], state.v[18].U16[7], state.v[3].U16[7], 1, 0, 0, 1)
	}


_04001AE4:	// 4001ae4: <4b53bdc5>	VMUDM     vec23 = ( acc = vec23 * vec19[2] ) >> 16
	{
		_u16		s2value = state.v[19].U16[5];
		VMUDM_operation(0, state.v[23].U16[0], state.v[23].U16[0], s2value, 1, 0, 0, 1)
		VMUDM_operation(1, state.v[23].U16[1], state.v[23].U16[1], s2value, 1, 0, 0, 1)
		VMUDM_operation(2, state.v[23].U16[2], state.v[23].U16[2], s2value, 1, 0, 0, 1)
		VMUDM_operation(3, state.v[23].U16[3], state.v[23].U16[3], s2value, 1, 0, 0, 1)
		VMUDM_operation(4, state.v[23].U16[4], state.v[23].U16[4], s2value, 1, 0, 0, 1)
		VMUDM_operation(5, state.v[23].U16[5], state.v[23].U16[5], s2value, 1, 0, 0, 1)
		VMUDM_operation(6, state.v[23].U16[6], state.v[23].U16[6], s2value, 1, 0, 0, 1)
		VMUDM_operation(7, state.v[23].U16[7], state.v[23].U16[7], s2value, 1, 0, 0, 1)
	}


_04001AE8:	// 4001ae8: <4b53c605>	VMUDM     vec24 = ( acc = vec24 * vec19[2] ) >> 16
	{
		_u16		s2value = state.v[19].U16[5];
		VMUDM_operation(0, state.v[24].U16[0], state.v[24].U16[0], s2value, 1, 0, 0, 1)
		VMUDM_operation(1, state.v[24].U16[1], state.v[24].U16[1], s2value, 1, 0, 0, 1)
		VMUDM_operation(2, state.v[24].U16[2], state.v[24].U16[2], s2value, 1, 0, 0, 1)
		VMUDM_operation(3, state.v[24].U16[3], state.v[24].U16[3], s2value, 1, 0, 0, 1)
		VMUDM_operation(4, state.v[24].U16[4], state.v[24].U16[4], s2value, 1, 0, 0, 1)
		VMUDM_operation(5, state.v[24].U16[5], state.v[24].U16[5], s2value, 1, 0, 0, 1)
		VMUDM_operation(6, state.v[24].U16[6], state.v[24].U16[6], s2value, 1, 0, 0, 1)
		VMUDM_operation(7, state.v[24].U16[7], state.v[24].U16[7], s2value, 1, 0, 0, 1)
	}


_04001AEC:	// 4001aec: <4b53ce45>	VMUDM     vec25 = ( acc = vec25 * vec19[2] ) >> 16
	{
		_u16		s2value = state.v[19].U16[5];
		VMUDM_operation(0, state.v[25].U16[0], state.v[25].U16[0], s2value, 1, 0, 0, 1)
		VMUDM_operation(1, state.v[25].U16[1], state.v[25].U16[1], s2value, 1, 0, 0, 1)
		VMUDM_operation(2, state.v[25].U16[2], state.v[25].U16[2], s2value, 1, 0, 0, 1)
		VMUDM_operation(3, state.v[25].U16[3], state.v[25].U16[3], s2value, 1, 0, 0, 1)
		VMUDM_operation(4, state.v[25].U16[4], state.v[25].U16[4], s2value, 1, 0, 0, 1)
		VMUDM_operation(5, state.v[25].U16[5], state.v[25].U16[5], s2value, 1, 0, 0, 1)
		VMUDM_operation(6, state.v[25].U16[6], state.v[25].U16[6], s2value, 1, 0, 0, 1)
		VMUDM_operation(7, state.v[25].U16[7], state.v[25].U16[7], s2value, 1, 0, 0, 1)
	}


_04001AF0:	// 4001af0: <4b53d685>	VMUDM     vec26 = ( acc = vec26 * vec19[2] ) >> 16
	{
		_u16		s2value = state.v[19].U16[5];
		VMUDM_operation(0, state.v[26].U16[0], state.v[26].U16[0], s2value, 1, 0, 0, 1)
		VMUDM_operation(1, state.v[26].U16[1], state.v[26].U16[1], s2value, 1, 0, 0, 1)
		VMUDM_operation(2, state.v[26].U16[2], state.v[26].U16[2], s2value, 1, 0, 0, 1)
		VMUDM_operation(3, state.v[26].U16[3], state.v[26].U16[3], s2value, 1, 0, 0, 1)
		VMUDM_operation(4, state.v[26].U16[4], state.v[26].U16[4], s2value, 1, 0, 0, 1)
		VMUDM_operation(5, state.v[26].U16[5], state.v[26].U16[5], s2value, 1, 0, 0, 1)
		VMUDM_operation(6, state.v[26].U16[6], state.v[26].U16[6], s2value, 1, 0, 0, 1)
		VMUDM_operation(7, state.v[26].U16[7], state.v[26].U16[7], s2value, 1, 0, 0, 1)
	}


_04001AF4:	// 4001af4: <25a5fffc>	ADDIU     A1 = T5 + fffc
	state.r[A1] = state.r[T5] + 0xFFFFFFFC;


_04001AF8:	// 4001af8: <c8a52801>	LRV       vec05 <00> = [A1 + 0x10]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000010 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[5].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001AFC:	// 4001afc: <4b934173>	VMOV      vec05[0] = vec19[4]
	state.v[5].U16[7] = state.v[19].U16[3];


_04001B00:	// 4001b00: <c8a62802>	LRV       vec06 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[6].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001B04:	// 4001b04: <4b9349b3>	VMOV      vec06[1] = vec19[4]
	state.v[6].U16[6] = state.v[19].U16[3];


_04001B08:	// 4001b08: <24a5fffe>	ADDIU     A1 = A1 + fffe
	state.r[A1] = state.r[A1] + 0xFFFFFFFE;


_04001B0C:	// 4001b0c: <c8a72802>	LRV       vec07 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[7].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001B10:	// 4001b10: <4b9351f3>	VMOV      vec07[2] = vec19[4]
	state.v[7].U16[5] = state.v[19].U16[3];


_04001B14:	// 4001b14: <24a5fffe>	ADDIU     A1 = A1 + fffe
	state.r[A1] = state.r[A1] + 0xFFFFFFFE;


_04001B18:	// 4001b18: <c8a82802>	LRV       vec08 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[8].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001B1C:	// 4001b1c: <4b935a33>	VMOV      vec08[3] = vec19[4]
	state.v[8].U16[4] = state.v[19].U16[3];


_04001B20:	// 4001b20: <24a5fffe>	ADDIU     A1 = A1 + fffe
	state.r[A1] = state.r[A1] + 0xFFFFFFFE;


_04001B24:	// 4001b24: <c8a92802>	LRV       vec09 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[9].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001B28:	// 4001b28: <4b936273>	VMOV      vec09[4] = vec19[4]
	state.v[9].U16[3] = state.v[19].U16[3];


_04001B2C:	// 4001b2c: <24a5fffe>	ADDIU     A1 = A1 + fffe
	state.r[A1] = state.r[A1] + 0xFFFFFFFE;


_04001B30:	// 4001b30: <c8aa2802>	LRV       vec10 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[10].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001B34:	// 4001b34: <4b936ab3>	VMOV      vec10[5] = vec19[4]
	state.v[10].U16[2] = state.v[19].U16[3];


_04001B38:	// 4001b38: <24a5fffe>	ADDIU     A1 = A1 + fffe
	state.r[A1] = state.r[A1] + 0xFFFFFFFE;


_04001B3C:	// 4001b3c: <c8ab2802>	LRV       vec11 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[11].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001B40:	// 4001b40: <4b9372f3>	VMOV      vec11[6] = vec19[4]
	state.v[11].U16[1] = state.v[19].U16[3];


_04001B44:	// 4001b44: <4b937b33>	VMOV      vec12[7] = vec19[4]
	state.v[12].U16[0] = state.v[19].U16[3];


_04001B48:	// 4001b48: <4b132bc7>	VMUDH     vec15 = ( acc = (vec05 * vec19[0]) << 16) >> 16
	{
		_u16		s2value = state.v[19].U16[7];
		VMUDH_operation(0, state.v[15].U16[0], state.v[5].U16[0], s2value, 0, 1, 0, 1)
		VMUDH_operation(1, state.v[15].U16[1], state.v[5].U16[1], s2value, 0, 1, 0, 1)
		VMUDH_operation(2, state.v[15].U16[2], state.v[5].U16[2], s2value, 0, 1, 0, 1)
		VMUDH_operation(3, state.v[15].U16[3], state.v[5].U16[3], s2value, 0, 1, 0, 1)
		VMUDH_operation(4, state.v[15].U16[4], state.v[5].U16[4], s2value, 0, 1, 0, 1)
		VMUDH_operation(5, state.v[15].U16[5], state.v[5].U16[5], s2value, 0, 1, 0, 1)
		VMUDH_operation(6, state.v[15].U16[6], state.v[5].U16[6], s2value, 0, 1, 0, 1)
		VMUDH_operation(7, state.v[15].U16[7], state.v[5].U16[7], s2value, 0, 1, 0, 1)
	}


_04001B4C:	// 4001b4c: <25a5fffe>	ADDIU     A1 = T5 + fffe
	state.r[A1] = state.r[T5] + 0xFFFFFFFE;


_04001B50:	// 4001b50: <4b3333cf>	VMADH     vec15 = ( acc+= (vec06 * vec19[1]) << 16) >> 16
	{
		_u16		s2value = state.v[19].U16[6];
		VMADH_operation(0, state.v[15].U16[0], state.v[6].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[6].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[6].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[6].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[6].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[6].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[6].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[6].U16[7], s2value, 0, 1, 0, 1)
	}


_04001B54:	// 4001b54: <c9a52000>	LQV       vec05 <00> = [T5 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[T5]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[5].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[5].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[5].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[5].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[5].U64[0] = state.v[5].U64[0] & ~temp1;
			state.v[5].U64[1] = state.v[5].U64[1] & ~temp2;
			state.v[5].U64[0] = state.v[5].U64[0] | value1;
			state.v[5].U64[1] = state.v[5].U64[1] | value2;
		}
	}


_04001B58:	// 4001b58: <4b573bcf>	VMADH     vec15 = ( acc+= (vec07 * vec23[2]) << 16) >> 16
	{
		_u16		s2value = state.v[23].U16[5];
		VMADH_operation(0, state.v[15].U16[0], state.v[7].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[7].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[7].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[7].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[7].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[7].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[7].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[7].U16[7], s2value, 0, 1, 0, 1)
	}


_04001B5C:	// 4001b5c: <c9a62001>	LQV       vec06 <00> = [T5 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[T5]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[6].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[6].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[6].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[6].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[6].U64[0] = state.v[6].U64[0] & ~temp1;
			state.v[6].U64[1] = state.v[6].U64[1] & ~temp2;
			state.v[6].U64[0] = state.v[6].U64[0] | value1;
			state.v[6].U64[1] = state.v[6].U64[1] | value2;
		}
	}


_04001B60:	// 4001b60: <4b7743cf>	VMADH     vec15 = ( acc+= (vec08 * vec23[3]) << 16) >> 16
	{
		_u16		s2value = state.v[23].U16[4];
		VMADH_operation(0, state.v[15].U16[0], state.v[8].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[8].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[8].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[8].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[8].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[8].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[8].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[8].U16[7], s2value, 0, 1, 0, 1)
	}


_04001B64:	// 4001b64: <c8a72802>	LRV       vec07 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[7].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001B68:	// 4001b68: <4b974bcf>	VMADH     vec15 = ( acc+= (vec09 * vec23[4]) << 16) >> 16
	{
		_u16		s2value = state.v[23].U16[3];
		VMADH_operation(0, state.v[15].U16[0], state.v[9].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[9].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[9].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[9].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[9].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[9].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[9].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[9].U16[7], s2value, 0, 1, 0, 1)
	}


_04001B6C:	// 4001b6c: <24a5fffe>	ADDIU     A1 = A1 + fffe
	state.r[A1] = state.r[A1] + 0xFFFFFFFE;


_04001B70:	// 4001b70: <4bb753cf>	VMADH     vec15 = ( acc+= (vec10 * vec23[5]) << 16) >> 16
	{
		_u16		s2value = state.v[23].U16[2];
		VMADH_operation(0, state.v[15].U16[0], state.v[10].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[10].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[10].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[10].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[10].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[10].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[10].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[10].U16[7], s2value, 0, 1, 0, 1)
	}


_04001B74:	// 4001b74: <c8a82802>	LRV       vec08 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[8].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001B78:	// 4001b78: <4bd75bcf>	VMADH     vec15 = ( acc+= (vec11 * vec23[6]) << 16) >> 16
	{
		_u16		s2value = state.v[23].U16[1];
		VMADH_operation(0, state.v[15].U16[0], state.v[11].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[11].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[11].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[11].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[11].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[11].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[11].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[11].U16[7], s2value, 0, 1, 0, 1)
	}


_04001B7C:	// 4001b7c: <24a5fffe>	ADDIU     A1 = A1 + fffe
	state.r[A1] = state.r[A1] + 0xFFFFFFFE;


_04001B80:	// 4001b80: <4bf763cf>	VMADH     vec15 = ( acc+= (vec12 * vec23[7]) << 16) >> 16
	{
		_u16		s2value = state.v[23].U16[0];
		VMADH_operation(0, state.v[15].U16[0], state.v[12].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[12].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[12].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[12].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[12].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[12].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[12].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[12].U16[7], s2value, 0, 1, 0, 1)
	}


_04001B84:	// 4001b84: <c8a92802>	LRV       vec09 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[9].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001B88:	// 4001b88: <4b357c1d>	VSAW $v16, $v15, $v21[[1]]
	state.v[16].U16[0] = state.accum[0].U16[2];
	state.v[16].U16[1] = state.accum[1].U16[2];
	state.v[16].U16[2] = state.accum[2].U16[2];
	state.v[16].U16[3] = state.accum[3].U16[2];
	state.v[16].U16[4] = state.accum[4].U16[2];
	state.v[16].U16[5] = state.accum[5].U16[2];
	state.v[16].U16[6] = state.accum[6].U16[2];
	state.v[16].U16[7] = state.accum[7].U16[2];


_04001B8C:	// 4001b8c: <24a5fffe>	ADDIU     A1 = A1 + fffe
	state.r[A1] = state.r[A1] + 0xFFFFFFFE;


_04001B90:	// 4001b90: <4b157d5d>	VSAW $v21, $v15, $v21[[0]]
	state.v[21].U16[0] = state.accum[0].U16[3];
	state.v[21].U16[1] = state.accum[1].U16[3];
	state.v[21].U16[2] = state.accum[2].U16[3];
	state.v[21].U16[3] = state.accum[3].U16[3];
	state.v[21].U16[4] = state.accum[4].U16[3];
	state.v[21].U16[5] = state.accum[5].U16[3];
	state.v[21].U16[6] = state.accum[6].U16[3];
	state.v[21].U16[7] = state.accum[7].U16[3];


_04001B94:	// 4001b94: <c8aa2802>	LRV       vec10 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[10].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001B98:	// 4001b98: <4b738406>	VMUDN     vec16 = ( acc = vec16 * vec19[3]      ) >> 16
	{
		_u16		s2value = state.v[19].U16[4];
		VMUDN_operation(0, state.v[16].U16[0], state.v[16].U16[0], s2value, 0, 1, 0, 1)
		VMUDN_operation(1, state.v[16].U16[1], state.v[16].U16[1], s2value, 0, 1, 0, 1)
		VMUDN_operation(2, state.v[16].U16[2], state.v[16].U16[2], s2value, 0, 1, 0, 1)
		VMUDN_operation(3, state.v[16].U16[3], state.v[16].U16[3], s2value, 0, 1, 0, 1)
		VMUDN_operation(4, state.v[16].U16[4], state.v[16].U16[4], s2value, 0, 1, 0, 1)
		VMUDN_operation(5, state.v[16].U16[5], state.v[16].U16[5], s2value, 0, 1, 0, 1)
		VMUDN_operation(6, state.v[16].U16[6], state.v[16].U16[6], s2value, 0, 1, 0, 1)
		VMUDN_operation(7, state.v[16].U16[7], state.v[16].U16[7], s2value, 0, 1, 0, 1)
	}


_04001B9C:	// 4001b9c: <24a5fffe>	ADDIU     A1 = A1 + fffe
	state.r[A1] = state.r[A1] + 0xFFFFFFFE;


_04001BA0:	// 4001ba0: <4b73ad4f>	VMADH     vec21 = ( acc+= (vec21 * vec19[3]) << 16) >> 16
	{
		_u16		s2value = state.v[19].U16[4];
		VMADH_operation(0, state.v[21].U16[0], state.v[21].U16[0], s2value, 1, 0, 0, 1)
		VMADH_operation(1, state.v[21].U16[1], state.v[21].U16[1], s2value, 1, 0, 0, 1)
		VMADH_operation(2, state.v[21].U16[2], state.v[21].U16[2], s2value, 1, 0, 0, 1)
		VMADH_operation(3, state.v[21].U16[3], state.v[21].U16[3], s2value, 1, 0, 0, 1)
		VMADH_operation(4, state.v[21].U16[4], state.v[21].U16[4], s2value, 1, 0, 0, 1)
		VMADH_operation(5, state.v[21].U16[5], state.v[21].U16[5], s2value, 1, 0, 0, 1)
		VMADH_operation(6, state.v[21].U16[6], state.v[21].U16[6], s2value, 1, 0, 0, 1)
		VMADH_operation(7, state.v[21].U16[7], state.v[21].U16[7], s2value, 1, 0, 0, 1)
	}


_04001BA4:	// 4001ba4: <c8ab2802>	LRV       vec11 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[11].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001BA8:	// 4001ba8: <4bd52bc7>	VMUDH     vec15 = ( acc = (vec05 * vec21[6]) << 16) >> 16
	{
		_u16		s2value = state.v[21].U16[1];
		VMUDH_operation(0, state.v[15].U16[0], state.v[5].U16[0], s2value, 0, 1, 0, 1)
		VMUDH_operation(1, state.v[15].U16[1], state.v[5].U16[1], s2value, 0, 1, 0, 1)
		VMUDH_operation(2, state.v[15].U16[2], state.v[5].U16[2], s2value, 0, 1, 0, 1)
		VMUDH_operation(3, state.v[15].U16[3], state.v[5].U16[3], s2value, 0, 1, 0, 1)
		VMUDH_operation(4, state.v[15].U16[4], state.v[5].U16[4], s2value, 0, 1, 0, 1)
		VMUDH_operation(5, state.v[15].U16[5], state.v[5].U16[5], s2value, 0, 1, 0, 1)
		VMUDH_operation(6, state.v[15].U16[6], state.v[5].U16[6], s2value, 0, 1, 0, 1)
		VMUDH_operation(7, state.v[15].U16[7], state.v[5].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BAC:	// 4001bac: <24a5fffe>	ADDIU     A1 = A1 + fffe
	state.r[A1] = state.r[A1] + 0xFFFFFFFE;


_04001BB0:	// 4001bb0: <4bf533cf>	VMADH     vec15 = ( acc+= (vec06 * vec21[7]) << 16) >> 16
	{
		_u16		s2value = state.v[21].U16[0];
		VMADH_operation(0, state.v[15].U16[0], state.v[6].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[6].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[6].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[6].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[6].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[6].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[6].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[6].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BB4:	// 4001bb4: <c8ac2802>	LRV       vec12 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[12].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001BB8:	// 4001bb8: <4b183bcf>	VMADH     vec15 = ( acc+= (vec07 * vec24[0]) << 16) >> 16
	{
		_u16		s2value = state.v[24].U16[7];
		VMADH_operation(0, state.v[15].U16[0], state.v[7].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[7].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[7].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[7].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[7].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[7].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[7].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[7].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BBC:	// 4001bbc: <24a5fffe>	ADDIU     A1 = A1 + fffe
	state.r[A1] = state.r[A1] + 0xFFFFFFFE;


_04001BC0:	// 4001bc0: <4b3843cf>	VMADH     vec15 = ( acc+= (vec08 * vec24[1]) << 16) >> 16
	{
		_u16		s2value = state.v[24].U16[6];
		VMADH_operation(0, state.v[15].U16[0], state.v[8].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[8].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[8].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[8].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[8].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[8].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[8].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[8].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BC4:	// 4001bc4: <c8ad2802>	LRV       vec13 <00> = [A1 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[A1]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[13].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001BC8:	// 4001bc8: <4b584bcf>	VMADH     vec15 = ( acc+= (vec09 * vec24[2]) << 16) >> 16
	{
		_u16		s2value = state.v[24].U16[5];
		VMADH_operation(0, state.v[15].U16[0], state.v[9].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[9].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[9].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[9].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[9].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[9].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[9].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[9].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BCC:	// 4001bcc: <e9952000>	SQV       [T4 + 0x00] = vec21 <00>
	{
		_u32    addr = (0x00000000 + state.r[T4]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[21].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[21].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[21].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[21].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[21].U64[0] & temp1);
			value2 |= (state.v[21].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001BD0:	// 4001bd0: <4b7853cf>	VMADH     vec15 = ( acc+= (vec10 * vec24[3]) << 16) >> 16
	{
		_u16		s2value = state.v[24].U16[4];
		VMADH_operation(0, state.v[15].U16[0], state.v[10].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[10].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[10].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[10].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[10].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[10].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[10].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[10].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BD4:	// 4001bd4: <4b985bcf>	VMADH     vec15 = ( acc+= (vec11 * vec24[4]) << 16) >> 16
	{
		_u16		s2value = state.v[24].U16[3];
		VMADH_operation(0, state.v[15].U16[0], state.v[11].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[11].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[11].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[11].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[11].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[11].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[11].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[11].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BD8:	// 4001bd8: <4bb863cf>	VMADH     vec15 = ( acc+= (vec12 * vec24[5]) << 16) >> 16
	{
		_u16		s2value = state.v[24].U16[2];
		VMADH_operation(0, state.v[15].U16[0], state.v[12].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[12].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[12].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[12].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[12].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[12].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[12].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[12].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BDC:	// 4001bdc: <4bd86bcf>	VMADH     vec15 = ( acc+= (vec13 * vec24[6]) << 16) >> 16
	{
		_u16		s2value = state.v[24].U16[1];
		VMADH_operation(0, state.v[15].U16[0], state.v[13].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[13].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[13].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[13].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[13].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[13].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[13].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[13].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BE0:	// 4001be0: <4b93c3cf>	VMADH     vec15 = ( acc+= (vec24 * vec19[4]) << 16) >> 16
	{
		_u16		s2value = state.v[19].U16[3];
		VMADH_operation(0, state.v[15].U16[0], state.v[24].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[24].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[24].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[24].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[24].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[24].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[24].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[24].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BE4:	// 4001be4: <4b367c1d>	VSAW $v16, $v15, $v22[[1]]
	state.v[16].U16[0] = state.accum[0].U16[2];
	state.v[16].U16[1] = state.accum[1].U16[2];
	state.v[16].U16[2] = state.accum[2].U16[2];
	state.v[16].U16[3] = state.accum[3].U16[2];
	state.v[16].U16[4] = state.accum[4].U16[2];
	state.v[16].U16[5] = state.accum[5].U16[2];
	state.v[16].U16[6] = state.accum[6].U16[2];
	state.v[16].U16[7] = state.accum[7].U16[2];


_04001BE8:	// 4001be8: <4b167d9d>	VSAW $v22, $v15, $v22[[0]]
	state.v[22].U16[0] = state.accum[0].U16[3];
	state.v[22].U16[1] = state.accum[1].U16[3];
	state.v[22].U16[2] = state.accum[2].U16[3];
	state.v[22].U16[3] = state.accum[3].U16[3];
	state.v[22].U16[4] = state.accum[4].U16[3];
	state.v[22].U16[5] = state.accum[5].U16[3];
	state.v[22].U16[6] = state.accum[6].U16[3];
	state.v[22].U16[7] = state.accum[7].U16[3];


_04001BEC:	// 4001bec: <4b738406>	VMUDN     vec16 = ( acc = vec16 * vec19[3]      ) >> 16
	{
		_u16		s2value = state.v[19].U16[4];
		VMUDN_operation(0, state.v[16].U16[0], state.v[16].U16[0], s2value, 0, 1, 0, 1)
		VMUDN_operation(1, state.v[16].U16[1], state.v[16].U16[1], s2value, 0, 1, 0, 1)
		VMUDN_operation(2, state.v[16].U16[2], state.v[16].U16[2], s2value, 0, 1, 0, 1)
		VMUDN_operation(3, state.v[16].U16[3], state.v[16].U16[3], s2value, 0, 1, 0, 1)
		VMUDN_operation(4, state.v[16].U16[4], state.v[16].U16[4], s2value, 0, 1, 0, 1)
		VMUDN_operation(5, state.v[16].U16[5], state.v[16].U16[5], s2value, 0, 1, 0, 1)
		VMUDN_operation(6, state.v[16].U16[6], state.v[16].U16[6], s2value, 0, 1, 0, 1)
		VMUDN_operation(7, state.v[16].U16[7], state.v[16].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BF0:	// 4001bf0: <4b73b58f>	VMADH     vec22 = ( acc+= (vec22 * vec19[3]) << 16) >> 16
	{
		_u16		s2value = state.v[19].U16[4];
		VMADH_operation(0, state.v[22].U16[0], state.v[22].U16[0], s2value, 1, 0, 0, 1)
		VMADH_operation(1, state.v[22].U16[1], state.v[22].U16[1], s2value, 1, 0, 0, 1)
		VMADH_operation(2, state.v[22].U16[2], state.v[22].U16[2], s2value, 1, 0, 0, 1)
		VMADH_operation(3, state.v[22].U16[3], state.v[22].U16[3], s2value, 1, 0, 0, 1)
		VMADH_operation(4, state.v[22].U16[4], state.v[22].U16[4], s2value, 1, 0, 0, 1)
		VMADH_operation(5, state.v[22].U16[5], state.v[22].U16[5], s2value, 1, 0, 0, 1)
		VMADH_operation(6, state.v[22].U16[6], state.v[22].U16[6], s2value, 1, 0, 0, 1)
		VMADH_operation(7, state.v[22].U16[7], state.v[22].U16[7], s2value, 1, 0, 0, 1)
	}


_04001BF4:	// 4001bf4: <4bd62bc7>	VMUDH     vec15 = ( acc = (vec05 * vec22[6]) << 16) >> 16
	{
		_u16		s2value = state.v[22].U16[1];
		VMUDH_operation(0, state.v[15].U16[0], state.v[5].U16[0], s2value, 0, 1, 0, 1)
		VMUDH_operation(1, state.v[15].U16[1], state.v[5].U16[1], s2value, 0, 1, 0, 1)
		VMUDH_operation(2, state.v[15].U16[2], state.v[5].U16[2], s2value, 0, 1, 0, 1)
		VMUDH_operation(3, state.v[15].U16[3], state.v[5].U16[3], s2value, 0, 1, 0, 1)
		VMUDH_operation(4, state.v[15].U16[4], state.v[5].U16[4], s2value, 0, 1, 0, 1)
		VMUDH_operation(5, state.v[15].U16[5], state.v[5].U16[5], s2value, 0, 1, 0, 1)
		VMUDH_operation(6, state.v[15].U16[6], state.v[5].U16[6], s2value, 0, 1, 0, 1)
		VMUDH_operation(7, state.v[15].U16[7], state.v[5].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BF8:	// 4001bf8: <4bf633cf>	VMADH     vec15 = ( acc+= (vec06 * vec22[7]) << 16) >> 16
	{
		_u16		s2value = state.v[22].U16[0];
		VMADH_operation(0, state.v[15].U16[0], state.v[6].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[6].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[6].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[6].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[6].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[6].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[6].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[6].U16[7], s2value, 0, 1, 0, 1)
	}


_04001BFC:	// 4001bfc: <4b193bcf>	VMADH     vec15 = ( acc+= (vec07 * vec25[0]) << 16) >> 16
	{
		_u16		s2value = state.v[25].U16[7];
		VMADH_operation(0, state.v[15].U16[0], state.v[7].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[7].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[7].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[7].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[7].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[7].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[7].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[7].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C00:	// 4001c00: <4b3943cf>	VMADH     vec15 = ( acc+= (vec08 * vec25[1]) << 16) >> 16
	{
		_u16		s2value = state.v[25].U16[6];
		VMADH_operation(0, state.v[15].U16[0], state.v[8].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[8].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[8].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[8].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[8].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[8].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[8].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[8].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C04:	// 4001c04: <e9962001>	SQV       [T4 + 0x10] = vec22 <00>
	{
		_u32    addr = (0x00000010 + state.r[T4]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[22].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[22].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[22].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[22].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[22].U64[0] & temp1);
			value2 |= (state.v[22].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001C08:	// 4001c08: <4b594bcf>	VMADH     vec15 = ( acc+= (vec09 * vec25[2]) << 16) >> 16
	{
		_u16		s2value = state.v[25].U16[5];
		VMADH_operation(0, state.v[15].U16[0], state.v[9].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[9].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[9].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[9].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[9].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[9].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[9].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[9].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C0C:	// 4001c0c: <4b7953cf>	VMADH     vec15 = ( acc+= (vec10 * vec25[3]) << 16) >> 16
	{
		_u16		s2value = state.v[25].U16[4];
		VMADH_operation(0, state.v[15].U16[0], state.v[10].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[10].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[10].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[10].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[10].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[10].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[10].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[10].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C10:	// 4001c10: <4b995bcf>	VMADH     vec15 = ( acc+= (vec11 * vec25[4]) << 16) >> 16
	{
		_u16		s2value = state.v[25].U16[3];
		VMADH_operation(0, state.v[15].U16[0], state.v[11].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[11].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[11].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[11].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[11].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[11].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[11].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[11].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C14:	// 4001c14: <4bb963cf>	VMADH     vec15 = ( acc+= (vec12 * vec25[5]) << 16) >> 16
	{
		_u16		s2value = state.v[25].U16[2];
		VMADH_operation(0, state.v[15].U16[0], state.v[12].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[12].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[12].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[12].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[12].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[12].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[12].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[12].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C18:	// 4001c18: <4bd96bcf>	VMADH     vec15 = ( acc+= (vec13 * vec25[6]) << 16) >> 16
	{
		_u16		s2value = state.v[25].U16[1];
		VMADH_operation(0, state.v[15].U16[0], state.v[13].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[13].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[13].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[13].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[13].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[13].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[13].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[13].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C1C:	// 4001c1c: <4b93cbcf>	VMADH     vec15 = ( acc+= (vec25 * vec19[4]) << 16) >> 16
	{
		_u16		s2value = state.v[19].U16[3];
		VMADH_operation(0, state.v[15].U16[0], state.v[25].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[25].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[25].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[25].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[25].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[25].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[25].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[25].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C20:	// 4001c20: <4b357c1d>	VSAW $v16, $v15, $v21[[1]]
	state.v[16].U16[0] = state.accum[0].U16[2];
	state.v[16].U16[1] = state.accum[1].U16[2];
	state.v[16].U16[2] = state.accum[2].U16[2];
	state.v[16].U16[3] = state.accum[3].U16[2];
	state.v[16].U16[4] = state.accum[4].U16[2];
	state.v[16].U16[5] = state.accum[5].U16[2];
	state.v[16].U16[6] = state.accum[6].U16[2];
	state.v[16].U16[7] = state.accum[7].U16[2];


_04001C24:	// 4001c24: <4b157d5d>	VSAW $v21, $v15, $v21[[0]]
	state.v[21].U16[0] = state.accum[0].U16[3];
	state.v[21].U16[1] = state.accum[1].U16[3];
	state.v[21].U16[2] = state.accum[2].U16[3];
	state.v[21].U16[3] = state.accum[3].U16[3];
	state.v[21].U16[4] = state.accum[4].U16[3];
	state.v[21].U16[5] = state.accum[5].U16[3];
	state.v[21].U16[6] = state.accum[6].U16[3];
	state.v[21].U16[7] = state.accum[7].U16[3];


_04001C28:	// 4001c28: <4b738406>	VMUDN     vec16 = ( acc = vec16 * vec19[3]      ) >> 16
	{
		_u16		s2value = state.v[19].U16[4];
		VMUDN_operation(0, state.v[16].U16[0], state.v[16].U16[0], s2value, 1, 1, 0, 1)
		VMUDN_operation(1, state.v[16].U16[1], state.v[16].U16[1], s2value, 1, 1, 0, 1)
		VMUDN_operation(2, state.v[16].U16[2], state.v[16].U16[2], s2value, 1, 1, 0, 1)
		VMUDN_operation(3, state.v[16].U16[3], state.v[16].U16[3], s2value, 1, 1, 0, 1)
		VMUDN_operation(4, state.v[16].U16[4], state.v[16].U16[4], s2value, 1, 1, 0, 1)
		VMUDN_operation(5, state.v[16].U16[5], state.v[16].U16[5], s2value, 1, 1, 0, 1)
		VMUDN_operation(6, state.v[16].U16[6], state.v[16].U16[6], s2value, 1, 1, 0, 1)
		VMUDN_operation(7, state.v[16].U16[7], state.v[16].U16[7], s2value, 1, 1, 0, 1)
	}


_04001C2C:	// 4001c2c: <4b73ad4f>	VMADH     vec21 = ( acc+= (vec21 * vec19[3]) << 16) >> 16
	{
		_u16		s2value = state.v[19].U16[4];
		VMADH_operation(0, state.v[21].U16[0], state.v[21].U16[0], s2value, 1, 0, 0, 1)
		VMADH_operation(1, state.v[21].U16[1], state.v[21].U16[1], s2value, 1, 0, 0, 1)
		VMADH_operation(2, state.v[21].U16[2], state.v[21].U16[2], s2value, 1, 0, 0, 1)
		VMADH_operation(3, state.v[21].U16[3], state.v[21].U16[3], s2value, 1, 0, 0, 1)
		VMADH_operation(4, state.v[21].U16[4], state.v[21].U16[4], s2value, 1, 0, 0, 1)
		VMADH_operation(5, state.v[21].U16[5], state.v[21].U16[5], s2value, 1, 0, 0, 1)
		VMADH_operation(6, state.v[21].U16[6], state.v[21].U16[6], s2value, 1, 0, 0, 1)
		VMADH_operation(7, state.v[21].U16[7], state.v[21].U16[7], s2value, 1, 0, 0, 1)
	}


_04001C30:	// 4001c30: <4bd52bc7>	VMUDH     vec15 = ( acc = (vec05 * vec21[6]) << 16) >> 16
	{
		_u16		s2value = state.v[21].U16[1];
		VMUDH_operation(0, state.v[15].U16[0], state.v[5].U16[0], s2value, 0, 1, 1, 1)
		VMUDH_operation(1, state.v[15].U16[1], state.v[5].U16[1], s2value, 0, 1, 1, 1)
		VMUDH_operation(2, state.v[15].U16[2], state.v[5].U16[2], s2value, 0, 1, 1, 1)
		VMUDH_operation(3, state.v[15].U16[3], state.v[5].U16[3], s2value, 0, 1, 1, 1)
		VMUDH_operation(4, state.v[15].U16[4], state.v[5].U16[4], s2value, 0, 1, 1, 1)
		VMUDH_operation(5, state.v[15].U16[5], state.v[5].U16[5], s2value, 0, 1, 1, 1)
		VMUDH_operation(6, state.v[15].U16[6], state.v[5].U16[6], s2value, 0, 1, 1, 1)
		VMUDH_operation(7, state.v[15].U16[7], state.v[5].U16[7], s2value, 0, 1, 1, 1)
	}


_04001C34:	// 4001c34: <4bf533cf>	VMADH     vec15 = ( acc+= (vec06 * vec21[7]) << 16) >> 16
	{
		_u16		s2value = state.v[21].U16[0];
		VMADH_operation(0, state.v[15].U16[0], state.v[6].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[6].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[6].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[6].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[6].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[6].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[6].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[6].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C38:	// 4001c38: <4b1a3bcf>	VMADH     vec15 = ( acc+= (vec07 * vec26[0]) << 16) >> 16
	{
		_u16		s2value = state.v[26].U16[7];
		VMADH_operation(0, state.v[15].U16[0], state.v[7].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[7].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[7].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[7].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[7].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[7].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[7].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[7].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C3C:	// 4001c3c: <4b3a43cf>	VMADH     vec15 = ( acc+= (vec08 * vec26[1]) << 16) >> 16
	{
		_u16		s2value = state.v[26].U16[6];
		VMADH_operation(0, state.v[15].U16[0], state.v[8].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[8].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[8].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[8].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[8].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[8].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[8].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[8].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C40:	// 4001c40: <e9952002>	SQV       [T4 + 0x20] = vec21 <00>
	{
		_u32    addr = (0x00000020 + state.r[T4]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[21].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[21].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[21].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[21].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[21].U64[0] & temp1);
			value2 |= (state.v[21].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001C44:	// 4001c44: <4b5a4bcf>	VMADH     vec15 = ( acc+= (vec09 * vec26[2]) << 16) >> 16
	{
		_u16		s2value = state.v[26].U16[5];
		VMADH_operation(0, state.v[15].U16[0], state.v[9].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[9].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[9].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[9].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[9].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[9].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[9].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[9].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C48:	// 4001c48: <39ce0001>	XORI      T6 = T6 xor 0x0001
	state.r[T6] = (state.r[T6] ^ 0x00000001);


_04001C4C:	// 4001c4c: <4b7a53cf>	VMADH     vec15 = ( acc+= (vec10 * vec26[3]) << 16) >> 16
	{
		_u16		s2value = state.v[26].U16[4];
		VMADH_operation(0, state.v[15].U16[0], state.v[10].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[10].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[10].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[10].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[10].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[10].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[10].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[10].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C50:	// 4001c50: <4b9a5bcf>	VMADH     vec15 = ( acc+= (vec11 * vec26[4]) << 16) >> 16
	{
		_u16		s2value = state.v[26].U16[3];
		VMADH_operation(0, state.v[15].U16[0], state.v[11].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[11].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[11].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[11].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[11].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[11].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[11].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[11].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C54:	// 4001c54: <4bba63cf>	VMADH     vec15 = ( acc+= (vec12 * vec26[5]) << 16) >> 16
	{
		_u16		s2value = state.v[26].U16[2];
		VMADH_operation(0, state.v[15].U16[0], state.v[12].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[12].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[12].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[12].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[12].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[12].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[12].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[12].U16[7], s2value, 0, 1, 0, 1)
	}


_04001C58:	// 4001c58: <4bda6bcf>	VMADH     vec15 = ( acc+= (vec13 * vec26[6]) << 16) >> 16
	{
		_u16		s2value = state.v[26].U16[1];
		VMADH_operation(0, state.v[15].U16[0], state.v[13].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[13].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[13].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[13].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[13].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[13].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[13].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[13].U16[7], s2value, 1, 1, 0, 1)
	}


_04001C5C:	// 4001c5c: <15c00003>	BNE       (R0!=T6) --> 1c6c
	sp_reg_pc = 0x04001C5C;
	if (state.r[T6] != 0)
	{
		{
			_u16		s2value = state.v[19].U16[3];
			VMADH_operation(0, state.v[15].U16[0], state.v[26].U16[0], s2value, 1, 1, 1, 1)
			VMADH_operation(1, state.v[15].U16[1], state.v[26].U16[1], s2value, 1, 1, 1, 1)
			VMADH_operation(2, state.v[15].U16[2], state.v[26].U16[2], s2value, 1, 1, 1, 1)
			VMADH_operation(3, state.v[15].U16[3], state.v[26].U16[3], s2value, 1, 1, 1, 1)
			VMADH_operation(4, state.v[15].U16[4], state.v[26].U16[4], s2value, 1, 1, 1, 1)
			VMADH_operation(5, state.v[15].U16[5], state.v[26].U16[5], s2value, 1, 1, 1, 1)
			VMADH_operation(6, state.v[15].U16[6], state.v[26].U16[6], s2value, 1, 1, 1, 1)
			VMADH_operation(7, state.v[15].U16[7], state.v[26].U16[7], s2value, 1, 1, 1, 1)
		}
		goto _04001C6C;
	}


_04001C60:	// 4001c60: <4b93d3cf>	VMADH     vec15 = ( acc+= (vec26 * vec19[4]) << 16) >> 16
	{
		_u16		s2value = state.v[19].U16[3];
		VMADH_operation(0, state.v[15].U16[0], state.v[26].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[15].U16[1], state.v[26].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[15].U16[2], state.v[26].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[15].U16[3], state.v[26].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[15].U16[4], state.v[26].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[15].U16[5], state.v[26].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[15].U16[6], state.v[26].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[15].U16[7], state.v[26].U16[7], s2value, 1, 1, 0, 1)
	}


_04001C64:	// 4001c64: <254a0008>	ADDIU     T2 = T2 + 0008
	state.r[T2] = state.r[T2] + 0x0008;


_04001C68:	// 4001c68: <256b0020>	ADDIU     T3 = T3 + 0020
	state.r[T3] = state.r[T3] + 0x0020;


_04001C6C:	// 4001c6c: <254a0010>	ADDIU     T2 = T2 + 0010
	state.r[T2] = state.r[T2] + 0x0010;


_04001C70:	// 4001c70: <4b367c1d>	VSAW $v16, $v15, $v22[[1]]
	state.v[16].U16[0] = state.accum[0].U16[2];
	state.v[16].U16[1] = state.accum[1].U16[2];
	state.v[16].U16[2] = state.accum[2].U16[2];
	state.v[16].U16[3] = state.accum[3].U16[2];
	state.v[16].U16[4] = state.accum[4].U16[2];
	state.v[16].U16[5] = state.accum[5].U16[2];
	state.v[16].U16[6] = state.accum[6].U16[2];
	state.v[16].U16[7] = state.accum[7].U16[2];


_04001C74:	// 4001c74: <256b0004>	ADDIU     T3 = T3 + 0004
	state.r[T3] = state.r[T3] + 0x0004;


_04001C78:	// 4001c78: <4b167d9d>	VSAW $v22, $v15, $v22[[0]]
	state.v[22].U16[0] = state.accum[0].U16[3];
	state.v[22].U16[1] = state.accum[1].U16[3];
	state.v[22].U16[2] = state.accum[2].U16[3];
	state.v[22].U16[3] = state.accum[3].U16[3];
	state.v[22].U16[4] = state.accum[4].U16[3];
	state.v[22].U16[5] = state.accum[5].U16[3];
	state.v[22].U16[6] = state.accum[6].U16[3];
	state.v[22].U16[7] = state.accum[7].U16[3];


_04001C7C:	// 4001c7c: <25efffff>	ADDIU     T7 = T7 + ffff
	state.r[T7] = state.r[T7] + 0xFFFFFFFF;


_04001C80:	// 4001c80: <4b738406>	VMUDN     vec16 = ( acc = vec16 * vec19[3]      ) >> 16
	{
		_u16		s2value = state.v[19].U16[4];
		VMUDN_operation(0, state.v[16].U16[0], state.v[16].U16[0], s2value, 1, 1, 1, 1)
		VMUDN_operation(1, state.v[16].U16[1], state.v[16].U16[1], s2value, 1, 1, 1, 1)
		VMUDN_operation(2, state.v[16].U16[2], state.v[16].U16[2], s2value, 1, 1, 1, 1)
		VMUDN_operation(3, state.v[16].U16[3], state.v[16].U16[3], s2value, 1, 1, 1, 1)
		VMUDN_operation(4, state.v[16].U16[4], state.v[16].U16[4], s2value, 1, 1, 1, 1)
		VMUDN_operation(5, state.v[16].U16[5], state.v[16].U16[5], s2value, 1, 1, 1, 1)
		VMUDN_operation(6, state.v[16].U16[6], state.v[16].U16[6], s2value, 1, 1, 1, 1)
		VMUDN_operation(7, state.v[16].U16[7], state.v[16].U16[7], s2value, 1, 1, 1, 1)
	}


_04001C84:	// 4001c84: <258c0040>	ADDIU     T4 = T4 + 0040
	state.r[T4] = state.r[T4] + 0x0040;


_04001C88:	// 4001c88: <4b73b58f>	VMADH     vec22 = ( acc+= (vec22 * vec19[3]) << 16) >> 16
	{
		_u16		s2value = state.v[19].U16[4];
		VMADH_operation(0, state.v[22].U16[0], state.v[22].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[22].U16[1], state.v[22].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[22].U16[2], state.v[22].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[22].U16[3], state.v[22].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[22].U16[4], state.v[22].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[22].U16[5], state.v[22].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[22].U16[6], state.v[22].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[22].U16[7], state.v[22].U16[7], s2value, 1, 1, 0, 1)
	}


_04001C8C:	// 4001c8c: <15e0ff6f>	BNE       (R0!=T7) --> 1a4c
	sp_reg_pc = 0x04001C8C;
	if (state.r[T7] != 0)
	{
		{
			_u32    addr = (0xFFFFFFF0 + state.r[T4]);
			int     shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				*(_u32 *)&pDMEM[addr+12] = state.v[22].U32[0];
				*(_u32 *)&pDMEM[addr+8 ] = state.v[22].U32[1];
				*(_u32 *)&pDMEM[addr+4 ] = state.v[22].U32[2];
				*(_u32 *)&pDMEM[addr   ] = state.v[22].U32[3];
			}
			else
			{
				_u64    value1 = Load64_DMEM(addr+8);
				_u64    value2 = Load64_DMEM(addr);
				_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & ~temp1;
				value2 = value2 & ~temp2;

				value1 |= (state.v[22].U64[0] & temp1);
				value2 |= (state.v[22].U64[1] & temp2);

				Save64_DMEM(value1, addr+8);
				Save64_DMEM(value2, addr  );
			}
		}
		goto _04001A4C;
	}


_04001C90:	// 4001c90: <e996207f>	SQV       [T4 + 0xf0] = vec22 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[T4]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[22].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[22].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[22].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[22].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[22].U64[0] & temp1);
			value2 |= (state.v[22].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001C94:	// 4001c94: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001C98:	// 4001c98: <00000000>	NOP       


_04001C9C:	// 4001c9c: <340c0bc0>	ORI       T4 = R0 | 0x0bc0
	state.r[T4] = (0 | 0x00000BC0);


_04001CA0:	// 4001ca0: <958b0006>	LHU       T3 = [T4+0006]
	state.r[T3] = (_s32)(_u16)Load16_DMEM((state.r[T4] + 0x00000006) & 0xfff);


_04001CA4:	// 4001ca4: <958a000e>	LHU       T2 = [T4+000e]
	state.r[T2] = (_s32)(_u16)Load16_DMEM((state.r[T4] + 0x0000000E) & 0xfff);


_04001CA8:	// 4001ca8: <34058000>	ORI       A1 = R0 | 0x8000
	state.r[A1] = (0 | 0x00008000);


_04001CAC:	// 4001cac: <24068000>	ADDIU     A2 = R0 + 8000
	state.r[A2] = 0 + 0xFFFF8000;


_04001CB0:	// 4001cb0: <000b5c00>	SLL       T3 = T3 << 16
	state.r[T3] = ((_u32)state.r[T3] << 16);


_04001CB4:	// 4001cb4: <014b5025>	OR        T2 = T2 | T3
	state.r[T2] = (state.r[T2] | state.r[T3]);


_04001CB8:	// 4001cb8: <0145402a>	SLT ?-?
	if (state.r[T2] < state.r[A1])
	{
		state.r[T0] = 1;
	}
	else
	{
		state.r[T0] = 0;
	}


_04001CBC:	// 4001cbc: <15000002>	BNE       (R0!=T0) --> 1cc8
	sp_reg_pc = 0x04001CBC;
	if (state.r[T0] != 0)
	{
		if (state.r[T2] < state.r[A2])
		{
			state.r[T0] = 1;
		}
		else
		{
			state.r[T0] = 0;
		}
		goto _04001CC8;
	}


_04001CC0:	// 4001cc0: <0146402a>	SLT ?-?
	if (state.r[T2] < state.r[A2])
	{
		state.r[T0] = 1;
	}
	else
	{
		state.r[T0] = 0;
	}


_04001CC4:	// 4001cc4: <340a7fff>	ORI       T2 = R0 | 0x7fff
	state.r[T2] = (0 | 0x00007FFF);


_04001CC8:	// 4001cc8: <11000002>	BEQ       (R0==T0) --> 1cd4
	sp_reg_pc = 0x04001CC8;
	if (state.r[T0] == 0)
	{
		state.r[T1] = (0 | 0x00000D60);
		goto _04001CD4;
	}


_04001CCC:	// 4001ccc: <34090d60>	ORI       T1 = R0 | 0x0d60
	state.r[T1] = (0 | 0x00000D60);


_04001CD0:	// 4001cd0: <240a8000>	ADDIU     T2 = R0 + 8000
	state.r[T2] = 0 + 0xFFFF8000;


_04001CD4:	// 4001cd4: <488a0800>	MTC2      vec1 <00> = T2
	state.v[1].U16[7] = (_u16)state.r[T2];


_04001CD8:	// 4001cd8: <4b010054>	VADDC	vec01 = vec00 + vec01[0]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[1].U16[7];
		VADDC_operation(0, state.v[1].U16[0], state.v[0].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[1].U16[1], state.v[0].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[1].U16[2], state.v[0].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[1].U16[3], state.v[0].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[1].U16[4], state.v[0].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[1].U16[5], state.v[0].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[1].U16[6], state.v[0].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[1].U16[7], state.v[0].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_04001CDC:	// 4001cdc: <3405000c>	ORI       A1 = R0 | 0x000c
	state.r[A1] = (0 | 0x0000000C);


_04001CE0:	// 4001ce0: <24a5ffff>	ADDIU     A1 = A1 + ffff
	state.r[A1] = state.r[A1] + 0xFFFFFFFF;


_04001CE4:	// 4001ce4: <25290020>	ADDIU     T1 = T1 + 0020
	state.r[T1] = state.r[T1] + 0x0020;


_04001CE8:	// 4001ce8: <e921207e>	SQV       [T1 + 0xe0] = vec01 <00>
	{
		_u32    addr = (0xFFFFFFE0 + state.r[T1]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[1].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[1].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[1].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[1].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[1].U64[0] & temp1);
			value2 |= (state.v[1].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001CEC:	// 4001cec: <14a0fffc>	BNE       (R0!=A1) --> 1ce0
	sp_reg_pc = 0x04001CEC;
	if (state.r[A1] != 0)
	{
		{
			_u32    addr = (0xFFFFFFF0 + state.r[T1]);
			int     shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				*(_u32 *)&pDMEM[addr+12] = state.v[1].U32[0];
				*(_u32 *)&pDMEM[addr+8 ] = state.v[1].U32[1];
				*(_u32 *)&pDMEM[addr+4 ] = state.v[1].U32[2];
				*(_u32 *)&pDMEM[addr   ] = state.v[1].U32[3];
			}
			else
			{
				_u64    value1 = Load64_DMEM(addr+8);
				_u64    value2 = Load64_DMEM(addr);
				_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & ~temp1;
				value2 = value2 & ~temp2;

				value1 |= (state.v[1].U64[0] & temp1);
				value2 |= (state.v[1].U64[1] & temp2);

				Save64_DMEM(value1, addr+8);
				Save64_DMEM(value2, addr  );
			}
		}
		goto _04001CE0;
	}


_04001CF0:	// 4001cf0: <e921207f>	SQV       [T1 + 0xf0] = vec01 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[T1]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[1].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[1].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[1].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[1].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[1].U64[0] & temp1);
			value2 |= (state.v[1].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001CF4:	// 4001cf4: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001CF8:	// 4001cf8: <00000000>	NOP       


_04001CFC:	// 4001cfc: <34060006>	ORI       A2 = R0 | 0x0006
	state.r[A2] = (0 | 0x00000006);


_04001D00:	// 4001d00: <e8a02000>	SQV       [A1 + 0x00] = vec00 <00>
	{
		_u32    addr = (0x00000000 + state.r[A1]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[0].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[0].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[0].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[0].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[0].U64[0] & temp1);
			value2 |= (state.v[0].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001D04:	// 4001d04: <e8a02001>	SQV       [A1 + 0x10] = vec00 <00>
	{
		_u32    addr = (0x00000010 + state.r[A1]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[0].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[0].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[0].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[0].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[0].U64[0] & temp1);
			value2 |= (state.v[0].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001D08:	// 4001d08: <e8a02002>	SQV       [A1 + 0x20] = vec00 <00>
	{
		_u32    addr = (0x00000020 + state.r[A1]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[0].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[0].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[0].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[0].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[0].U64[0] & temp1);
			value2 |= (state.v[0].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001D0C:	// 4001d0c: <e8a02003>	SQV       [A1 + 0x30] = vec00 <00>
	{
		_u32    addr = (0x00000030 + state.r[A1]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[0].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[0].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[0].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[0].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[0].U64[0] & temp1);
			value2 |= (state.v[0].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001D10:	// 4001d10: <24c6ffff>	ADDIU     A2 = A2 + ffff
	state.r[A2] = state.r[A2] + 0xFFFFFFFF;


_04001D14:	// 4001d14: <14c0fffa>	BNE       (R0!=A2) --> 1d00
	sp_reg_pc = 0x04001D14;
	if (state.r[A2] != 0)
	{
		state.r[A1] = state.r[A1] + 0x0040;
		goto _04001D00;
	}


_04001D18:	// 4001d18: <24a50040>	ADDIU     A1 = A1 + 0040
	state.r[A1] = state.r[A1] + 0x0040;


_04001D1C:	// 4001d1c: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001D20:	// 4001d20: <00000000>	NOP       


_04001D24:	// 4001d24: <001ff025>	OR        S8 = R0 | RA
	state.r[S8] = (0 | state.r[RA]);


_04001D28:	// 4001d28: <8c05025c>	LW        A1 = [R0+025c]
	state.r[A1] = (_s32)Load32_DMEM((0 + 0x0000025C) & 0xfff);


_04001D2C:	// 4001d2c: <34060001>	ORI       A2 = R0 | 0x0001
	state.r[A2] = (0 | 0x00000001);


_04001D30:	// 4001d30: <48860800>	MTC2      vec1 <00> = A2
	state.v[1].U16[7] = (_u16)state.r[A2];


_04001D34:	// 4001d34: <10a0004a>	BEQ       (R0==A1) --> 1e60
	sp_reg_pc = 0x04001D34;
	if (state.r[A1] == 0)
	{
		state.r[A2] = (0 | 0x00000008);
		goto _04001E60;
	}


_04001D38:	// 4001d38: <34060008>	ORI       A2 = R0 | 0x0008
	state.r[A2] = (0 | 0x00000008);


_04001D3C:	// 4001d3c: <48860a00>	MTC2      vec1 <04> = A2
	state.v[1].U16[5] = (_u16)state.r[A2];


_04001D40:	// 4001d40: <34060600>	ORI       A2 = R0 | 0x0600
	state.r[A2] = (0 | 0x00000600);


_04001D44:	// 4001d44: <0d0004fa>	JAL	    040013e8
	state.r[A3] = (0 | 0x00000047);
	sp_reg_pc = 0x04001D44;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040013E8;


_04001D48:	// 4001d48: <34070047>	ORI       A3 = R0 | 0x0047
	state.r[A3] = (0 | 0x00000047);


_04001D4C:	// 4001d4c: <8c0c0604>	LW        T4 = [R0+0604]
	state.r[T4] = (_s32)Load32_DMEM((0 + 0x00000604) & 0xfff);


_04001D50:	// 4001d50: <940d0252>	LHU       T5 = [R0+0252]
	state.r[T5] = (_s32)(_u16)Load16_DMEM((0 + 0x00000252) & 0xfff);


_04001D54:	// 4001d54: <8c0e0600>	LW        T6 = [R0+0600]
	state.r[T6] = (_s32)Load32_DMEM((0 + 0x00000600) & 0xfff);


_04001D58:	// 4001d58: <000d29c0>	SLL       A1 = T5 << 7
	state.r[A1] = ((_u32)state.r[T5] << 7);


_04001D5C:	// 4001d5c: <000d6980>	SLL       T5 = T5 << 6
	state.r[T5] = ((_u32)state.r[T5] << 6);


_04001D60:	// 4001d60: <01a56821>	ADDU      T5 = T5+A1
	state.r[T5] = (state.r[T5] + state.r[A1]);


_04001D64:	// 4001d64: <0d00073f>	JAL	    04001cfc
	state.r[A1] = (0 | 0x00000650);
	sp_reg_pc = 0x04001D64;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001CFC;


_04001D68:	// 4001d68: <34050650>	ORI       A1 = R0 | 0x0650
	state.r[A1] = (0 | 0x00000650);


_04001D6C:	// 4001d6c: <94090608>	LHU       T1 = [R0+0608]
	state.r[T1] = (_s32)(_u16)Load16_DMEM((0 + 0x00000608) & 0xfff);


_04001D70:	// 4001d70: <340a060c>	ORI       T2 = R0 | 0x060c
	state.r[T2] = (0 | 0x0000060C);


_04001D74:	// 4001d74: <340b062c>	ORI       T3 = R0 | 0x062c
	state.r[T3] = (0 | 0x0000062C);


_04001D78:	// 4001d78: <8d4f0000>	LW        T7 = [T2+0000]
	state.r[T7] = (_s32)Load32_DMEM((state.r[T2] + 0x00000000) & 0xfff);


_04001D7C:	// 4001d7c: <01af7823>	SUBU      T7 = T5-T7
	state.r[T7] = (state.r[T5] - state.r[T7]);


_04001D80:	// 4001d80: <05e10002>	BGEZ ?-?
	sp_reg_pc = 0x04001D80;
	if (state.r[T7] >= 0)
	{
		goto _04001D8C;
	}


_04001D84:	// 4001d84: <00000000>	NOP       


_04001D88:	// 4001d88: <01ec7821>	ADDU      T7 = T7+T4
	state.r[T7] = (state.r[T7] + state.r[T4]);


_04001D8C:	// 4001d8c: <25e600c0>	ADDIU     A2 = T7 + 00c0
	state.r[A2] = state.r[T7] + 0x00C0;


_04001D90:	// 4001d90: <00cc3023>	SUBU      A2 = A2-T4
	state.r[A2] = (state.r[A2] - state.r[T4]);


_04001D94:	// 4001d94: <18c0000a>	BLEZ      (R0<=0) --> 1dc0
	sp_reg_pc = 0x04001D94;
	if ((_s32)state.r[A2] <= 0)
	{
		state.r[A3] = (0 | 0x0000017F);
		goto _04001DC0;
	}


_04001D98:	// 4001d98: <3407017f>	ORI       A3 = R0 | 0x017f
	state.r[A3] = (0 | 0x0000017F);


_04001D9C:	// 4001d9c: <018f8023>	SUBU      S0 = T4-T7
	state.r[S0] = (state.r[T4] - state.r[T7]);


_04001DA0:	// 4001da0: <00108040>	SLL       S0 = S0 << 1
	state.r[S0] = ((_u32)state.r[S0] << 1);


_04001DA4:	// 4001da4: <00063840>	SLL       A3 = A2 << 1
	state.r[A3] = ((_u32)state.r[A2] << 1);


_04001DA8:	// 4001da8: <000e2825>	OR        A1 = R0 | T6
	state.r[A1] = (0 | state.r[T6]);


_04001DAC:	// 4001dac: <340607d0>	ORI       A2 = R0 | 0x07d0
	state.r[A2] = (0 | 0x000007D0);


_04001DB0:	// 4001db0: <00d03021>	ADDU      A2 = A2+S0
	state.r[A2] = (state.r[A2] + state.r[S0]);


_04001DB4:	// 4001db4: <0d0004fa>	JAL	    040013e8
	state.r[A3] = state.r[A3] + 0xFFFFFFFF;
	sp_reg_pc = 0x04001DB4;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040013E8;


_04001DB8:	// 4001db8: <24e7ffff>	ADDIU     A3 = A3 + ffff
	state.r[A3] = state.r[A3] + 0xFFFFFFFF;


_04001DBC:	// 4001dbc: <2607ffff>	ADDIU     A3 = S0 + ffff
	state.r[A3] = state.r[S0] + 0xFFFFFFFF;


_04001DC0:	// 4001dc0: <000f2840>	SLL       A1 = T7 << 1
	state.r[A1] = ((_u32)state.r[T7] << 1);


_04001DC4:	// 4001dc4: <00ae2821>	ADDU      A1 = A1+T6
	state.r[A1] = (state.r[A1] + state.r[T6]);


_04001DC8:	// 4001dc8: <0d0004fa>	JAL	    040013e8
	state.r[A2] = (0 | 0x000007D0);
	sp_reg_pc = 0x04001DC8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040013E8;


_04001DCC:	// 4001dcc: <340607d0>	ORI       A2 = R0 | 0x07d0
	state.r[A2] = (0 | 0x000007D0);


_04001DD0:	// 4001dd0: <c9610900>	LSV       vec01 <02> = [T3 + 0x00]
	state.v[1].U16[6] = Load16_DMEM(0x00000000 + state.r[T3]);


_04001DD4:	// 4001dd4: <340507d0>	ORI       A1 = R0 | 0x07d0
	state.r[A1] = (0 | 0x000007D0);


_04001DD8:	// 4001dd8: <0d00079a>	JAL	    04001e68
	state.r[A2] = (0 | 0x00000650);
	sp_reg_pc = 0x04001DD8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001E68;


_04001DDC:	// 4001ddc: <34060650>	ORI       A2 = R0 | 0x0650
	state.r[A2] = (0 | 0x00000650);


_04001DE0:	// 4001de0: <254a0004>	ADDIU     T2 = T2 + 0004
	state.r[T2] = state.r[T2] + 0x0004;


_04001DE4:	// 4001de4: <2529ffff>	ADDIU     T1 = T1 + ffff
	state.r[T1] = state.r[T1] + 0xFFFFFFFF;


_04001DE8:	// 4001de8: <1520ffe3>	BNE       (R0!=T1) --> 1d78
	sp_reg_pc = 0x04001DE8;
	if (state.r[T1] != 0)
	{
		state.r[T3] = state.r[T3] + 0x0002;
		goto _04001D78;
	}


_04001DEC:	// 4001dec: <256b0002>	ADDIU     T3 = T3 + 0002
	state.r[T3] = state.r[T3] + 0x0002;


_04001DF0:	// 4001df0: <34050600>	ORI       A1 = R0 | 0x0600
	state.r[A1] = (0 | 0x00000600);


_04001DF4:	// 4001df4: <c8a10905>	LSV       vec01 <02> = [A1 + 0x0a]
	state.v[1].U16[6] = Load16_DMEM(0x0000000A + state.r[A1]);


_04001DF8:	// 4001df8: <34050650>	ORI       A1 = R0 | 0x0650
	state.r[A1] = (0 | 0x00000650);


_04001DFC:	// 4001dfc: <0d0007ab>	JAL	    04001eac
	state.r[A2] = (0 | 0x00000D60);
	sp_reg_pc = 0x04001DFC;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001EAC;


_04001E00:	// 4001e00: <34060d60>	ORI       A2 = R0 | 0x0d60
	state.r[A2] = (0 | 0x00000D60);


_04001E04:	// 4001e04: <34050d60>	ORI       A1 = R0 | 0x0d60
	state.r[A1] = (0 | 0x00000D60);


_04001E08:	// 4001e08: <000d3040>	SLL       A2 = T5 << 1
	state.r[A2] = ((_u32)state.r[T5] << 1);


_04001E0C:	// 4001e0c: <00ce3021>	ADDU      A2 = A2+T6
	state.r[A2] = (state.r[A2] + state.r[T6]);


_04001E10:	// 4001e10: <0d0004ec>	JAL	    040013b0
	state.r[A3] = (0 | 0x0000017F);
	sp_reg_pc = 0x04001E10;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040013B0;


_04001E14:	// 4001e14: <3407017f>	ORI       A3 = R0 | 0x017f
	state.r[A3] = (0 | 0x0000017F);


_04001E18:	// 4001e18: <34070650>	ORI       A3 = R0 | 0x0650
	state.r[A3] = (0 | 0x00000650);


_04001E1C:	// 4001e1c: <34050300>	ORI       A1 = R0 | 0x0300
	state.r[A1] = (0 | 0x00000300);


_04001E20:	// 4001e20: <34060480>	ORI       A2 = R0 | 0x0480
	state.r[A2] = (0 | 0x00000480);


_04001E24:	// 4001e24: <34090018>	ORI       T1 = R0 | 0x0018
	state.r[T1] = (0 | 0x00000018);


_04001E28:	// 4001e28: <c8e32000>	LQV       vec03 <00> = [A3 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[A3]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[3].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[3].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[3].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[3].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[3].U64[0] = state.v[3].U64[0] & ~temp1;
			state.v[3].U64[1] = state.v[3].U64[1] & ~temp2;
			state.v[3].U64[0] = state.v[3].U64[0] | value1;
			state.v[3].U64[1] = state.v[3].U64[1] | value2;
		}
	}


_04001E2C:	// 4001e2c: <c8a72000>	LQV       vec07 <00> = [A1 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[A1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[7].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[7].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[7].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[7].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[7].U64[0] = state.v[7].U64[0] & ~temp1;
			state.v[7].U64[1] = state.v[7].U64[1] & ~temp2;
			state.v[7].U64[0] = state.v[7].U64[0] | value1;
			state.v[7].U64[1] = state.v[7].U64[1] | value2;
		}
	}


_04001E30:	// 4001e30: <4b011887>	VMUDH     vec02 = ( acc = (vec03 * vec01[0]) << 16) >> 16
	{
		_u16		s2value = state.v[1].U16[7];
		VMUDH_operation(0, state.v[2].U16[0], state.v[3].U16[0], s2value, 0, 1, 0, 1)
		VMUDH_operation(1, state.v[2].U16[1], state.v[3].U16[1], s2value, 0, 1, 0, 1)
		VMUDH_operation(2, state.v[2].U16[2], state.v[3].U16[2], s2value, 0, 1, 0, 1)
		VMUDH_operation(3, state.v[2].U16[3], state.v[3].U16[3], s2value, 0, 1, 0, 1)
		VMUDH_operation(4, state.v[2].U16[4], state.v[3].U16[4], s2value, 0, 1, 0, 1)
		VMUDH_operation(5, state.v[2].U16[5], state.v[3].U16[5], s2value, 0, 1, 0, 1)
		VMUDH_operation(6, state.v[2].U16[6], state.v[3].U16[6], s2value, 0, 1, 0, 1)
		VMUDH_operation(7, state.v[2].U16[7], state.v[3].U16[7], s2value, 0, 1, 0, 1)
	}


_04001E34:	// 4001e34: <c8cc2000>	LQV       vec12 <00> = [A2 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[A2]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[12].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[12].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[12].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[12].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[12].U64[0] = state.v[12].U64[0] & ~temp1;
			state.v[12].U64[1] = state.v[12].U64[1] & ~temp2;
			state.v[12].U64[0] = state.v[12].U64[0] | value1;
			state.v[12].U64[1] = state.v[12].U64[1] | value2;
		}
	}


_04001E38:	// 4001e38: <4b0139cf>	VMADH     vec07 = ( acc+= (vec07 * vec01[0]) << 16) >> 16
	{
		_u16		s2value = state.v[1].U16[7];
		VMADH_operation(0, state.v[7].U16[0], state.v[7].U16[0], s2value, 1, 0, 0, 1)
		VMADH_operation(1, state.v[7].U16[1], state.v[7].U16[1], s2value, 1, 0, 0, 1)
		VMADH_operation(2, state.v[7].U16[2], state.v[7].U16[2], s2value, 1, 0, 0, 1)
		VMADH_operation(3, state.v[7].U16[3], state.v[7].U16[3], s2value, 1, 0, 0, 1)
		VMADH_operation(4, state.v[7].U16[4], state.v[7].U16[4], s2value, 1, 0, 0, 1)
		VMADH_operation(5, state.v[7].U16[5], state.v[7].U16[5], s2value, 1, 0, 0, 1)
		VMADH_operation(6, state.v[7].U16[6], state.v[7].U16[6], s2value, 1, 0, 0, 1)
		VMADH_operation(7, state.v[7].U16[7], state.v[7].U16[7], s2value, 1, 0, 0, 1)
	}


_04001E3C:	// 4001e3c: <4b011887>	VMUDH     vec02 = ( acc = (vec03 * vec01[0]) << 16) >> 16
	{
		_u16		s2value = state.v[1].U16[7];
		VMUDH_operation(0, state.v[2].U16[0], state.v[3].U16[0], s2value, 1, 1, 1, 1)
		VMUDH_operation(1, state.v[2].U16[1], state.v[3].U16[1], s2value, 1, 1, 1, 1)
		VMUDH_operation(2, state.v[2].U16[2], state.v[3].U16[2], s2value, 1, 1, 1, 1)
		VMUDH_operation(3, state.v[2].U16[3], state.v[3].U16[3], s2value, 1, 1, 1, 1)
		VMUDH_operation(4, state.v[2].U16[4], state.v[3].U16[4], s2value, 1, 1, 1, 1)
		VMUDH_operation(5, state.v[2].U16[5], state.v[3].U16[5], s2value, 1, 1, 1, 1)
		VMUDH_operation(6, state.v[2].U16[6], state.v[3].U16[6], s2value, 1, 1, 1, 1)
		VMUDH_operation(7, state.v[2].U16[7], state.v[3].U16[7], s2value, 1, 1, 1, 1)
	}


_04001E40:	// 4001e40: <24a50010>	ADDIU     A1 = A1 + 0010
	state.r[A1] = state.r[A1] + 0x0010;


_04001E44:	// 4001e44: <4b01630f>	VMADH     vec12 = ( acc+= (vec12 * vec01[0]) << 16) >> 16
	{
		_u16		s2value = state.v[1].U16[7];
		VMADH_operation(0, state.v[12].U16[0], state.v[12].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[12].U16[1], state.v[12].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[12].U16[2], state.v[12].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[12].U16[3], state.v[12].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[12].U16[4], state.v[12].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[12].U16[5], state.v[12].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[12].U16[6], state.v[12].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[12].U16[7], state.v[12].U16[7], s2value, 1, 1, 0, 1)
	}


_04001E48:	// 4001e48: <24c60010>	ADDIU     A2 = A2 + 0010
	state.r[A2] = state.r[A2] + 0x0010;


_04001E4C:	// 4001e4c: <2529ffff>	ADDIU     T1 = T1 + ffff
	state.r[T1] = state.r[T1] + 0xFFFFFFFF;


_04001E50:	// 4001e50: <24e70010>	ADDIU     A3 = A3 + 0010
	state.r[A3] = state.r[A3] + 0x0010;


_04001E54:	// 4001e54: <e8a7207f>	SQV       [A1 + 0xf0] = vec07 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[A1]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[7].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[7].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[7].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[7].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[7].U64[0] & temp1);
			value2 |= (state.v[7].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001E58:	// 4001e58: <1520fff3>	BNE       (R0!=T1) --> 1e28
	sp_reg_pc = 0x04001E58;
	if (state.r[T1] != 0)
	{
		{
			_u32    addr = (0xFFFFFFF0 + state.r[A2]);
			int     shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				*(_u32 *)&pDMEM[addr+12] = state.v[12].U32[0];
				*(_u32 *)&pDMEM[addr+8 ] = state.v[12].U32[1];
				*(_u32 *)&pDMEM[addr+4 ] = state.v[12].U32[2];
				*(_u32 *)&pDMEM[addr   ] = state.v[12].U32[3];
			}
			else
			{
				_u64    value1 = Load64_DMEM(addr+8);
				_u64    value2 = Load64_DMEM(addr);
				_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & ~temp1;
				value2 = value2 & ~temp2;

				value1 |= (state.v[12].U64[0] & temp1);
				value2 |= (state.v[12].U64[1] & temp2);

				Save64_DMEM(value1, addr+8);
				Save64_DMEM(value2, addr  );
			}
		}
		goto _04001E28;
	}


_04001E5C:	// 4001e5c: <e8cc207f>	SQV       [A2 + 0xf0] = vec12 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[A2]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[12].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[12].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[12].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[12].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[12].U64[0] & temp1);
			value2 |= (state.v[12].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001E60:	// 4001e60: <03c00008>	JR        S8
	{
		_u32	temp = ((state.r[S8] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001E64:	// 4001e64: <00000000>	NOP       


_04001E68:	// 4001e68: <3407000c>	ORI       A3 = R0 | 0x000c
	state.r[A3] = (0 | 0x0000000C);


_04001E6C:	// 4001e6c: <c8a72000>	LQV       vec07 <00> = [A1 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[A1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[7].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[7].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[7].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[7].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[7].U64[0] = state.v[7].U64[0] & ~temp1;
			state.v[7].U64[1] = state.v[7].U64[1] & ~temp2;
			state.v[7].U64[0] = state.v[7].U64[0] | value1;
			state.v[7].U64[1] = state.v[7].U64[1] | value2;
		}
	}


_04001E70:	// 4001e70: <c8ac2001>	LQV       vec12 <00> = [A1 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[A1]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[12].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[12].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[12].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[12].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[12].U64[0] = state.v[12].U64[0] & ~temp1;
			state.v[12].U64[1] = state.v[12].U64[1] & ~temp2;
			state.v[12].U64[0] = state.v[12].U64[0] | value1;
			state.v[12].U64[1] = state.v[12].U64[1] | value2;
		}
	}


_04001E74:	// 4001e74: <c8c32000>	LQV       vec03 <00> = [A2 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[A2]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[3].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[3].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[3].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[3].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[3].U64[0] = state.v[3].U64[0] & ~temp1;
			state.v[3].U64[1] = state.v[3].U64[1] & ~temp2;
			state.v[3].U64[0] = state.v[3].U64[0] | value1;
			state.v[3].U64[1] = state.v[3].U64[1] | value2;
		}
	}


_04001E78:	// 4001e78: <4b213880>	VMULF     vec02 = ( acc = (vec07 * vec01[1]) << 1 ) >> 16
	{
		_u16		s2value = state.v[1].U16[6];
		VMULF_operation(0, state.v[2].U16[0], state.v[7].U16[0], s2value, 0, 1, 0, 1)
		VMULF_operation(1, state.v[2].U16[1], state.v[7].U16[1], s2value, 0, 1, 0, 1)
		VMULF_operation(2, state.v[2].U16[2], state.v[7].U16[2], s2value, 0, 1, 0, 1)
		VMULF_operation(3, state.v[2].U16[3], state.v[7].U16[3], s2value, 0, 1, 0, 1)
		VMULF_operation(4, state.v[2].U16[4], state.v[7].U16[4], s2value, 0, 1, 0, 1)
		VMULF_operation(5, state.v[2].U16[5], state.v[7].U16[5], s2value, 0, 1, 0, 1)
		VMULF_operation(6, state.v[2].U16[6], state.v[7].U16[6], s2value, 0, 1, 0, 1)
		VMULF_operation(7, state.v[2].U16[7], state.v[7].U16[7], s2value, 0, 1, 0, 1)
	}


_04001E7C:	// 4001e7c: <c8c42001>	LQV       vec04 <00> = [A2 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[A2]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[4].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[4].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[4].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[4].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[4].U64[0] = state.v[4].U64[0] & ~temp1;
			state.v[4].U64[1] = state.v[4].U64[1] & ~temp2;
			state.v[4].U64[0] = state.v[4].U64[0] | value1;
			state.v[4].U64[1] = state.v[4].U64[1] | value2;
		}
	}


_04001E80:	// 4001e80: <4b0118cf>	VMADH     vec03 = ( acc+= (vec03 * vec01[0]) << 16) >> 16
	{
		_u16		s2value = state.v[1].U16[7];
		VMADH_operation(0, state.v[3].U16[0], state.v[3].U16[0], s2value, 1, 0, 0, 1)
		VMADH_operation(1, state.v[3].U16[1], state.v[3].U16[1], s2value, 1, 0, 0, 1)
		VMADH_operation(2, state.v[3].U16[2], state.v[3].U16[2], s2value, 1, 0, 0, 1)
		VMADH_operation(3, state.v[3].U16[3], state.v[3].U16[3], s2value, 1, 0, 0, 1)
		VMADH_operation(4, state.v[3].U16[4], state.v[3].U16[4], s2value, 1, 0, 0, 1)
		VMADH_operation(5, state.v[3].U16[5], state.v[3].U16[5], s2value, 1, 0, 0, 1)
		VMADH_operation(6, state.v[3].U16[6], state.v[3].U16[6], s2value, 1, 0, 0, 1)
		VMADH_operation(7, state.v[3].U16[7], state.v[3].U16[7], s2value, 1, 0, 0, 1)
	}


_04001E84:	// 4001e84: <4b216080>	VMULF     vec02 = ( acc = (vec12 * vec01[1]) << 1 ) >> 16
	{
		_u16		s2value = state.v[1].U16[6];
		VMULF_operation(0, state.v[2].U16[0], state.v[12].U16[0], s2value, 1, 1, 1, 1)
		VMULF_operation(1, state.v[2].U16[1], state.v[12].U16[1], s2value, 1, 1, 1, 1)
		VMULF_operation(2, state.v[2].U16[2], state.v[12].U16[2], s2value, 1, 1, 1, 1)
		VMULF_operation(3, state.v[2].U16[3], state.v[12].U16[3], s2value, 1, 1, 1, 1)
		VMULF_operation(4, state.v[2].U16[4], state.v[12].U16[4], s2value, 1, 1, 1, 1)
		VMULF_operation(5, state.v[2].U16[5], state.v[12].U16[5], s2value, 1, 1, 1, 1)
		VMULF_operation(6, state.v[2].U16[6], state.v[12].U16[6], s2value, 1, 1, 1, 1)
		VMULF_operation(7, state.v[2].U16[7], state.v[12].U16[7], s2value, 1, 1, 1, 1)
	}


_04001E88:	// 4001e88: <24a50020>	ADDIU     A1 = A1 + 0020
	state.r[A1] = state.r[A1] + 0x0020;


_04001E8C:	// 4001e8c: <4b01210f>	VMADH     vec04 = ( acc+= (vec04 * vec01[0]) << 16) >> 16
	{
		_u16		s2value = state.v[1].U16[7];
		VMADH_operation(0, state.v[4].U16[0], state.v[4].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[4].U16[1], state.v[4].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[4].U16[2], state.v[4].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[4].U16[3], state.v[4].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[4].U16[4], state.v[4].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[4].U16[5], state.v[4].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[4].U16[6], state.v[4].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[4].U16[7], state.v[4].U16[7], s2value, 1, 1, 0, 1)
	}


_04001E90:	// 4001e90: <24e7ffff>	ADDIU     A3 = A3 + ffff
	state.r[A3] = state.r[A3] + 0xFFFFFFFF;


_04001E94:	// 4001e94: <24c60020>	ADDIU     A2 = A2 + 0020
	state.r[A2] = state.r[A2] + 0x0020;


_04001E98:	// 4001e98: <e8c3207e>	SQV       [A2 + 0xe0] = vec03 <00>
	{
		_u32    addr = (0xFFFFFFE0 + state.r[A2]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[3].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[3].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[3].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[3].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[3].U64[0] & temp1);
			value2 |= (state.v[3].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001E9C:	// 4001e9c: <14e0fff3>	BNE       (R0!=A3) --> 1e6c
	sp_reg_pc = 0x04001E9C;
	if (state.r[A3] != 0)
	{
		{
			_u32    addr = (0xFFFFFFF0 + state.r[A2]);
			int     shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				*(_u32 *)&pDMEM[addr+12] = state.v[4].U32[0];
				*(_u32 *)&pDMEM[addr+8 ] = state.v[4].U32[1];
				*(_u32 *)&pDMEM[addr+4 ] = state.v[4].U32[2];
				*(_u32 *)&pDMEM[addr   ] = state.v[4].U32[3];
			}
			else
			{
				_u64    value1 = Load64_DMEM(addr+8);
				_u64    value2 = Load64_DMEM(addr);
				_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & ~temp1;
				value2 = value2 & ~temp2;

				value1 |= (state.v[4].U64[0] & temp1);
				value2 |= (state.v[4].U64[1] & temp2);

				Save64_DMEM(value1, addr+8);
				Save64_DMEM(value2, addr  );
			}
		}
		goto _04001E6C;
	}


_04001EA0:	// 4001ea0: <e8c4207f>	SQV       [A2 + 0xf0] = vec04 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[A2]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[4].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[4].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[4].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[4].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[4].U64[0] & temp1);
			value2 |= (state.v[4].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001EA4:	// 4001ea4: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001EA8:	// 4001ea8: <00000000>	NOP       


_04001EAC:	// 4001eac: <001f4025>	OR        T0 = R0 | RA
	state.r[T0] = (0 | state.r[RA]);


_04001EB0:	// 4001eb0: <34070600>	ORI       A3 = R0 | 0x0600
	state.r[A3] = (0 | 0x00000600);


_04001EB4:	// 4001eb4: <c8ef1808>	LDV       vec15 <00> = [A3 + 0x40]
	rsp_ldv_compiler((state.r[A3] + 0x00000040) & 0xFFF, 15, 8);


_04001EB8:	// 4001eb8: <c8ef1c08>	LDV       vec15 <08> = [A3 + 0x40]
	rsp_ldv_compiler((state.r[A3] + 0x00000040) & 0xFFF, 15, 0);


_04001EBC:	// 4001ebc: <34070d50>	ORI       A3 = R0 | 0x0d50
	state.r[A3] = (0 | 0x00000D50);


_04001EC0:	// 4001ec0: <c8e21800>	LDV       vec02 <00> = [A3 + 0x00]
	rsp_ldv_compiler((state.r[A3] & 0xFFF), 2, 8);


_04001EC4:	// 4001ec4: <24b1fffa>	ADDIU     S1 = A1 + fffa
	state.r[S1] = state.r[A1] + 0xFFFFFFFA;


_04001EC8:	// 4001ec8: <24b2fffc>	ADDIU     S2 = A1 + fffc
	state.r[S2] = state.r[A1] + 0xFFFFFFFC;


_04001ECC:	// 4001ecc: <24b3fffe>	ADDIU     S3 = A1 + fffe
	state.r[S3] = state.r[A1] + 0xFFFFFFFE;


_04001ED0:	// 4001ed0: <24b40000>	ADDIU     S4 = A1 + 0000
	state.r[S4] = state.r[A1] + 0x0000;


_04001ED4:	// 4001ed4: <24b50002>	ADDIU     S5 = A1 + 0002
	state.r[S5] = state.r[A1] + 0x0002;


_04001ED8:	// 4001ed8: <24b60004>	ADDIU     S6 = A1 + 0004
	state.r[S6] = state.r[A1] + 0x0004;


_04001EDC:	// 4001edc: <24b70006>	ADDIU     S7 = A1 + 0006
	state.r[S7] = state.r[A1] + 0x0006;


_04001EE0:	// 4001ee0: <24b80008>	ADDIU     T8 = A1 + 0008
	state.r[T8] = state.r[A1] + 0x0008;


_04001EE4:	// 4001ee4: <e8a2187f>	SDV       [A1 + 0x3c] = vec02 <00>
	{
		_u32	addr = (0xFFFFFFF8 + state.r[A1]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[2].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[2].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[2].U32[0x00000003];
		}
	}


_04001EE8:	// 4001ee8: <24a50178>	ADDIU     A1 = A1 + 0178
	state.r[A1] = state.r[A1] + 0x0178;


_04001EEC:	// 4001eec: <c8a71800>	LDV       vec07 <00> = [A1 + 0x00]
	rsp_ldv_compiler((state.r[A1] & 0xFFF), 7, 8);


_04001EF0:	// 4001ef0: <4b217bc0>	VMULF     vec15 = ( acc = (vec15 * vec01[1]) << 1 ) >> 16
	{
		_u16		s2value = state.v[1].U16[6];
		VMULF_operation(0, state.v[15].U16[0], state.v[15].U16[0], s2value, 1, 1, 1, 1)
		VMULF_operation(1, state.v[15].U16[1], state.v[15].U16[1], s2value, 1, 1, 1, 1)
		VMULF_operation(2, state.v[15].U16[2], state.v[15].U16[2], s2value, 1, 1, 1, 1)
		VMULF_operation(3, state.v[15].U16[3], state.v[15].U16[3], s2value, 1, 1, 1, 1)
		VMULF_operation(4, state.v[15].U16[4], state.v[15].U16[4], s2value, 1, 1, 1, 1)
		VMULF_operation(5, state.v[15].U16[5], state.v[15].U16[5], s2value, 1, 1, 1, 1)
		VMULF_operation(6, state.v[15].U16[6], state.v[15].U16[6], s2value, 1, 1, 1, 1)
		VMULF_operation(7, state.v[15].U16[7], state.v[15].U16[7], s2value, 1, 1, 1, 1)
	}


_04001EF4:	// 4001ef4: <0d0005e5>	JAL	    04001794
	state.r[A1] = (0 | 0x00000001);
	sp_reg_pc = 0x04001EF4;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001794;


_04001EF8:	// 4001ef8: <34050001>	ORI       A1 = R0 | 0x0001
	state.r[A1] = (0 | 0x00000001);


_04001EFC:	// 4001efc: <e8e71800>	SDV       [A3 + 0x00] = vec07 <00>
	{
		_u32	addr = (0x00000000 + state.r[A3]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[7].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[7].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[7].U32[0x00000003];
		}
	}


_04001F00:	// 4001f00: <ca271800>	LDV       vec07 <00> = [S1 + 0x00]
	rsp_ldv_compiler((state.r[S1] & 0xFFF), 7, 8);


_04001F04:	// 4001f04: <caa71c00>	LDV       vec07 <08> = [S5 + 0x00]
	rsp_ldv_compiler((state.r[S5] & 0xFFF), 7, 0);


_04001F08:	// 4001f08: <ca4c1800>	LDV       vec12 <00> = [S2 + 0x00]
	rsp_ldv_compiler((state.r[S2] & 0xFFF), 12, 8);


_04001F0C:	// 4001f0c: <cacc1c00>	LDV       vec12 <08> = [S6 + 0x00]
	rsp_ldv_compiler((state.r[S6] & 0xFFF), 12, 0);


_04001F10:	// 4001f10: <34090018>	ORI       T1 = R0 | 0x0018
	state.r[T1] = (0 | 0x00000018);


_04001F14:	// 4001f14: <ca6d1800>	LDV       vec13 <00> = [S3 + 0x00]
	rsp_ldv_compiler((state.r[S3] & 0xFFF), 13, 8);


_04001F18:	// 4001f18: <caed1c00>	LDV       vec13 <08> = [S7 + 0x00]
	rsp_ldv_compiler((state.r[S7] & 0xFFF), 13, 0);


_04001F1C:	// 4001f1c: <ca8e1800>	LDV       vec14 <00> = [S4 + 0x00]
	rsp_ldv_compiler((state.r[S4] & 0xFFF), 14, 8);


_04001F20:	// 4001f20: <cb0e1c00>	LDV       vec14 <08> = [T8 + 0x00]
	rsp_ldv_compiler((state.r[T8] & 0xFFF), 14, 0);


_04001F24:	// 4001f24: <4a0f39c0>	VMULF     vec07 = ( acc = (vec07 * vec15[<none>]) << 1 ) >> 16
	{
		VMULF_operation(0, state.v[7].U16[0], state.v[7].U16[0], state.v[15].U16[0], 1, 0, 0, 1)
		VMULF_operation(1, state.v[7].U16[1], state.v[7].U16[1], state.v[15].U16[1], 1, 0, 0, 1)
		VMULF_operation(2, state.v[7].U16[2], state.v[7].U16[2], state.v[15].U16[2], 1, 0, 0, 1)
		VMULF_operation(3, state.v[7].U16[3], state.v[7].U16[3], state.v[15].U16[3], 1, 0, 0, 1)
		VMULF_operation(4, state.v[7].U16[4], state.v[7].U16[4], state.v[15].U16[4], 1, 0, 0, 1)
		VMULF_operation(5, state.v[7].U16[5], state.v[7].U16[5], state.v[15].U16[5], 1, 0, 0, 1)
		VMULF_operation(6, state.v[7].U16[6], state.v[7].U16[6], state.v[15].U16[6], 1, 0, 0, 1)
		VMULF_operation(7, state.v[7].U16[7], state.v[7].U16[7], state.v[15].U16[7], 1, 0, 0, 1)
	}


_04001F28:	// 4001f28: <c8d02000>	LQV       vec16 <00> = [A2 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[A2]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[16].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[16].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[16].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[16].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[16].U64[0] = state.v[16].U64[0] & ~temp1;
			state.v[16].U64[1] = state.v[16].U64[1] & ~temp2;
			state.v[16].U64[0] = state.v[16].U64[0] | value1;
			state.v[16].U64[1] = state.v[16].U64[1] | value2;
		}
	}


_04001F2C:	// 4001f2c: <4a0f6300>	VMULF     vec12 = ( acc = (vec12 * vec15[<none>]) << 1 ) >> 16
	{
		VMULF_operation(0, state.v[12].U16[0], state.v[12].U16[0], state.v[15].U16[0], 1, 0, 0, 1)
		VMULF_operation(1, state.v[12].U16[1], state.v[12].U16[1], state.v[15].U16[1], 1, 0, 0, 1)
		VMULF_operation(2, state.v[12].U16[2], state.v[12].U16[2], state.v[15].U16[2], 1, 0, 0, 1)
		VMULF_operation(3, state.v[12].U16[3], state.v[12].U16[3], state.v[15].U16[3], 1, 0, 0, 1)
		VMULF_operation(4, state.v[12].U16[4], state.v[12].U16[4], state.v[15].U16[4], 1, 0, 0, 1)
		VMULF_operation(5, state.v[12].U16[5], state.v[12].U16[5], state.v[15].U16[5], 1, 0, 0, 1)
		VMULF_operation(6, state.v[12].U16[6], state.v[12].U16[6], state.v[15].U16[6], 1, 0, 0, 1)
		VMULF_operation(7, state.v[12].U16[7], state.v[12].U16[7], state.v[15].U16[7], 1, 0, 0, 1)
	}


_04001F30:	// 4001f30: <26310010>	ADDIU     S1 = S1 + 0010
	state.r[S1] = state.r[S1] + 0x0010;


_04001F34:	// 4001f34: <4a0f6b40>	VMULF     vec13 = ( acc = (vec13 * vec15[<none>]) << 1 ) >> 16
	{
		VMULF_operation(0, state.v[13].U16[0], state.v[13].U16[0], state.v[15].U16[0], 1, 0, 0, 1)
		VMULF_operation(1, state.v[13].U16[1], state.v[13].U16[1], state.v[15].U16[1], 1, 0, 0, 1)
		VMULF_operation(2, state.v[13].U16[2], state.v[13].U16[2], state.v[15].U16[2], 1, 0, 0, 1)
		VMULF_operation(3, state.v[13].U16[3], state.v[13].U16[3], state.v[15].U16[3], 1, 0, 0, 1)
		VMULF_operation(4, state.v[13].U16[4], state.v[13].U16[4], state.v[15].U16[4], 1, 0, 0, 1)
		VMULF_operation(5, state.v[13].U16[5], state.v[13].U16[5], state.v[15].U16[5], 1, 0, 0, 1)
		VMULF_operation(6, state.v[13].U16[6], state.v[13].U16[6], state.v[15].U16[6], 1, 0, 0, 1)
		VMULF_operation(7, state.v[13].U16[7], state.v[13].U16[7], state.v[15].U16[7], 1, 0, 0, 1)
	}


_04001F38:	// 4001f38: <26520010>	ADDIU     S2 = S2 + 0010
	state.r[S2] = state.r[S2] + 0x0010;


_04001F3C:	// 4001f3c: <4a0f7380>	VMULF     vec14 = ( acc = (vec14 * vec15[<none>]) << 1 ) >> 16
	{
		VMULF_operation(0, state.v[14].U16[0], state.v[14].U16[0], state.v[15].U16[0], 1, 0, 0, 1)
		VMULF_operation(1, state.v[14].U16[1], state.v[14].U16[1], state.v[15].U16[1], 1, 0, 0, 1)
		VMULF_operation(2, state.v[14].U16[2], state.v[14].U16[2], state.v[15].U16[2], 1, 0, 0, 1)
		VMULF_operation(3, state.v[14].U16[3], state.v[14].U16[3], state.v[15].U16[3], 1, 0, 0, 1)
		VMULF_operation(4, state.v[14].U16[4], state.v[14].U16[4], state.v[15].U16[4], 1, 0, 0, 1)
		VMULF_operation(5, state.v[14].U16[5], state.v[14].U16[5], state.v[15].U16[5], 1, 0, 0, 1)
		VMULF_operation(6, state.v[14].U16[6], state.v[14].U16[6], state.v[15].U16[6], 1, 0, 0, 1)
		VMULF_operation(7, state.v[14].U16[7], state.v[14].U16[7], state.v[15].U16[7], 1, 0, 0, 1)
	}


_04001F40:	// 4001f40: <26730010>	ADDIU     S3 = S3 + 0010
	state.r[S3] = state.r[S3] + 0x0010;


_04001F44:	// 4001f44: <4a6739d0>	VADD      vec07 = vec07 + vec07[1q]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[7].U16[0];
		VADD_operation(0, state.v[7].U16[0], state.v[7].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[7].U16[1], state.v[7].U16[1], s2value, 1, 0, 0, 1)
		s2value = state.v[7].U16[2];
		VADD_operation(2, state.v[7].U16[2], state.v[7].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[7].U16[3], state.v[7].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[7].U16[4];
		VADD_operation(4, state.v[7].U16[4], state.v[7].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[7].U16[5], state.v[7].U16[5], s2value, 1, 0, 0, 1)
		s2value = state.v[7].U16[6];
		VADD_operation(6, state.v[7].U16[6], state.v[7].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[7].U16[7], state.v[7].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001F48:	// 4001f48: <26940010>	ADDIU     S4 = S4 + 0010
	state.r[S4] = state.r[S4] + 0x0010;


_04001F4C:	// 4001f4c: <4a6c6310>	VADD      vec12 = vec12 + vec12[1q]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[12].U16[0];
		VADD_operation(0, state.v[12].U16[0], state.v[12].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[12].U16[1], state.v[12].U16[1], s2value, 1, 0, 0, 1)
		s2value = state.v[12].U16[2];
		VADD_operation(2, state.v[12].U16[2], state.v[12].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[12].U16[3], state.v[12].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[12].U16[4];
		VADD_operation(4, state.v[12].U16[4], state.v[12].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[12].U16[5], state.v[12].U16[5], s2value, 1, 0, 0, 1)
		s2value = state.v[12].U16[6];
		VADD_operation(6, state.v[12].U16[6], state.v[12].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[12].U16[7], state.v[12].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001F50:	// 4001f50: <26b50010>	ADDIU     S5 = S5 + 0010
	state.r[S5] = state.r[S5] + 0x0010;


_04001F54:	// 4001f54: <4a6d6b50>	VADD      vec13 = vec13 + vec13[1q]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[13].U16[0];
		VADD_operation(0, state.v[13].U16[0], state.v[13].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[13].U16[1], state.v[13].U16[1], s2value, 1, 0, 0, 1)
		s2value = state.v[13].U16[2];
		VADD_operation(2, state.v[13].U16[2], state.v[13].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[13].U16[3], state.v[13].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[13].U16[4];
		VADD_operation(4, state.v[13].U16[4], state.v[13].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[13].U16[5], state.v[13].U16[5], s2value, 1, 0, 0, 1)
		s2value = state.v[13].U16[6];
		VADD_operation(6, state.v[13].U16[6], state.v[13].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[13].U16[7], state.v[13].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001F58:	// 4001f58: <26d60010>	ADDIU     S6 = S6 + 0010
	state.r[S6] = state.r[S6] + 0x0010;


_04001F5C:	// 4001f5c: <4a6e7390>	VADD      vec14 = vec14 + vec14[1q]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[14].U16[0];
		VADD_operation(0, state.v[14].U16[0], state.v[14].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[14].U16[1], state.v[14].U16[1], s2value, 1, 0, 0, 1)
		s2value = state.v[14].U16[2];
		VADD_operation(2, state.v[14].U16[2], state.v[14].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[14].U16[3], state.v[14].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[14].U16[4];
		VADD_operation(4, state.v[14].U16[4], state.v[14].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[14].U16[5], state.v[14].U16[5], s2value, 1, 0, 0, 1)
		s2value = state.v[14].U16[6];
		VADD_operation(6, state.v[14].U16[6], state.v[14].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[14].U16[7], state.v[14].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001F60:	// 4001f60: <26f70010>	ADDIU     S7 = S7 + 0010
	state.r[S7] = state.r[S7] + 0x0010;


_04001F64:	// 4001f64: <4ac738d0>	VADD      vec03 = vec07 + vec07[2h]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[7].U16[1];
		VADD_operation(0, state.v[3].U16[0], state.v[7].U16[0], s2value, 0, 0, 0, 1)
		VADD_operation(1, state.v[3].U16[1], state.v[7].U16[1], s2value, 0, 0, 0, 1)
		VADD_operation(2, state.v[3].U16[2], state.v[7].U16[2], s2value, 0, 0, 0, 1)
		VADD_operation(3, state.v[3].U16[3], state.v[7].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[7].U16[5];
		VADD_operation(4, state.v[3].U16[4], state.v[7].U16[4], s2value, 0, 0, 0, 1)
		VADD_operation(5, state.v[3].U16[5], state.v[7].U16[5], s2value, 0, 0, 0, 1)
		VADD_operation(6, state.v[3].U16[6], state.v[7].U16[6], s2value, 0, 0, 0, 1)
		VADD_operation(7, state.v[3].U16[7], state.v[7].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001F68:	// 4001f68: <27180010>	ADDIU     T8 = T8 + 0010
	state.r[T8] = state.r[T8] + 0x0010;


_04001F6C:	// 4001f6c: <4acc6110>	VADD      vec04 = vec12 + vec12[2h]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[12].U16[1];
		VADD_operation(0, state.v[4].U16[0], state.v[12].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[4].U16[1], state.v[12].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[4].U16[2], state.v[12].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[4].U16[3], state.v[12].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[12].U16[5];
		VADD_operation(4, state.v[4].U16[4], state.v[12].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[4].U16[5], state.v[12].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[4].U16[6], state.v[12].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[4].U16[7], state.v[12].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001F70:	// 4001f70: <24c60010>	ADDIU     A2 = A2 + 0010
	state.r[A2] = state.r[A2] + 0x0010;


_04001F74:	// 4001f74: <4acd6950>	VADD      vec05 = vec13 + vec13[2h]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[13].U16[1];
		VADD_operation(0, state.v[5].U16[0], state.v[13].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[5].U16[1], state.v[13].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[5].U16[2], state.v[13].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[5].U16[3], state.v[13].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[13].U16[5];
		VADD_operation(4, state.v[5].U16[4], state.v[13].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[5].U16[5], state.v[13].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[5].U16[6], state.v[13].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[5].U16[7], state.v[13].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001F78:	// 4001f78: <ca271800>	LDV       vec07 <00> = [S1 + 0x00]
	rsp_ldv_compiler((state.r[S1] & 0xFFF), 7, 8);


_04001F7C:	// 4001f7c: <4ace7190>	VADD      vec06 = vec14 + vec14[2h]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value;
		s2value = state.v[14].U16[1];
		VADD_operation(0, state.v[6].U16[0], state.v[14].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[6].U16[1], state.v[14].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[6].U16[2], state.v[14].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[6].U16[3], state.v[14].U16[3], s2value, 1, 0, 0, 1)
		s2value = state.v[14].U16[5];
		VADD_operation(4, state.v[6].U16[4], state.v[14].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[6].U16[5], state.v[14].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[6].U16[6], state.v[14].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[6].U16[7], state.v[14].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001F80:	// 4001f80: <4a8340c7>	VMUDH     vec03 = ( acc = (vec08 * vec03[0h]) << 16) >> 16
	{
		_u16		s2value;
		s2value = state.v[3].U16[3];
		VMUDH_operation(0, state.v[3].U16[0], state.v[8].U16[0], s2value, 0, 1, 1, 1)
		VMUDH_operation(1, state.v[3].U16[1], state.v[8].U16[1], s2value, 0, 1, 1, 1)
		VMUDH_operation(2, state.v[3].U16[2], state.v[8].U16[2], s2value, 0, 1, 1, 1)
		VMUDH_operation(3, state.v[3].U16[3], state.v[8].U16[3], s2value, 0, 1, 1, 1)
		s2value = state.v[3].U16[7];
		VMUDH_operation(4, state.v[3].U16[4], state.v[8].U16[4], s2value, 0, 1, 1, 1)
		VMUDH_operation(5, state.v[3].U16[5], state.v[8].U16[5], s2value, 0, 1, 1, 1)
		VMUDH_operation(6, state.v[3].U16[6], state.v[8].U16[6], s2value, 0, 1, 1, 1)
		VMUDH_operation(7, state.v[3].U16[7], state.v[8].U16[7], s2value, 0, 1, 1, 1)
	}


_04001F84:	// 4001f84: <caa71c00>	LDV       vec07 <08> = [S5 + 0x00]
	rsp_ldv_compiler((state.r[S5] & 0xFFF), 7, 0);


_04001F88:	// 4001f88: <4a8448cf>	VMADH     vec03 = ( acc+= (vec09 * vec04[0h]) << 16) >> 16
	{
		_u16		s2value;
		s2value = state.v[4].U16[3];
		VMADH_operation(0, state.v[3].U16[0], state.v[9].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[3].U16[1], state.v[9].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[3].U16[2], state.v[9].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[3].U16[3], state.v[9].U16[3], s2value, 0, 1, 0, 1)
		s2value = state.v[4].U16[7];
		VMADH_operation(4, state.v[3].U16[4], state.v[9].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[3].U16[5], state.v[9].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[3].U16[6], state.v[9].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[3].U16[7], state.v[9].U16[7], s2value, 0, 1, 0, 1)
	}


_04001F8C:	// 4001f8c: <ca4c1800>	LDV       vec12 <00> = [S2 + 0x00]
	rsp_ldv_compiler((state.r[S2] & 0xFFF), 12, 8);


_04001F90:	// 4001f90: <4a8550cf>	VMADH     vec03 = ( acc+= (vec10 * vec05[0h]) << 16) >> 16
	{
		_u16		s2value;
		s2value = state.v[5].U16[3];
		VMADH_operation(0, state.v[3].U16[0], state.v[10].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[3].U16[1], state.v[10].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[3].U16[2], state.v[10].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[3].U16[3], state.v[10].U16[3], s2value, 0, 1, 0, 1)
		s2value = state.v[5].U16[7];
		VMADH_operation(4, state.v[3].U16[4], state.v[10].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[3].U16[5], state.v[10].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[3].U16[6], state.v[10].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[3].U16[7], state.v[10].U16[7], s2value, 0, 1, 0, 1)
	}


_04001F94:	// 4001f94: <cacc1c00>	LDV       vec12 <08> = [S6 + 0x00]
	rsp_ldv_compiler((state.r[S6] & 0xFFF), 12, 0);


_04001F98:	// 4001f98: <4a8658cf>	VMADH     vec03 = ( acc+= (vec11 * vec06[0h]) << 16) >> 16
	{
		_u16		s2value;
		s2value = state.v[6].U16[3];
		VMADH_operation(0, state.v[3].U16[0], state.v[11].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[3].U16[1], state.v[11].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[3].U16[2], state.v[11].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[3].U16[3], state.v[11].U16[3], s2value, 1, 1, 0, 1)
		s2value = state.v[6].U16[7];
		VMADH_operation(4, state.v[3].U16[4], state.v[11].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[3].U16[5], state.v[11].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[3].U16[6], state.v[11].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[3].U16[7], state.v[11].U16[7], s2value, 1, 1, 0, 1)
	}


_04001F9C:	// 4001f9c: <4b01840f>	VMADH     vec16 = ( acc+= (vec16 * vec01[0]) << 16) >> 16
	{
		_u16		s2value = state.v[1].U16[7];
		VMADH_operation(0, state.v[16].U16[0], state.v[16].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[16].U16[1], state.v[16].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[16].U16[2], state.v[16].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[16].U16[3], state.v[16].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[16].U16[4], state.v[16].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[16].U16[5], state.v[16].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[16].U16[6], state.v[16].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[16].U16[7], state.v[16].U16[7], s2value, 1, 1, 0, 1)
	}


_04001FA0:	// 4001fa0: <2529ffff>	ADDIU     T1 = T1 + ffff
	state.r[T1] = state.r[T1] + 0xFFFFFFFF;


_04001FA4:	// 4001fa4: <1520ffdb>	BNE       (R0!=T1) --> 1f14
	sp_reg_pc = 0x04001FA4;
	if (state.r[T1] != 0)
	{
		{
			_u32    addr = (0xFFFFFFF0 + state.r[A2]);
			int     shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				*(_u32 *)&pDMEM[addr+12] = state.v[16].U32[0];
				*(_u32 *)&pDMEM[addr+8 ] = state.v[16].U32[1];
				*(_u32 *)&pDMEM[addr+4 ] = state.v[16].U32[2];
				*(_u32 *)&pDMEM[addr   ] = state.v[16].U32[3];
			}
			else
			{
				_u64    value1 = Load64_DMEM(addr+8);
				_u64    value2 = Load64_DMEM(addr);
				_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & ~temp1;
				value2 = value2 & ~temp2;

				value1 |= (state.v[16].U64[0] & temp1);
				value2 |= (state.v[16].U64[1] & temp2);

				Save64_DMEM(value1, addr+8);
				Save64_DMEM(value2, addr  );
			}
		}
		goto _04001F14;
	}


_04001FA8:	// 4001fa8: <e8d0207f>	SQV       [A2 + 0xf0] = vec16 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[A2]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[16].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[16].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[16].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[16].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[16].U64[0] & temp1);
			value2 |= (state.v[16].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001FAC:	// 4001fac: <01000008>	JR        T0
	{
		_u32	temp = ((state.r[T0] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001FB0:	// 4001fb0: <00000000>	NOP       


_04001FB4:	// 4001fb4: <00000000>	NOP       


_04001FB8:	// 4001fb8: <00000000>	NOP       


_04001FBC:	// 4001fbc: <00000000>	NOP       


_04001FC0:	// 4001fc0: <00000000>	NOP       


_04001FC4:	// 4001fc4: <00000000>	NOP       


_04001FC8:	// 4001fc8: <00000000>	NOP       


_04001FCC:	// 4001fcc: <00000000>	NOP       


_04001FD0:	// 4001fd0: <00410042>	SRL       R0 = AT >> 1
	; //0 = ((_u32)state.r[AT] >> 1);



_04001FD4:	// 4001fd4: <00400044>	SLLV      R0 = R0 << V0
	; //0 = (0 << (state.r[V0] & 0x1F));



_04001FD8:	// 4001fd8: <0043007e>	SPECIAL RESERVED


_04001FDC:	// 4001fdc: <00470048>	JR        V0
	{
		_u32	temp = ((state.r[V0] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001FE0:	// 4001fe0: <0046004a>	SPECIAL RESERVED

_04001FE4:
_04001FE8:
_04001FEC:
_04001FF0:
_04001FF4:
_04001FF8:
_04001FFC:
	state.halt = 1;
	return;

	_BuildJumpTable:
	#include "jumptable.h"
	goto _Label;
}
