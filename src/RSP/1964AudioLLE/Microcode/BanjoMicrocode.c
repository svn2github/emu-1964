//RSP microcode

#include "../../Shared/rsp_prefix.h"
#include "../../Shared/rsp_macros.h"
#include "Microcode.h"

void _BanjoData(_u32 StartAddress);

void Banjo1BE8_1C4C(void);

void _BanjoBootCode(_u32 StartAddress)
{
	static _u32	JumpTable[(0x1000 >> 2)];
	static _u32	BuildJumpTable = 0;

	if (!BuildJumpTable)
	{
		BuildJumpTable = 1;
		goto _BuildJumpTable;
	}

	_Label:
	StartAddress = JumpTable[(StartAddress & 0x0FFF) >> 2];
	__asm mov eax, StartAddress
	__asm jmp eax


_04001000:	// 4001000: <09000419>	J         04001064
	state.r[AT] = 0 + 0x0FC0;
	goto _04001064;


_04001004:	// 4001004: <20010fc0>	ADDI      AT = R0 + 0fc0
	state.r[AT] = 0 + 0x0FC0;


_04001008:	// 4001008: <8c220010>	LW        V0 = [AT+0010]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000010) & 0xfff);


_0400100C:	// 400100c: <20030f7f>	ADDI      V1 = R0 + 0f7f
	state.r[V1] = 0 + 0x0F7F;


_04001010:	// 4001010: <20071080>	ADDI      A3 = R0 + 1080
	state.r[A3] = 0 + 0x1080;


_04001014:	// 4001014: <40870000>	MTC0      SP memory address = A3
	DMEM_Address = state.r[A3];


_04001018:	// 4001018: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_0400101C:	// 400101c: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x04001020;
	_BanjoData(0x04001020);
	return;


_04001020:	// 4001020: <40043000>	MFC0      A2 = SP status
	state.r[A0] = 0;


_04001024:	// 4001024: <1480fffe>	BNE       (R0!=A0) --> 1020
	sp_reg_pc = 0x04001024;
	if (state.r[A0] != 0)
	{
		goto _04001020;
	}


_04001028:	// 4001028: <00000000>	NOP       


_0400102C:	// 400102c: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x0400102C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_04001030:	// 4001030: <00000000>	NOP       


_04001034:	// 4001034: <00e00008>	JR        A3
	{
		_u32	temp = ((state.r[A3] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001038:	// 4001038: <40803800>	MTC0      SP semaphore = R0


_0400103C:	// 400103c: <40082000>	MFC0      A0 = DP CMD DMA start
	state.r[T0] = 0;


_04001040:	// 4001040: <31080080>	ANDI      T0 = T0 & 0080
	state.r[T0] = (state.r[T0] & 0x00000080);


_04001044:	// 4001044: <15000002>	BNE       (R0!=T0) --> 1050
	sp_reg_pc = 0x04001044;
	if (state.r[T0] != 0)
	{
		goto _04001050;
	}


_04001048:	// 4001048: <00000000>	NOP       


_0400104C:	// 400104c: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001050:	// 4001050: <40803800>	MTC0      SP semaphore = R0


_04001054:	// 4001054: <34085200>	ORI       T0 = R0 | 0x5200
	state.r[T0] = (0 | 0x00005200);


_04001058:	// 4001058: <40882000>	MTC0      SP status = T0


_0400105C:	// 400105c: <0000000d>	BREAK
	state.halt = 1;
	return;


_04001060:	// 4001060: <00000000>	NOP       


_04001064:	// 4001064: <8c220004>	LW        V0 = [AT+0004]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000004) & 0xfff);


_04001068:	// 4001068: <30420002>	ANDI      V0 = V0 & 0002
	state.r[V0] = (state.r[V0] & 0x00000002);


_0400106C:	// 400106c: <10400007>	BEQ       (R0==V0) --> 108c
	sp_reg_pc = 0x0400106C;
	if (state.r[V0] == 0)
	{
		goto _0400108C;
	}


_04001070:	// 4001070: <00000000>	NOP       


_04001074:	// 4001074: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x04001074;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_04001078:	// 4001078: <00000000>	NOP       


_0400107C:	// 400107c: <40025800>	MFC0      T3 = SP read DMA length
	state.r[V0] = 0;


_04001080:	// 4001080: <30420100>	ANDI      V0 = V0 & 0100
	state.r[V0] = (state.r[V0] & 0x00000100);


_04001084:	// 4001084: <1c40ffed>	BGTZ      (R0>0) --> 103c
	sp_reg_pc = 0x04001084;
	if((_s32)state.r[V0] > 0)
	{
		goto _0400103C;
	}


_04001088:	// 4001088: <00000000>	NOP       


_0400108C:	// 400108c: <8c220018>	LW        V0 = [AT+0018]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000018) & 0xfff);


_04001090:	// 4001090: <8c23001c>	LW        V1 = [AT+001c]
	state.r[V1] = (_s32)Load32_DMEM((state.r[AT] + 0x0000001C) & 0xfff);


_04001094:	// 4001094: <2063ffff>	ADDI      V1 = V1 + ffff
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;


_04001098:	// 4001098: <401e2800>	MFC0      A1 = unknown
	state.r[S8] = 0;


_0400109C:	// 400109c: <17c0fffe>	BNE       (R0!=S8) --> 1098
	sp_reg_pc = 0x0400109C;
	if (state.r[S8] != 0)
	{
		goto _04001098;
	}


_040010A0:	// 40010a0: <00000000>	NOP       


_040010A4:	// 40010a4: <40800000>	MTC0      SP memory address = R0
	DMEM_Address = 0;


_040010A8:	// 40010a8: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_040010AC:	// 40010ac: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x040010AC;
	DMARead(state.r[V1]);


_040010B0:	// 40010b0: <40043000>	MFC0      A2 = SP status
	state.r[A0] = 0;


_040010B4:	// 40010b4: <1480fffe>	BNE       (R0!=A0) --> 10b0
	sp_reg_pc = 0x040010B4;
	if (state.r[A0] != 0)
	{
		goto _040010B0;
	}


_040010B8:	// 40010b8: <00000000>	NOP       


_040010BC:	// 40010bc: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x040010BC;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_040010C0:	// 40010c0: <00000000>	NOP       


_040010C4:	// 40010c4: <09000402>	J         04001008
	goto _04001008;


_040010C8:	// 40010c8: <00000000>	NOP       


_040010CC:	// 40010cc: <02001001>	SPECIAL RESERVED


_040010D0:	// 40010d0: <400a0088>	MFC0      R0 = DP CMD DMA current
	state.r[T2] = 0;


_040010D4:	// 40010d4: <04402202>	BLTZ ?-?
	sp_reg_pc = 0x040010D4;
	if (state.r[V0] < 0)
	{
		state.halt = 1;
		return;
	}


_040010D8:	// 40010d8: <081041ff>	J         004107fc
	state.halt = 1;
	return;


_040010DC:	// 40010dc: <08084044>	J         00210110
	state.halt = 1;
	return;


_040010E0:	// 40010e0: <0120087f>	SPECIAL RESERVED


_040010E4:	// 40010e4: <02041010>	SPECIAL RESERVED


_040010E8:	// 40010e8: <80840420>	LB        A0 = [A0+0420]
	state.r[A0] = (_s32)(_s8)pDMEM[((state.r[A0] + 0x00000420) & 0xfff) ^ 3];


_040010EC:	// 40010ec: <41fe0808>	COP0 RESERVED


_040010F0:	// 40010f0: <40220110>	COP0 RESERVED


_040010F4:	// 40010f4: <08804404>	J         02011010
	; //0 = 0x07000000;

	state.halt = 1;
	return;


_040010F8:	// 40010f8: <3fc00700>	LUI       R0 = 0x07000000
	; //0 = 0x07000000;


_040010FC:
_04001100:
_04001104:
_04001108:
_0400110C:
_04001110:
_04001114:
_04001118:
_0400111C:
_04001120:
_04001124:
_04001128:
_0400112C:
_04001130:
_04001134:
_04001138:
_0400113C:
_04001140:
_04001144:
_04001148:
_0400114C:
_04001150:
_04001154:
_04001158:
_0400115C:
_04001160:
_04001164:
_04001168:
_0400116C:
_04001170:
_04001174:
_04001178:
_0400117C:
_04001180:
_04001184:
_04001188:
_0400118C:
_04001190:
_04001194:
_04001198:
_0400119C:
_040011A0:
_040011A4:
_040011A8:
_040011AC:
_040011B0:
_040011B4:
_040011B8:
_040011BC:
_040011C0:
_040011C4:
_040011C8:
_040011CC:
_040011D0:
_040011D4:
_040011D8:
_040011DC:
_040011E0:
_040011E4:
_040011E8:
_040011EC:
_040011F0:
_040011F4:
_040011F8:
_040011FC:
_04001200:
_04001204:
_04001208:
_0400120C:
_04001210:
_04001214:
_04001218:
_0400121C:
_04001220:
_04001224:
_04001228:
_0400122C:
_04001230:
_04001234:
_04001238:
_0400123C:
_04001240:
_04001244:
_04001248:
_0400124C:
_04001250:
_04001254:
_04001258:
_0400125C:
_04001260:
_04001264:
_04001268:
_0400126C:
_04001270:
_04001274:
_04001278:
_0400127C:
_04001280:
_04001284:
_04001288:
_0400128C:
_04001290:
_04001294:
_04001298:
_0400129C:
_040012A0:
_040012A4:
_040012A8:
_040012AC:
_040012B0:
_040012B4:
_040012B8:
_040012BC:
_040012C0:
_040012C4:
_040012C8:
_040012CC:
_040012D0:
_040012D4:
_040012D8:
_040012DC:
_040012E0:
_040012E4:
_040012E8:
_040012EC:
_040012F0:
_040012F4:
_040012F8:
_040012FC:
_04001300:
_04001304:
_04001308:
_0400130C:
_04001310:
_04001314:
_04001318:
_0400131C:
_04001320:
_04001324:
_04001328:
_0400132C:
_04001330:
_04001334:
_04001338:
_0400133C:
_04001340:
_04001344:
_04001348:
_0400134C:
_04001350:
_04001354:
_04001358:
_0400135C:
_04001360:
_04001364:
_04001368:
_0400136C:
_04001370:
_04001374:
_04001378:
_0400137C:
_04001380:
_04001384:
_04001388:
_0400138C:
_04001390:
_04001394:
_04001398:
_0400139C:
_040013A0:
_040013A4:
_040013A8:
_040013AC:
_040013B0:
_040013B4:
_040013B8:
_040013BC:
_040013C0:
_040013C4:
_040013C8:
_040013CC:
_040013D0:
_040013D4:
_040013D8:
_040013DC:
_040013E0:
_040013E4:
_040013E8:
_040013EC:
_040013F0:
_040013F4:
_040013F8:
_040013FC:
_04001400:
_04001404:
_04001408:
_0400140C:
_04001410:
_04001414:
_04001418:
_0400141C:
_04001420:
_04001424:
_04001428:
_0400142C:
_04001430:
_04001434:
_04001438:
_0400143C:
_04001440:
_04001444:
_04001448:
_0400144C:
_04001450:
_04001454:
_04001458:
_0400145C:
_04001460:
_04001464:
_04001468:
_0400146C:
_04001470:
_04001474:
_04001478:
_0400147C:
_04001480:
_04001484:
_04001488:
_0400148C:
_04001490:
_04001494:
_04001498:
_0400149C:
_040014A0:
_040014A4:
_040014A8:
_040014AC:
_040014B0:
_040014B4:
_040014B8:
_040014BC:
_040014C0:
_040014C4:
_040014C8:
_040014CC:
_040014D0:
_040014D4:
_040014D8:
_040014DC:
_040014E0:
_040014E4:
_040014E8:
_040014EC:
_040014F0:
_040014F4:
_040014F8:
_040014FC:
_04001500:
_04001504:
_04001508:
_0400150C:
_04001510:
_04001514:
_04001518:
_0400151C:
_04001520:
_04001524:
_04001528:
_0400152C:
_04001530:
_04001534:
_04001538:
_0400153C:
_04001540:
_04001544:
_04001548:
_0400154C:
_04001550:
_04001554:
_04001558:
_0400155C:
_04001560:
_04001564:
_04001568:
_0400156C:
_04001570:
_04001574:
_04001578:
_0400157C:
_04001580:
_04001584:
_04001588:
_0400158C:
_04001590:
_04001594:
_04001598:
_0400159C:
_040015A0:
_040015A4:
_040015A8:
_040015AC:
_040015B0:
_040015B4:
_040015B8:
_040015BC:
_040015C0:
_040015C4:
_040015C8:
_040015CC:
_040015D0:
_040015D4:
_040015D8:
_040015DC:
_040015E0:
_040015E4:
_040015E8:
_040015EC:
_040015F0:
_040015F4:
_040015F8:
_040015FC:
_04001600:
_04001604:
_04001608:
_0400160C:
_04001610:
_04001614:
_04001618:
_0400161C:
_04001620:
_04001624:
_04001628:
_0400162C:
_04001630:
_04001634:
_04001638:
_0400163C:
_04001640:
_04001644:
_04001648:
_0400164C:
_04001650:
_04001654:
_04001658:
_0400165C:
_04001660:
_04001664:
_04001668:
_0400166C:
_04001670:
_04001674:
_04001678:
_0400167C:
_04001680:
_04001684:
_04001688:
_0400168C:
_04001690:
_04001694:
_04001698:
_0400169C:
_040016A0:
_040016A4:
_040016A8:
_040016AC:
_040016B0:
_040016B4:
_040016B8:
_040016BC:
_040016C0:
_040016C4:
_040016C8:
_040016CC:
_040016D0:
_040016D4:
_040016D8:
_040016DC:
_040016E0:
_040016E4:
_040016E8:
_040016EC:
_040016F0:
_040016F4:
_040016F8:
_040016FC:
_04001700:
_04001704:
_04001708:
_0400170C:
_04001710:
_04001714:
_04001718:
_0400171C:
_04001720:
_04001724:
_04001728:
_0400172C:
_04001730:
_04001734:
_04001738:
_0400173C:
_04001740:
_04001744:
_04001748:
_0400174C:
_04001750:
_04001754:
_04001758:
_0400175C:
_04001760:
_04001764:
_04001768:
_0400176C:
_04001770:
_04001774:
_04001778:
_0400177C:
_04001780:
_04001784:
_04001788:
_0400178C:
_04001790:
_04001794:
_04001798:
_0400179C:
_040017A0:
_040017A4:
_040017A8:
_040017AC:
_040017B0:
_040017B4:
_040017B8:
_040017BC:
_040017C0:
_040017C4:
_040017C8:
_040017CC:
_040017D0:
_040017D4:
_040017D8:
_040017DC:
_040017E0:
_040017E4:
_040017E8:
_040017EC:
_040017F0:
_040017F4:
_040017F8:
_040017FC:
_04001800:
_04001804:
_04001808:
_0400180C:
_04001810:
_04001814:
_04001818:
_0400181C:
_04001820:
_04001824:
_04001828:
_0400182C:
_04001830:
_04001834:
_04001838:
_0400183C:
_04001840:
_04001844:
_04001848:
_0400184C:
_04001850:
_04001854:
_04001858:
_0400185C:
_04001860:
_04001864:
_04001868:
_0400186C:
_04001870:
_04001874:
_04001878:
_0400187C:
_04001880:
_04001884:
_04001888:
_0400188C:
_04001890:
_04001894:
_04001898:
_0400189C:
_040018A0:
_040018A4:
_040018A8:
_040018AC:
_040018B0:
_040018B4:
_040018B8:
_040018BC:
_040018C0:
_040018C4:
_040018C8:
_040018CC:
_040018D0:
_040018D4:
_040018D8:
_040018DC:
_040018E0:
_040018E4:
_040018E8:
_040018EC:
_040018F0:
_040018F4:
_040018F8:
_040018FC:
_04001900:
_04001904:
_04001908:
_0400190C:
_04001910:
_04001914:
_04001918:
_0400191C:
_04001920:
_04001924:
_04001928:
_0400192C:
_04001930:
_04001934:
_04001938:
_0400193C:
_04001940:
_04001944:
_04001948:
_0400194C:
_04001950:
_04001954:
_04001958:
_0400195C:
_04001960:
_04001964:
_04001968:
_0400196C:
_04001970:
_04001974:
_04001978:
_0400197C:
_04001980:
_04001984:
_04001988:
_0400198C:
_04001990:
_04001994:
_04001998:
_0400199C:
_040019A0:
_040019A4:
_040019A8:
_040019AC:
_040019B0:
_040019B4:
_040019B8:
_040019BC:
_040019C0:
_040019C4:
_040019C8:
_040019CC:
_040019D0:
_040019D4:
_040019D8:
_040019DC:
_040019E0:
_040019E4:
_040019E8:
_040019EC:
_040019F0:
_040019F4:
_040019F8:
_040019FC:
_04001A00:
_04001A04:
_04001A08:
_04001A0C:
_04001A10:
_04001A14:
_04001A18:
_04001A1C:
_04001A20:
_04001A24:
_04001A28:
_04001A2C:
_04001A30:
_04001A34:
_04001A38:
_04001A3C:
_04001A40:
_04001A44:
_04001A48:
_04001A4C:
_04001A50:
_04001A54:
_04001A58:
_04001A5C:
_04001A60:
_04001A64:
_04001A68:
_04001A6C:
_04001A70:
_04001A74:
_04001A78:
_04001A7C:
_04001A80:
_04001A84:
_04001A88:
_04001A8C:
_04001A90:
_04001A94:
_04001A98:
_04001A9C:
_04001AA0:
_04001AA4:
_04001AA8:
_04001AAC:
_04001AB0:
_04001AB4:
_04001AB8:
_04001ABC:
_04001AC0:
_04001AC4:
_04001AC8:
_04001ACC:
_04001AD0:
_04001AD4:
_04001AD8:
_04001ADC:
_04001AE0:
_04001AE4:
_04001AE8:
_04001AEC:
_04001AF0:
_04001AF4:
_04001AF8:
_04001AFC:
_04001B00:
_04001B04:
_04001B08:
_04001B0C:
_04001B10:
_04001B14:
_04001B18:
_04001B1C:
_04001B20:
_04001B24:
_04001B28:
_04001B2C:
_04001B30:
_04001B34:
_04001B38:
_04001B3C:
_04001B40:
_04001B44:
_04001B48:
_04001B4C:
_04001B50:
_04001B54:
_04001B58:
_04001B5C:
_04001B60:
_04001B64:
_04001B68:
_04001B6C:
_04001B70:
_04001B74:
_04001B78:
_04001B7C:
_04001B80:
_04001B84:
_04001B88:
_04001B8C:
_04001B90:
_04001B94:
_04001B98:
_04001B9C:
_04001BA0:
_04001BA4:
_04001BA8:
_04001BAC:
_04001BB0:
_04001BB4:
_04001BB8:
_04001BBC:
_04001BC0:
_04001BC4:
_04001BC8:
_04001BCC:
_04001BD0:
_04001BD4:
_04001BD8:
_04001BDC:
_04001BE0:
_04001BE4:
_04001BE8:
_04001BEC:
_04001BF0:
_04001BF4:
_04001BF8:
_04001BFC:
_04001C00:
_04001C04:
_04001C08:
_04001C0C:
_04001C10:
_04001C14:
_04001C18:
_04001C1C:
_04001C20:
_04001C24:
_04001C28:
_04001C2C:
_04001C30:
_04001C34:
_04001C38:
_04001C3C:
_04001C40:
_04001C44:
_04001C48:
_04001C4C:
_04001C50:
_04001C54:
_04001C58:
_04001C5C:
_04001C60:
_04001C64:
_04001C68:
_04001C6C:
_04001C70:
_04001C74:
_04001C78:
_04001C7C:
_04001C80:
_04001C84:
_04001C88:
_04001C8C:
_04001C90:
_04001C94:
_04001C98:
_04001C9C:
_04001CA0:
_04001CA4:
_04001CA8:
_04001CAC:
_04001CB0:
_04001CB4:
_04001CB8:
_04001CBC:
_04001CC0:
_04001CC4:
_04001CC8:
_04001CCC:
_04001CD0:
_04001CD4:
_04001CD8:
_04001CDC:
_04001CE0:
_04001CE4:
_04001CE8:
_04001CEC:
_04001CF0:
_04001CF4:
_04001CF8:
_04001CFC:
_04001D00:
_04001D04:
_04001D08:
_04001D0C:
_04001D10:
_04001D14:
_04001D18:
_04001D1C:
_04001D20:
_04001D24:
_04001D28:
_04001D2C:
_04001D30:
_04001D34:
_04001D38:
_04001D3C:
_04001D40:
_04001D44:
_04001D48:
_04001D4C:
_04001D50:
_04001D54:
_04001D58:
_04001D5C:
_04001D60:
_04001D64:
_04001D68:
_04001D6C:
_04001D70:
_04001D74:
_04001D78:
_04001D7C:
_04001D80:
_04001D84:
_04001D88:
_04001D8C:
_04001D90:
_04001D94:
_04001D98:
_04001D9C:
_04001DA0:
_04001DA4:
_04001DA8:
_04001DAC:
_04001DB0:
_04001DB4:
_04001DB8:
_04001DBC:
_04001DC0:
_04001DC4:
_04001DC8:
_04001DCC:
_04001DD0:
_04001DD4:
_04001DD8:
_04001DDC:
_04001DE0:
_04001DE4:
_04001DE8:
_04001DEC:
_04001DF0:
_04001DF4:
_04001DF8:
_04001DFC:
_04001E00:
_04001E04:
_04001E08:
_04001E0C:
_04001E10:
_04001E14:
_04001E18:
_04001E1C:
_04001E20:
_04001E24:
_04001E28:
_04001E2C:
_04001E30:
_04001E34:
_04001E38:
_04001E3C:
_04001E40:
_04001E44:
_04001E48:
_04001E4C:
_04001E50:
_04001E54:
_04001E58:
_04001E5C:
_04001E60:
_04001E64:
_04001E68:
_04001E6C:
_04001E70:
_04001E74:
_04001E78:
_04001E7C:
_04001E80:
_04001E84:
_04001E88:
_04001E8C:
_04001E90:
_04001E94:
_04001E98:
_04001E9C:
_04001EA0:
_04001EA4:
_04001EA8:
_04001EAC:
_04001EB0:
_04001EB4:
_04001EB8:
_04001EBC:
_04001EC0:
_04001EC4:
_04001EC8:
_04001ECC:
_04001ED0:
_04001ED4:
_04001ED8:
_04001EDC:
_04001EE0:
_04001EE4:
_04001EE8:
_04001EEC:
_04001EF0:
_04001EF4:
_04001EF8:
_04001EFC:
_04001F00:
_04001F04:
_04001F08:
_04001F0C:
_04001F10:
_04001F14:
_04001F18:
_04001F1C:
_04001F20:
_04001F24:
_04001F28:
_04001F2C:
_04001F30:
_04001F34:
_04001F38:
_04001F3C:
_04001F40:
_04001F44:
_04001F48:
_04001F4C:
_04001F50:
_04001F54:
_04001F58:
_04001F5C:
_04001F60:
_04001F64:
_04001F68:
_04001F6C:
_04001F70:
_04001F74:
_04001F78:
_04001F7C:
_04001F80:
_04001F84:
_04001F88:
_04001F8C:
_04001F90:
_04001F94:
_04001F98:
_04001F9C:
_04001FA0:
_04001FA4:
_04001FA8:
_04001FAC:
_04001FB0:
_04001FB4:
_04001FB8:
_04001FBC:
_04001FC0:
_04001FC4:
_04001FC8:
_04001FCC:
_04001FD0:
_04001FD4:
_04001FD8:
_04001FDC:
_04001FE0:
_04001FE4:
_04001FE8:
_04001FEC:
_04001FF0:
_04001FF4:
_04001FF8:
_04001FFC:
	state.halt = 1;
	return;

	_BuildJumpTable:
	#include "jumptable.h"
	goto _Label;
}

void _BanjoData(_u32 StartAddress)
{
	static _u32	JumpTable[(0x1000 >> 2)];
	static _u32	BuildJumpTable = 0;

	if (!BuildJumpTable)
	{
		BuildJumpTable = 1;
		goto _BuildJumpTable;
	}

	_Label:
	StartAddress = JumpTable[(StartAddress & 0x0FFF) >> 2];
	__asm mov eax, StartAddress
	__asm jmp eax


_04001000:	// 4001000: <09000419>	J         04001064
	state.r[AT] = 0 + 0x0FC0;
	goto _04001064;


_04001004:	// 4001004: <20010fc0>	ADDI      AT = R0 + 0fc0
	state.r[AT] = 0 + 0x0FC0;


_04001008:	// 4001008: <8c220010>	LW        V0 = [AT+0010]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000010) & 0xfff);


_0400100C:	// 400100c: <20030f7f>	ADDI      V1 = R0 + 0f7f
	state.r[V1] = 0 + 0x0F7F;


_04001010:	// 4001010: <20071080>	ADDI      A3 = R0 + 1080
	state.r[A3] = 0 + 0x1080;


_04001014:	// 4001014: <40870000>	MTC0      SP memory address = A3
	DMEM_Address = state.r[A3];


_04001018:	// 4001018: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_0400101C:	// 400101c: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x04001020;
	_BanjoData(0x04001020);
	return;


_04001020:	// 4001020: <40043000>	MFC0      A2 = SP status
	state.r[A0] = 0;


_04001024:	// 4001024: <1480fffe>	BNE       (R0!=A0) --> 1020
	sp_reg_pc = 0x04001024;
	if (state.r[A0] != 0)
	{
		goto _04001020;
	}


_04001028:	// 4001028: <00000000>	NOP       


_0400102C:	// 400102c: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x0400102C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_04001030:	// 4001030: <00000000>	NOP       


_04001034:	// 4001034: <00e00008>	JR        A3
	{
		_u32	temp = ((state.r[A3] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001038:	// 4001038: <40803800>	MTC0      SP semaphore = R0


_0400103C:	// 400103c: <40082000>	MFC0      A0 = DP CMD DMA start
	state.r[T0] = 0;


_04001040:	// 4001040: <31080080>	ANDI      T0 = T0 & 0080
	state.r[T0] = (state.r[T0] & 0x00000080);


_04001044:	// 4001044: <15000002>	BNE       (R0!=T0) --> 1050
	sp_reg_pc = 0x04001044;
	if (state.r[T0] != 0)
	{
		goto _04001050;
	}


_04001048:	// 4001048: <00000000>	NOP       


_0400104C:	// 400104c: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001050:	// 4001050: <40803800>	MTC0      SP semaphore = R0


_04001054:	// 4001054: <34085200>	ORI       T0 = R0 | 0x5200
	state.r[T0] = (0 | 0x00005200);


_04001058:	// 4001058: <40882000>	MTC0      SP status = T0


_0400105C:	// 400105c: <0000000d>	BREAK
	state.halt = 1;
	return;


_04001060:	// 4001060: <00000000>	NOP       


_04001064:	// 4001064: <8c220004>	LW        V0 = [AT+0004]
	state.r[V0] = (_s32)Load32_DMEM((state.r[AT] + 0x00000004) & 0xfff);


_04001068:	// 4001068: <30420002>	ANDI      V0 = V0 & 0002
	state.r[V0] = (state.r[V0] & 0x00000002);


_0400106C:	// 400106c: <10400007>	BEQ       (R0==V0) --> 108c
	sp_reg_pc = 0x0400106C;
	if (state.r[V0] == 0)
	{
		goto _0400108C;
	}


_04001070:	// 4001070: <00000000>	NOP       


_04001074:	// 4001074: <0d00040f>	JAL	    0400103c
	sp_reg_pc = 0x04001074;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400103C;


_04001078:	// 4001078: <00000000>	NOP       


_0400107C:	// 400107c: <40025800>	MFC0      T3 = SP read DMA length
	state.r[V0] = 0;


_04001080:	// 4001080: <40055800>	MFC0      T3 = SP DMA full
	state.r[A1] = 0;


_04001084:	// 4001084: <8c3c0030>	LW        GP = [AT+0030]
	state.r[GP] = (_s32)Load32_DMEM((state.r[AT] + 0x00000030) & 0xfff);


_04001088:	// 4001088: <8c3b0034>	LW        K1 = [AT+0034]
	state.r[K1] = (_s32)Load32_DMEM((state.r[AT] + 0x00000034) & 0xfff);


_0400108C:	// 400108c: <30a40001>	ANDI      A0 = A1 & 0001
	state.r[A0] = (state.r[A1] & 0x00000001);


_04001090:	// 4001090: <10800006>	BEQ       (R0==A0) --> 10ac
	sp_reg_pc = 0x04001090;
	if (state.r[A0] == 0)
	{
		state.r[A0] = (state.r[A1] & 0x00000100);
		goto _040010AC;
	}


_04001094:	// 4001094: <30a40100>	ANDI      A0 = A1 & 0100
	state.r[A0] = (state.r[A1] & 0x00000100);


_04001098:	// 4001098: <10800004>	BEQ       (R0==A0) --> 10ac
	sp_reg_pc = 0x04001098;
	if (state.r[A0] == 0)
	{
		state.r[A0] = 0;
		goto _040010AC;
	}


_0400109C:	// 400109c: <40045800>	MFC0      T3 = SP status
	state.r[A0] = 0;


_040010A0:	// 40010a0: <30840100>	ANDI      A0 = A0 & 0100
	state.r[A0] = (state.r[A0] & 0x00000100);


_040010A4:	// 40010a4: <1c80fffe>	BGTZ      (R0>0) --> 10a0
	sp_reg_pc = 0x040010A4;
	if((_s32)state.r[A0] > 0)
	{
		state.r[A0] = 0;
		goto _040010A0;
	}


_040010A8:	// 40010a8: <40045800>	MFC0      T3 = SP status
	state.r[A0] = 0;


_040010AC:	// 40010ac: <20180fa0>	ADDI      T8 = R0 + 0fa0
	state.r[T8] = 0 + 0x0FA0;


_040010B0:	// 40010b0: <0d000449>	JAL	    04001124
	state.r[V0] = (0 + state.r[GP]);
	sp_reg_pc = 0x040010B0;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001124;


_040010B4:	// 40010b4: <001c1020>	ADD       V0 = R0+GP
	state.r[V0] = (0 + state.r[GP]);


_040010B8:	// 40010b8: <40023000>	MFC0      A2 = SP read DMA length
	state.r[V0] = 0;


_040010BC:	// 40010bc: <1440ffff>	BNE       (R0!=V0) --> 10bc
	sp_reg_pc = 0x040010BC;
	if (state.r[V0] != 0)
	{
		state.r[V0] = 0;
		goto _040010BC;
	}


_040010C0:	// 40010c0: <40023000>	MFC0      A2 = SP read DMA length
	state.r[V0] = 0;


_040010C4:	// 40010c4: <40803800>	MTC0      SP semaphore = R0


_040010C8:	// 40010c8: <8fba0000>	LW        K0 = [SP+0000]
	state.r[K0] = (_s32)Load32_DMEM((state.r[SP] + 0x00000000) & 0xfff);


_040010CC:	// 40010cc: <8fb90004>	LW        T9 = [SP+0004]
	state.r[T9] = (_s32)Load32_DMEM((state.r[SP] + 0x00000004) & 0xfff);


_040010D0:	// 40010d0: <239c0008>	ADDI      GP = GP + 0008
	state.r[GP] = state.r[GP] + 0x0008;


_040010D4:	// 40010d4: <001a0dc2>	SRL       AT = K0 >> 23
	state.r[AT] = ((_u32)state.r[K0] >> 23);


_040010D8:	// 40010d8: <302100fe>	ANDI      AT = AT & 00fe
	state.r[AT] = (state.r[AT] & 0x000000FE);


_040010DC:	// 40010dc: <00200820>	ADD       AT = AT+R0
	state.r[AT] = (state.r[AT] + 0);


_040010E0:	// 40010e0: <84210000>	LH        AT = [AT+0000]
	state.r[AT] = (_s32)(_s16)Load16_DMEM((state.r[AT] + 0x00000000) & 0xfff);


_040010E4:	// 40010e4: <00200008>	JR        AT
	{
		_u32	temp = ((state.r[AT] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		state.r[K1] = state.r[K1] + 0xFFFFFFF8;
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_040010E8:	// 40010e8: <237bfff8>	ADDI      K1 = K1 + fff8
	state.r[K1] = state.r[K1] + 0xFFFFFFF8;


_040010EC:	// 40010ec: <0000000d>	BREAK
	state.halt = 1;
	return;


_040010F0:	// 40010f0: <1fc0fff5>	BGTZ      (R0>0) --> 10c8
	sp_reg_pc = 0x040010F0;
	if((_s32)state.r[S8] > 0)
	{
		state.r[SP] = state.r[SP] + 0x0008;
		goto _040010C8;
	}


_040010F4:	// 40010f4: <23bd0008>	ADDI      SP = SP + 0008
	state.r[SP] = state.r[SP] + 0x0008;


_040010F8:	// 40010f8: <1b600005>	BLEZ      (R0<=0) --> 1110
	sp_reg_pc = 0x040010F8;
	if ((_s32)state.r[K1] <= 0)
	{
		state.r[AT] = (0 | 0x00004000);
		goto _04001110;
	}


_040010FC:	// 40010fc: <34014000>	ORI       AT = R0 | 0x4000
	state.r[AT] = (0 | 0x00004000);


_04001100:	// 4001100: <0d000449>	JAL	    04001124
	state.r[V0] = (0 + state.r[GP]);
	sp_reg_pc = 0x04001100;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001124;


_04001104:	// 4001104: <001c1020>	ADD       V0 = R0+GP
	state.r[V0] = (0 + state.r[GP]);


_04001108:	// 4001108: <0900042f>	J         040010bc
	state.r[V0] = 0;
	goto _040010BC;


_0400110C:	// 400110c: <40023000>	MFC0      A2 = SP read DMA length
	state.r[V0] = 0;


_04001110:	// 4001110: <40812000>	MTC0      SP status = AT


_04001114:	// 4001114: <0000000d>	BREAK
	state.halt = 1;
	return;


_04001118:	// 4001118: <00000000>	NOP       


_0400111C:	// 400111c: <1000ffff>	BEQ       (R0==R0) --> 111c
	sp_reg_pc = 0x0400111C;
	if (0 == 0)
	{
		goto _0400111C;
	}


_04001120:	// 4001120: <00000000>	NOP       


_04001124:	// 4001124: <23e50000>	ADDI      A1 = RA + 0000
	state.r[A1] = state.r[RA] + 0x0000;


_04001128:	// 4001128: <23630000>	ADDI      V1 = K1 + 0000
	state.r[V1] = state.r[K1] + 0x0000;


_0400112C:	// 400112c: <2064fec0>	ADDI      A0 = V1 + fec0
	state.r[A0] = state.r[V1] + 0xFFFFFEC0;


_04001130:	// 4001130: <18800002>	BLEZ      (R0<=0) --> 113c
	sp_reg_pc = 0x04001130;
	if ((_s32)state.r[A0] <= 0)
	{
		state.r[AT] = 0 + 0x02B0;
		goto _0400113C;
	}


_04001134:	// 4001134: <200102b0>	ADDI      AT = R0 + 02b0
	state.r[AT] = 0 + 0x02B0;


_04001138:	// 4001138: <20030140>	ADDI      V1 = R0 + 0140
	state.r[V1] = 0 + 0x0140;


_0400113C:	// 400113c: <207e0000>	ADDI      S8 = V1 + 0000
	state.r[S8] = state.r[V1] + 0x0000;


_04001140:	// 4001140: <0d000454>	JAL	    04001150
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;
	sp_reg_pc = 0x04001140;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001150;


_04001144:	// 4001144: <2063ffff>	ADDI      V1 = V1 + ffff
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;


_04001148:	// 4001148: <00a00008>	JR        A1
	{
		_u32	temp = ((state.r[A1] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		state.r[SP] = 0 + 0x02B0;
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_0400114C:	// 400114c: <201d02b0>	ADDI      SP = R0 + 02b0
	state.r[SP] = 0 + 0x02B0;


_04001150:	// 4001150: <40043800>	MFC0      A3 = SP status
	state.r[A0] = 0;


_04001154:	// 4001154: <1480ffff>	BNE       (R0!=A0) --> 1154
	sp_reg_pc = 0x04001154;
	if (state.r[A0] != 0)
	{
		state.r[A0] = 0;
		goto _04001154;
	}


_04001158:	// 4001158: <40043800>	MFC0      A3 = SP status
	state.r[A0] = 0;


_0400115C:	// 400115c: <40042800>	MFC0      A1 = SP status
	state.r[A0] = 0;


_04001160:	// 4001160: <1480ffff>	BNE       (R0!=A0) --> 1160
	sp_reg_pc = 0x04001160;
	if (state.r[A0] != 0)
	{
		state.r[A0] = 0;
		goto _04001160;
	}


_04001164:	// 4001164: <40042800>	MFC0      A1 = SP status
	state.r[A0] = 0;


_04001168:	// 4001168: <40810000>	MTC0      SP memory address = AT
	DMEM_Address = state.r[AT];


_0400116C:	// 400116c: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_04001170:	// 4001170: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		sp_reg_pc = 0x04001174;
		DMARead(state.r[V1]);
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001174:	// 4001174: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x04001174;
	DMARead(state.r[V1]);


_04001178:	// 4001178: <40043800>	MFC0      A3 = SP status
	state.r[A0] = 0;


_0400117C:	// 400117c: <1480ffff>	BNE       (R0!=A0) --> 117c
	sp_reg_pc = 0x0400117C;
	if (state.r[A0] != 0)
	{
		state.r[A0] = 0;
		goto _0400117C;
	}


_04001180:	// 4001180: <40043800>	MFC0      A3 = SP status
	state.r[A0] = 0;


_04001184:	// 4001184: <40042800>	MFC0      A1 = SP status
	state.r[A0] = 0;


_04001188:	// 4001188: <1480ffff>	BNE       (R0!=A0) --> 1188
	sp_reg_pc = 0x04001188;
	if (state.r[A0] != 0)
	{
		state.r[A0] = 0;
		goto _04001188;
	}


_0400118C:	// 400118c: <40042800>	MFC0      A1 = SP status
	state.r[A0] = 0;


_04001190:	// 4001190: <40810000>	MTC0      SP memory address = AT
	DMEM_Address = state.r[AT];


_04001194:	// 4001194: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_04001198:	// 4001198: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		DMAWrite(state.r[V1]);
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_0400119C:	// 400119c: <40831800>	MTC0      SP write DMA length = V1
	DMAWrite(state.r[V1]);


_040011A0:	// 40011a0: <3322ffff>	ANDI      V0 = T9 & ffff
	state.r[V0] = (state.r[T9] & 0x0000FFFF);


_040011A4:	// 40011a4: <4a01086c>	VXOR      vec01 = vec01 xor vec01[<none>]
	rsp_cop2_vxor(&state.v[1], &state.v[1], &state.v[1]);


_040011A8:	// 40011a8: <3341ffff>	ANDI      AT = K0 & ffff
	state.r[AT] = (state.r[K0] & 0x0000FFFF);


_040011AC:	// 40011ac: <202104f0>	ADDI      AT = AT + 04f0
	state.r[AT] = state.r[AT] + 0x04F0;


_040011B0:	// 40011b0: <e8211800>	SDV       [AT + 0x00] = vec01 <00>
	// In function: SmashBros11AC_11B4
	//Call the function: SmashBros11AC_11B4
	SmashBros11AC_11B4();
	goto _040011BC;

_040011B4:	// 40011b4: <e8211801>	SDV       [AT + 0x04] = vec01 <00>
	ErrorToCallFunction(0x040011B4);

_040011B8:	// 40011b8: <2042fff0>	ADDI      V0 = V0 + fff0
	ErrorToCallFunction(0x040011B8);

_040011BC:	// 40011bc: <1c40fffc>	BGTZ      (R0>0) --> 11b0
	sp_reg_pc = 0x040011BC;
	if((_s32)state.r[V0] > 0)
	{
		state.r[AT] = state.r[AT] + 0x0010;
		goto _040011B0;
	}


_040011C0:	// 40011c0: <20210010>	ADDI      AT = AT + 0010
	state.r[AT] = state.r[AT] + 0x0010;


_040011C4:	// 40011c4: <0900043c>	J         040010f0
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;
	goto _040010F0;


_040011C8:	// 40011c8: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_040011CC:	// 40011cc: <001a1a00>	SLL       V1 = K0 << 8
	state.r[V1] = ((_u32)state.r[K0] << 8);


_040011D0:	// 40011d0: <00031d02>	SRL       V1 = V1 >> 20
	state.r[V1] = ((_u32)state.r[V1] >> 20);


_040011D4:	// 40011d4: <1060ffc6>	BEQ       (R0==V1) --> 10f0
	sp_reg_pc = 0x040011D4;
	if (state.r[V1] == 0)
	{
		state.r[S8] = state.r[S8] + 0xFFFFFFF8;
		goto _040010F0;
	}


_040011D8:	// 40011d8: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_040011DC:	// 40011dc: <33410fff>	ANDI      AT = K0 & 0fff
	state.r[AT] = (state.r[K0] & 0x00000FFF);


_040011E0:	// 40011e0: <202104f0>	ADDI      AT = AT + 04f0
	state.r[AT] = state.r[AT] + 0x04F0;


_040011E4:	// 40011e4: <00191200>	SLL       V0 = T9 << 8
	state.r[V0] = ((_u32)state.r[T9] << 8);


_040011E8:	// 40011e8: <00021202>	SRL       V0 = V0 >> 8
	state.r[V0] = ((_u32)state.r[V0] >> 8);


_040011EC:	// 40011ec: <2063ffff>	ADDI      V1 = V1 + ffff
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;


_040011F0:	// 40011f0: <0d000454>	JAL	    04001150
	state.r[V0] = state.r[V0] + 0x0000;
	sp_reg_pc = 0x040011F0;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001150;


_040011F4:	// 40011f4: <20420000>	ADDI      V0 = V0 + 0000
	state.r[V0] = state.r[V0] + 0x0000;


_040011F8:	// 40011f8: <40013000>	MFC0      A2 = SP DRAM DMA address
	state.r[AT] = 0;


_040011FC:	// 40011fc: <1420ffff>	BNE       (R0!=AT) --> 11fc
	sp_reg_pc = 0x040011FC;
	if (state.r[AT] != 0)
	{
		state.r[AT] = 0;
		goto _040011FC;
	}


_04001200:	// 4001200: <40013000>	MFC0      A2 = SP DRAM DMA address
	state.r[AT] = 0;


_04001204:	// 4001204: <0900043c>	J         040010f0
	goto _040010F0;


_04001208:	// 4001208: <40803800>	MTC0      SP semaphore = R0


_0400120C:	// 400120c: <001a1a00>	SLL       V1 = K0 << 8
	state.r[V1] = ((_u32)state.r[K0] << 8);


_04001210:	// 4001210: <00031d02>	SRL       V1 = V1 >> 20
	state.r[V1] = ((_u32)state.r[V1] >> 20);


_04001214:	// 4001214: <1060ffb6>	BEQ       (R0==V1) --> 10f0
	sp_reg_pc = 0x04001214;
	if (state.r[V1] == 0)
	{
		state.r[S8] = state.r[S8] + 0xFFFFFFF8;
		goto _040010F0;
	}


_04001218:	// 4001218: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_0400121C:	// 400121c: <33410fff>	ANDI      AT = K0 & 0fff
	state.r[AT] = (state.r[K0] & 0x00000FFF);


_04001220:	// 4001220: <202104f0>	ADDI      AT = AT + 04f0
	state.r[AT] = state.r[AT] + 0x04F0;


_04001224:	// 4001224: <00191200>	SLL       V0 = T9 << 8
	state.r[V0] = ((_u32)state.r[T9] << 8);


_04001228:	// 4001228: <00021202>	SRL       V0 = V0 >> 8
	state.r[V0] = ((_u32)state.r[V0] >> 8);


_0400122C:	// 400122c: <2063ffff>	ADDI      V1 = V1 + ffff
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;


_04001230:	// 4001230: <0d00045e>	JAL	    04001178
	state.r[V0] = state.r[V0] + 0x0000;
	sp_reg_pc = 0x04001230;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001178;


_04001234:	// 4001234: <20420000>	ADDI      V0 = V0 + 0000
	state.r[V0] = state.r[V0] + 0x0000;


_04001238:	// 4001238: <40013000>	MFC0      A2 = SP DRAM DMA address
	state.r[AT] = 0;


_0400123C:	// 400123c: <1420ffff>	BNE       (R0!=AT) --> 123c
	sp_reg_pc = 0x0400123C;
	if (state.r[AT] != 0)
	{
		state.r[AT] = 0;
		goto _0400123C;
	}


_04001240:	// 4001240: <40013000>	MFC0      A2 = SP DRAM DMA address
	state.r[AT] = 0;


_04001244:	// 4001244: <0900043c>	J         040010f0
	goto _040010F0;


_04001248:	// 4001248: <40803800>	MTC0      SP semaphore = R0


_0400124C:	// 400124c: <00191200>	SLL       V0 = T9 << 8
	state.r[V0] = ((_u32)state.r[T9] << 8);


_04001250:	// 4001250: <00021202>	SRL       V0 = V0 >> 8
	state.r[V0] = ((_u32)state.r[V0] >> 8);


_04001254:	// 4001254: <20420000>	ADDI      V0 = V0 + 0000
	state.r[V0] = state.r[V0] + 0x0000;


_04001258:	// 4001258: <200103f0>	ADDI      AT = R0 + 03f0
	state.r[AT] = 0 + 0x03F0;


_0400125C:	// 400125c: <3343ffff>	ANDI      V1 = K0 & ffff
	state.r[V1] = (state.r[K0] & 0x0000FFFF);


_04001260:	// 4001260: <0d000454>	JAL	    04001150
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;
	sp_reg_pc = 0x04001260;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001150;


_04001264:	// 4001264: <2063ffff>	ADDI      V1 = V1 + ffff
	state.r[V1] = state.r[V1] + 0xFFFFFFFF;


_04001268:	// 4001268: <40013000>	MFC0      A2 = SP DRAM DMA address
	state.r[AT] = 0;


_0400126C:	// 400126c: <1420ffff>	BNE       (R0!=AT) --> 126c
	sp_reg_pc = 0x0400126C;
	if (state.r[AT] != 0)
	{
		state.r[AT] = 0;
		goto _0400126C;
	}


_04001270:	// 4001270: <40013000>	MFC0      A2 = SP DRAM DMA address
	state.r[AT] = 0;


_04001274:	// 4001274: <40803800>	MTC0      SP semaphore = R0


_04001278:	// 4001278: <0900043c>	J         040010f0
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;
	goto _040010F0;


_0400127C:	// 400127c: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_04001280:	// 4001280: <001a1c02>	SRL       V1 = K0 >> 16
	state.r[V1] = ((_u32)state.r[K0] >> 16);


_04001284:	// 4001284: <30610004>	ANDI      AT = V1 & 0004
	state.r[AT] = (state.r[V1] & 0x00000004);


_04001288:	// 4001288: <1020000d>	BEQ       (R0==AT) --> 12c0
	sp_reg_pc = 0x04001288;
	if (state.r[AT] == 0)
	{
		state.r[AT] = (state.r[V1] & 0x00000002);
		goto _040012C0;
	}


_0400128C:	// 400128c: <30610002>	ANDI      AT = V1 & 0002
	state.r[AT] = (state.r[V1] & 0x00000002);


_04001290:	// 4001290: <10200006>	BEQ       (R0==AT) --> 12ac
	sp_reg_pc = 0x04001290;
	if (state.r[AT] == 0)
	{
		state.r[V0] = ((_u32)state.r[T9] >> 16);
		goto _040012AC;
	}


_04001294:	// 4001294: <00191402>	SRL       V0 = T9 >> 16
	state.r[V0] = ((_u32)state.r[T9] >> 16);


_04001298:	// 4001298: <a71a0050>	SH        [T8+0050] = K0
	Save16_DMEM((_u16)state.r[K0], (state.r[T8] + 0x00000050) & 0xfff);


_0400129C:	// 400129c: <a702004c>	SH        [T8+004c] = V0
	Save16_DMEM((_u16)state.r[V0], (state.r[T8] + 0x0000004C) & 0xfff);


_040012A0:	// 40012a0: <a719004e>	SH        [T8+004e] = T9
	Save16_DMEM((_u16)state.r[T9], (state.r[T8] + 0x0000004E) & 0xfff);


_040012A4:	// 40012a4: <0900043c>	J         040010f0
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;
	goto _040010F0;


_040012A8:	// 40012a8: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_040012AC:	// 40012ac: <a71a0046>	SH        [T8+0046] = K0
	Save16_DMEM((_u16)state.r[K0], (state.r[T8] + 0x00000046) & 0xfff);


_040012B0:	// 40012b0: <a7020048>	SH        [T8+0048] = V0
	Save16_DMEM((_u16)state.r[V0], (state.r[T8] + 0x00000048) & 0xfff);


_040012B4:	// 40012b4: <a719004a>	SH        [T8+004a] = T9
	Save16_DMEM((_u16)state.r[T9], (state.r[T8] + 0x0000004A) & 0xfff);


_040012B8:	// 40012b8: <0900043c>	J         040010f0
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;
	goto _040010F0;


_040012BC:	// 40012bc: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_040012C0:	// 40012c0: <00191402>	SRL       V0 = T9 >> 16
	state.r[V0] = ((_u32)state.r[T9] >> 16);


_040012C4:	// 40012c4: <a71a0040>	SH        [T8+0040] = K0
	Save16_DMEM((_u16)state.r[K0], (state.r[T8] + 0x00000040) & 0xfff);


_040012C8:	// 40012c8: <a7020042>	SH        [T8+0042] = V0
	Save16_DMEM((_u16)state.r[V0], (state.r[T8] + 0x00000042) & 0xfff);


_040012CC:	// 40012cc: <a7190044>	SH        [T8+0044] = T9
	Save16_DMEM((_u16)state.r[T9], (state.r[T8] + 0x00000044) & 0xfff);


_040012D0:	// 40012d0: <0900043c>	J         040010f0
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;
	goto _040010F0;


_040012D4:	// 40012d4: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_040012D8:	// 40012d8: <20010170>	ADDI      AT = R0 + 0170
	state.r[AT] = 0 + 0x0170;


_040012DC:	// 40012dc: <200404f0>	ADDI      A0 = R0 + 04f0
	state.r[A0] = 0 + 0x04F0;


_040012E0:	// 40012e0: <200209d0>	ADDI      V0 = R0 + 09d0
	state.r[V0] = 0 + 0x09D0;


_040012E4:	// 40012e4: <20030b40>	ADDI      V1 = R0 + 0b40
	state.r[V1] = 0 + 0x0B40;


_040012E8:	// 40012e8: <c8412000>	LQV       vec01 <00> = [V0 + 0x00]
	// In function: SmashBros12E4_1334
	//Call the function: SmashBros12E4_1334
	SmashBros12E4_1334();
	goto _0400133C;

_040012EC:	// 40012ec: <c8622000>	LQV       vec02 <00> = [V1 + 0x00]
	ErrorToCallFunction(0x040012EC);

_040012F0:	// 40012f0: <2021fff0>	ADDI      AT = AT + fff0
	ErrorToCallFunction(0x040012F0);

_040012F4:	// 40012f4: <20420010>	ADDI      V0 = V0 + 0010
	ErrorToCallFunction(0x040012F4);

_040012F8:	// 40012f8: <20630010>	ADDI      V1 = V1 + 0010
	ErrorToCallFunction(0x040012F8);

_040012FC:	// 40012fc: <e8810800>	SSV       [A0 + 0x00] = vec01 <00>
	ErrorToCallFunction(0x040012FC);

_04001300:	// 4001300: <e8820801>	SSV       [A0 + 0x02] = vec02 <00>
	ErrorToCallFunction(0x04001300);

_04001304:	// 4001304: <e8810902>	SSV       [A0 + 0x04] = vec01 <02>
	ErrorToCallFunction(0x04001304);

_04001308:	// 4001308: <e8820903>	SSV       [A0 + 0x06] = vec02 <02>
	ErrorToCallFunction(0x04001308);

_0400130C:	// 400130c: <e8810a04>	SSV       [A0 + 0x08] = vec01 <04>
	ErrorToCallFunction(0x0400130C);

_04001310:	// 4001310: <e8820a05>	SSV       [A0 + 0x0a] = vec02 <04>
	ErrorToCallFunction(0x04001310);

_04001314:	// 4001314: <e8810b06>	SSV       [A0 + 0x0c] = vec01 <06>
	ErrorToCallFunction(0x04001314);

_04001318:	// 4001318: <e8820b07>	SSV       [A0 + 0x0e] = vec02 <06>
	ErrorToCallFunction(0x04001318);

_0400131C:	// 400131c: <e8810c08>	SSV       [A0 + 0x10] = vec01 <08>
	ErrorToCallFunction(0x0400131C);

_04001320:	// 4001320: <e8820c09>	SSV       [A0 + 0x12] = vec02 <08>
	ErrorToCallFunction(0x04001320);

_04001324:	// 4001324: <e8810d0a>	SSV       [A0 + 0x14] = vec01 <10>
	ErrorToCallFunction(0x04001324);

_04001328:	// 4001328: <e8820d0b>	SSV       [A0 + 0x16] = vec02 <10>
	ErrorToCallFunction(0x04001328);

_0400132C:	// 400132c: <e8810e0c>	SSV       [A0 + 0x18] = vec01 <12>
	ErrorToCallFunction(0x0400132C);

_04001330:	// 4001330: <e8820e0d>	SSV       [A0 + 0x1a] = vec02 <12>
	ErrorToCallFunction(0x04001330);

_04001334:	// 4001334: <e8810f0e>	SSV       [A0 + 0x1c] = vec01 <14>
	ErrorToCallFunction(0x04001334);

_04001338:	// 4001338: <e8820f0f>	SSV       [A0 + 0x1e] = vec02 <14>
	ErrorToCallFunction(0x04001338);

_0400133C:	// 400133c: <1c20ffea>	BGTZ      (R0>0) --> 12e8
	sp_reg_pc = 0x0400133C;
	if((_s32)state.r[AT] > 0)
	{
		state.r[A0] = state.r[A0] + 0x0020;
		goto _040012E8;
	}


_04001340:	// 4001340: <20840020>	ADDI      A0 = A0 + 0020
	state.r[A0] = state.r[A0] + 0x0020;


_04001344:	// 4001344: <0900043c>	J         040010f0
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;
	goto _040010F0;


_04001348:	// 4001348: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_0400134C:	// 400134c: <3321ffff>	ANDI      AT = T9 & ffff
	state.r[AT] = (state.r[T9] & 0x0000FFFF);


_04001350:	// 4001350: <3342ffff>	ANDI      V0 = K0 & ffff
	state.r[V0] = (state.r[K0] & 0x0000FFFF);


_04001354:	// 4001354: <204204f0>	ADDI      V0 = V0 + 04f0
	state.r[V0] = state.r[V0] + 0x04F0;


_04001358:	// 4001358: <00191c02>	SRL       V1 = T9 >> 16
	state.r[V1] = ((_u32)state.r[T9] >> 16);


_0400135C:	// 400135c: <206304f0>	ADDI      V1 = V1 + 04f0
	state.r[V1] = state.r[V1] + 0x04F0;


_04001360:	// 4001360: <c8411800>	LDV       vec01 <00> = [V0 + 0x00]
	// In function: Mario1424_1438
	//Call the function: Mario1424_1438
	Mario1424_1438();
	goto _04001378;

_04001364:	// 4001364: <c8421801>	LDV       vec02 <00> = [V0 + 0x08]
	ErrorToCallFunction(0x04001364);

_04001368:	// 4001368: <2021fff0>	ADDI      AT = AT + fff0
	ErrorToCallFunction(0x04001368);

_0400136C:	// 400136c: <20420010>	ADDI      V0 = V0 + 0010
	ErrorToCallFunction(0x0400136C);

_04001370:	// 4001370: <e8611800>	SDV       [V1 + 0x00] = vec01 <00>
	ErrorToCallFunction(0x04001370);

_04001374:	// 4001374: <e8621801>	SDV       [V1 + 0x04] = vec02 <00>
	ErrorToCallFunction(0x04001374);

_04001378:	// 4001378: <1c20fff9>	BGTZ      (R0>0) --> 1360
	sp_reg_pc = 0x04001378;
	if((_s32)state.r[AT] > 0)
	{
		state.r[V1] = state.r[V1] + 0x0010;
		goto _04001360;
	}


_0400137C:	// 400137c: <20630010>	ADDI      V1 = V1 + 0010
	state.r[V1] = state.r[V1] + 0x0010;


_04001380:	// 4001380: <0900043c>	J         040010f0
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;
	goto _040010F0;


_04001384:	// 4001384: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_04001388:	// 4001388: <00190a00>	SLL       AT = T9 << 8
	state.r[AT] = ((_u32)state.r[T9] << 8);


_0400138C:	// 400138c: <00010a02>	SRL       AT = AT >> 8
	state.r[AT] = ((_u32)state.r[AT] >> 8);


_04001390:	// 4001390: <20210000>	ADDI      AT = AT + 0000
	state.r[AT] = state.r[AT] + 0x0000;


_04001394:	// 4001394: <ac01000e>	SW        [R0+000e] = AT
	Save32_DMEM((_u32)state.r[AT], (0 + 0x0000000E) & 0xfff);


_04001398:	// 4001398: <0900043c>	J         040010f0
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;
	goto _040010F0;


_0400139C:	// 400139c: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_040013A0:	// 40013a0: <c81f2005>	LQV       vec31 <00> = [R0 + 0x50]
	{
		_u32 addr = (0x00000050 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[31].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[31].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[31].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[31].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[31].U64[0] = state.v[31].U64[0] & ~temp1;
			state.v[31].U64[1] = state.v[31].U64[1] & ~temp2;
			state.v[31].U64[0] = state.v[31].U64[0] | value1;
			state.v[31].U64[1] = state.v[31].U64[1] | value2;
		}
	}


_040013A4:	// 40013a4: <0019bb02>	SRL       S7 = T9 >> 12
	state.r[S7] = ((_u32)state.r[T9] >> 12);


_040013A8:	// 40013a8: <4a19ce6c>	VXOR      vec25 = vec25 xor vec25[<none>]
	rsp_cop2_vxor(&state.v[25], &state.v[25], &state.v[25]);


_040013AC:	// 40013ac: <32f7000f>	ANDI      S7 = S7 & 000f
	state.r[S7] = (state.r[S7] & 0x0000000F);


_040013B0:	// 40013b0: <4a18c62c>	VXOR      vec24 = vec24 xor vec24[<none>]
	rsp_cop2_vxor(&state.v[24], &state.v[24], &state.v[24]);


_040013B4:	// 40013b4: <22f704f0>	ADDI      S7 = S7 + 04f0
	state.r[S7] = state.r[S7] + 0x04F0;


_040013B8:	// 40013b8: <4a0d6b6c>	VXOR      vec13 = vec13 xor vec13[<none>]
	rsp_cop2_vxor(&state.v[13], &state.v[13], &state.v[13]);


_040013BC:	// 40013bc: <33210fff>	ANDI      AT = T9 & 0fff
	state.r[AT] = (state.r[T9] & 0x00000FFF);


_040013C0:	// 40013c0: <4a0e73ac>	VXOR      vec14 = vec14 xor vec14[<none>]
	rsp_cop2_vxor(&state.v[14], &state.v[14], &state.v[14]);


_040013C4:	// 40013c4: <202104f0>	ADDI      AT = AT + 04f0
	state.r[AT] = state.r[AT] + 0x04F0;


_040013C8:	// 40013c8: <4a0f7bec>	VXOR      vec15 = vec15 xor vec15[<none>]
	rsp_cop2_vxor(&state.v[15], &state.v[15], &state.v[15]);


_040013CC:	// 40013cc: <0019ac02>	SRL       S5 = T9 >> 16
	state.r[S5] = ((_u32)state.r[T9] >> 16);


_040013D0:	// 40013d0: <4a10842c>	VXOR      vec16 = vec16 xor vec16[<none>]
	rsp_cop2_vxor(&state.v[16], &state.v[16], &state.v[16]);


_040013D4:	// 40013d4: <32b50fff>	ANDI      S5 = S5 & 0fff
	state.r[S5] = (state.r[S5] & 0x00000FFF);


_040013D8:	// 40013d8: <4a118c6c>	VXOR      vec17 = vec17 xor vec17[<none>]
	rsp_cop2_vxor(&state.v[17], &state.v[17], &state.v[17]);


_040013DC:	// 40013dc: <001aa200>	SLL       S4 = K0 << 8
	state.r[S4] = ((_u32)state.r[K0] << 8);


_040013E0:	// 40013e0: <4a1294ac>	VXOR      vec18 = vec18 xor vec18[<none>]
	rsp_cop2_vxor(&state.v[18], &state.v[18], &state.v[18]);


_040013E4:	// 40013e4: <0014a202>	SRL       S4 = S4 >> 8
	state.r[S4] = ((_u32)state.r[S4] >> 8);


_040013E8:	// 40013e8: <4a139cec>	VXOR      vec19 = vec19 xor vec19[<none>]
	rsp_cop2_vxor(&state.v[19], &state.v[19], &state.v[19]);


_040013EC:	// 40013ec: <2003001f>	ADDI      V1 = R0 + 001f
	state.r[V1] = 0 + 0x001F;


_040013F0:	// 40013f0: <00196f02>	SRL       T5 = T9 >> 28
	state.r[T5] = ((_u32)state.r[T9] >> 28);


_040013F4:	// 40013f4: <31a20001>	ANDI      V0 = T5 & 0001
	state.r[V0] = (state.r[T5] & 0x00000001);


_040013F8:	// 40013f8: <1c40001a>	BGTZ      (R0>0) --> 1464
	sp_reg_pc = 0x040013F8;
	if((_s32)state.r[V0] > 0)
	{
		state.r[S6] = state.r[S7] + 0x0001;
		goto _04001464;
	}


_040013FC:	// 40013fc: <22f60001>	ADDI      S6 = S7 + 0001
	state.r[S6] = state.r[S7] + 0x0001;


_04001400:	// 4001400: <31a20002>	ANDI      V0 = T5 & 0002
	state.r[V0] = (state.r[T5] & 0x00000002);


_04001404:	// 4001404: <10400002>	BEQ       (R0==V0) --> 1410
	sp_reg_pc = 0x04001404;
	if (state.r[V0] == 0)
	{
		state.r[V0] = state.r[S4] + 0x0000;
		goto _04001410;
	}


_04001408:	// 4001408: <22820000>	ADDI      V0 = S4 + 0000
	state.r[V0] = state.r[S4] + 0x0000;


_0400140C:	// 400140c: <8c02000e>	LW        V0 = [R0+000e]
	state.r[V0] = (_s32)Load32_DMEM((0 + 0x0000000E) & 0xfff);


_04001410:	// 4001410: <400d3800>	MFC0      A3 = DP buffer busy counter
	state.r[T5] = 0;


_04001414:	// 4001414: <15a0ffff>	BNE       (R0!=T5) --> 1414
	sp_reg_pc = 0x04001414;
	if (state.r[T5] != 0)
	{
		state.r[T5] = 0;
		goto _04001414;
	}


_04001418:	// 4001418: <400d3800>	MFC0      A3 = DP buffer busy counter
	state.r[T5] = 0;


_0400141C:	// 400141c: <400d2800>	MFC0      A1 = DP buffer busy counter
	state.r[T5] = 0;


_04001420:	// 4001420: <15a0ffff>	BNE       (R0!=T5) --> 1420
	sp_reg_pc = 0x04001420;
	if (state.r[T5] != 0)
	{
		state.r[T5] = 0;
		goto _04001420;
	}


_04001424:	// 4001424: <400d2800>	MFC0      A1 = DP buffer busy counter
	state.r[T5] = 0;


_04001428:	// 4001428: <40810000>	MTC0      SP memory address = AT
	DMEM_Address = state.r[AT];


_0400142C:	// 400142c: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_04001430:	// 4001430: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x04001430;
	DMARead(state.r[V1]);


_04001434:	// 4001434: <20130020>	ADDI      S3 = R0 + 0020
	state.r[S3] = 0 + 0x0020;


_04001438:	// 4001438: <201203f0>	ADDI      S2 = R0 + 03f0
	state.r[S2] = 0 + 0x03F0;


_0400143C:	// 400143c: <ca791800>	LDV       vec25 <00> = [S3 + 0x00]
	rsp_ldv_compiler((state.r[S3] & 0xFFF), 25, 8);


_04001440:	// 4001440: <ca781c00>	LDV       vec24 <08> = [S3 + 0x00]
	rsp_ldv_compiler((state.r[S3] & 0xFFF), 24, 0);


_04001444:	// 4001444: <ca771801>	LDV       vec23 <00> = [S3 + 0x08]
	rsp_ldv_compiler((state.r[S3] + 0x00000008) & 0xFFF, 23, 8);


_04001448:	// 4001448: <ca771c01>	LDV       vec23 <08> = [S3 + 0x08]
	rsp_ldv_compiler((state.r[S3] + 0x00000008) & 0xFFF, 23, 0);


_0400144C:	// 400144c: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001450:	// 4001450: <14a0ffff>	BNE       (R0!=A1) --> 1450
	sp_reg_pc = 0x04001450;
	if (state.r[A1] != 0)
	{
		state.r[A1] = 0;
		goto _04001450;
	}


_04001454:	// 4001454: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001458:	// 4001458: <40803800>	MTC0      SP semaphore = R0


_0400145C:	// 400145c: <09000522>	J         04001488
	{
		_u32 addr = (0x00000010 + state.r[AT]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
			state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
			state.v[27].U64[0] = state.v[27].U64[0] | value1;
			state.v[27].U64[1] = state.v[27].U64[1] | value2;
		}
	}
	goto _04001488;


_04001460:	// 4001460: <c83b2001>	LQV       vec27 <00> = [AT + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[AT]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
			state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
			state.v[27].U64[0] = state.v[27].U64[0] | value1;
			state.v[27].U64[1] = state.v[27].U64[1] | value2;
		}
	}


_04001464:	// 4001464: <20130020>	ADDI      S3 = R0 + 0020
	state.r[S3] = 0 + 0x0020;


_04001468:	// 4001468: <4a1bdeec>	VXOR      vec27 = vec27 xor vec27[<none>]
	rsp_cop2_vxor(&state.v[27], &state.v[27], &state.v[27]);


_0400146C:	// 400146c: <201203f0>	ADDI      S2 = R0 + 03f0
	state.r[S2] = 0 + 0x03F0;


_04001470:	// 4001470: <ca791800>	LDV       vec25 <00> = [S3 + 0x00]
	rsp_ldv_compiler((state.r[S3] & 0xFFF), 25, 8);


_04001474:	// 4001474: <ca781c00>	LDV       vec24 <08> = [S3 + 0x00]
	rsp_ldv_compiler((state.r[S3] & 0xFFF), 24, 0);


_04001478:	// 4001478: <ca771801>	LDV       vec23 <00> = [S3 + 0x08]
	rsp_ldv_compiler((state.r[S3] + 0x00000008) & 0xFFF, 23, 8);


_0400147C:	// 400147c: <ca771c01>	LDV       vec23 <08> = [S3 + 0x08]
	rsp_ldv_compiler((state.r[S3] + 0x00000008) & 0xFFF, 23, 0);


_04001480:	// 4001480: <e83b2000>	SQV       [AT + 0x00] = vec27 <00>
	{
		_u32    addr = (0x00000000 + state.r[AT]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[27].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[27].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[27].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[27].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[27].U64[0] & temp1);
			value2 |= (state.v[27].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001484:	// 4001484: <e83b2001>	SQV       [AT + 0x10] = vec27 <00>
	{
		_u32    addr = (0x00000010 + state.r[AT]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[27].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[27].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[27].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[27].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[27].U64[0] & temp1);
			value2 |= (state.v[27].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001488:	// 4001488: <12a0006b>	BEQ       (R0==S5) --> 1638
	sp_reg_pc = 0x04001488;
	if (state.r[S5] == 0)
	{
		state.r[AT] = state.r[AT] + 0x0020;
		goto _04001638;
	}


_0400148C:	// 400148c: <20210020>	ADDI      AT = AT + 0020
	state.r[AT] = state.r[AT] + 0x0020;


_04001490:	// 4001490: <cacc1800>	LDV       vec12 <00> = [S6 + 0x00]
	rsp_ldv_compiler((state.r[S6] & 0xFFF), 12, 8);


_04001494:	// 4001494: <92ea0000>	LBU       T2 = [S7+0000]
	state.r[T2] = (_s32)(_u8)pDMEM[((state.r[S7] + 0x00000000) & 0xfff) ^ 3];


_04001498:	// 4001498: <200d000c>	ADDI      T5 = R0 + 000c
	state.r[T5] = 0 + 0x000C;


_0400149C:	// 400149c: <200c0001>	ADDI      T4 = R0 + 0001
	state.r[T4] = 0 + 0x0001;


_040014A0:	// 40014a0: <314e000f>	ANDI      T6 = T2 & 000f
	state.r[T6] = (state.r[T2] & 0x0000000F);


_040014A4:	// 40014a4: <000e7140>	SLL       T6 = T6 << 5
	state.r[T6] = ((_u32)state.r[T6] << 5);


_040014A8:	// 40014a8: <4b0ccaa8>	VAND      vec10 = vec25 and vec12[0]
	rsp_cop2_vand_element(&state.v[10], &state.v[25], &state.v[12].U16[7]);


_040014AC:	// 40014ac: <01d28020>	ADD       S0 = T6+S2
	state.r[S0] = (state.r[T6] + state.r[S2]);


_040014B0:	// 40014b0: <4b2cc268>	VAND      vec09 = vec24 and vec12[1]
	rsp_cop2_vand_element(&state.v[9], &state.v[24], &state.v[12].U16[6]);


_040014B4:	// 40014b4: <000a8902>	SRL       S1 = T2 >> 4
	state.r[S1] = ((_u32)state.r[T2] >> 4);


_040014B8:	// 40014b8: <4b4cca28>	VAND      vec08 = vec25 and vec12[2]
	rsp_cop2_vand_element(&state.v[8], &state.v[25], &state.v[12].U16[5]);


_040014BC:	// 40014bc: <01b18822>	SUB       S1 = T5-S1
	state.r[S1] = (state.r[T5] - state.r[S1]);


_040014C0:	// 40014c0: <4b6cc1e8>	VAND      vec07 = vec24 and vec12[3]
	rsp_cop2_vand_element(&state.v[7], &state.v[24], &state.v[12].U16[4]);


_040014C4:	// 40014c4: <222dffff>	ADDI      T5 = S1 + ffff
	state.r[T5] = state.r[S1] + 0xFFFFFFFF;


_040014C8:	// 40014c8: <000c63c0>	SLL       T4 = T4 << 15
	state.r[T4] = ((_u32)state.r[T4] << 15);


_040014CC:	// 40014cc: <01ac5806>	SRLV      T4 = T3 >> T5
	state.r[T3] = ((_u32)state.r[T4] >> (state.r[T5] & 0x1F));


_040014D0:	// 40014d0: <488bb000>	MTC2      vec22 <00> = T3
	state.v[22].U16[7] = (_u16)state.r[T3];


_040014D4:	// 40014d4: <ca152000>	LQV       vec21 <00> = [S0 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S0]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[21].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[21].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[21].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[21].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[21].U64[0] = state.v[21].U64[0] & ~temp1;
			state.v[21].U64[1] = state.v[21].U64[1] & ~temp2;
			state.v[21].U64[0] = state.v[21].U64[0] | value1;
			state.v[21].U64[1] = state.v[21].U64[1] | value2;
		}
	}


_040014D8:	// 40014d8: <ca142001>	LQV       vec20 <00> = [S0 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[S0]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[20].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[20].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[20].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[20].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[20].U64[0] = state.v[20].U64[0] & ~temp1;
			state.v[20].U64[1] = state.v[20].U64[1] & ~temp2;
			state.v[20].U64[0] = state.v[20].U64[0] | value1;
			state.v[20].U64[1] = state.v[20].U64[1] | value2;
		}
	}


_040014DC:	// 40014dc: <2210fffe>	ADDI      S0 = S0 + fffe
	state.r[S0] = state.r[S0] + 0xFFFFFFFE;


_040014E0:	// 40014e0: <ca132802>	LRV       vec19 <00> = [S0 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S0]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[19].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040014E4:	// 40014e4: <2210fffe>	ADDI      S0 = S0 + fffe
	state.r[S0] = state.r[S0] + 0xFFFFFFFE;


_040014E8:	// 40014e8: <ca122802>	LRV       vec18 <00> = [S0 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S0]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[18].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040014EC:	// 40014ec: <2210fffe>	ADDI      S0 = S0 + fffe
	state.r[S0] = state.r[S0] + 0xFFFFFFFE;


_040014F0:	// 40014f0: <ca112802>	LRV       vec17 <00> = [S0 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S0]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[17].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040014F4:	// 40014f4: <2210fffe>	ADDI      S0 = S0 + fffe
	state.r[S0] = state.r[S0] + 0xFFFFFFFE;


_040014F8:	// 40014f8: <ca102802>	LRV       vec16 <00> = [S0 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S0]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[16].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040014FC:	// 40014fc: <2210fffe>	ADDI      S0 = S0 + fffe
	state.r[S0] = state.r[S0] + 0xFFFFFFFE;


_04001500:	// 4001500: <ca0f2802>	LRV       vec15 <00> = [S0 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S0]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[15].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001504:	// 4001504: <2210fffe>	ADDI      S0 = S0 + fffe
	state.r[S0] = state.r[S0] + 0xFFFFFFFE;


_04001508:	// 4001508: <ca0e2802>	LRV       vec14 <00> = [S0 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S0]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[14].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_0400150C:	// 400150c: <2210fffe>	ADDI      S0 = S0 + fffe
	state.r[S0] = state.r[S0] + 0xFFFFFFFE;


_04001510:	// 4001510: <ca0d2802>	LRV       vec13 <00> = [S0 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S0]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[13].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001514:	// 4001514: <22d60009>	ADDI      S6 = S6 + 0009
	// In function: SmashBros1514_1630
	//Call the function: SmashBros1514_1630
	SmashBros1514_1630();
	goto _04001638;

_04001518:	// 4001518: <4a175786>	VMUDN     vec30 = ( acc = vec10 * vec23[<none>]      ) >> 16
	ErrorToCallFunction(0x04001518);

_0400151C:	// 400151c: <22f70009>	ADDI      S7 = S7 + 0009
	ErrorToCallFunction(0x0400151C);

_04001520:	// 4001520: <4a174f8e>	VMADN     vec30 = ( acc+= vec09 * vec23[<none>] )
	ErrorToCallFunction(0x04001520);

_04001524:	// 4001524: <92ea0000>	LBU       T2 = [S7+0000]
	ErrorToCallFunction(0x04001524);

_04001528:	// 4001528: <4a174746>	VMUDN     vec29 = ( acc = vec08 * vec23[<none>]      ) >> 16
	ErrorToCallFunction(0x04001528);

_0400152C:	// 400152c: <cacc1800>	LDV       vec12 <00> = [S6 + 0x00]
	ErrorToCallFunction(0x0400152C);

_04001530:	// 4001530: <4a173f4e>	VMADN     vec29 = ( acc+= vec07 * vec23[<none>] )
	ErrorToCallFunction(0x04001530);

_04001534:	// 4001534: <200d000c>	ADDI      T5 = R0 + 000c
	ErrorToCallFunction(0x04001534);

_04001538:	// 4001538: <1a200003>	BLEZ      (R0<=0) --> 1548
	ErrorToCallFunction(0x04001538);

_0400153C:	// 400153c: <314e000f>	ANDI      T6 = T2 & 000f
	ErrorToCallFunction(0x0400153C);

_04001540:	// 4001540: <4b16f785>	VMUDM     vec30 = ( acc = vec30 * vec22[0] ) >> 16
	ErrorToCallFunction(0x04001540);

_04001544:	// 4001544: <4b16ef45>	VMUDM     vec29 = ( acc = vec29 * vec22[0] ) >> 16
	ErrorToCallFunction(0x04001544);

_04001548:	// 4001548: <000e7140>	SLL       T6 = T6 << 5
	ErrorToCallFunction(0x04001548);

_0400154C:	// 400154c: <4bdbaac7>	VMUDH     vec11 = ( acc = (vec21 * vec27[6]) << 16) >> 16
	ErrorToCallFunction(0x0400154C);

_04001550:	// 4001550: <01d28020>	ADD       S0 = T6+S2
	ErrorToCallFunction(0x04001550);

_04001554:	// 4001554: <4bfba2cf>	VMADH     vec11 = ( acc+= (vec20 * vec27[7]) << 16) >> 16
	ErrorToCallFunction(0x04001554);

_04001558:	// 4001558: <4b1e9acf>	VMADH     vec11 = ( acc+= (vec19 * vec30[0]) << 16) >> 16
	ErrorToCallFunction(0x04001558);

_0400155C:	// 400155c: <4b3e92cf>	VMADH     vec11 = ( acc+= (vec18 * vec30[1]) << 16) >> 16
	ErrorToCallFunction(0x0400155C);

_04001560:	// 4001560: <000a8902>	SRL       S1 = T2 >> 4
	ErrorToCallFunction(0x04001560);

_04001564:	// 4001564: <4b5e8acf>	VMADH     vec11 = ( acc+= (vec17 * vec30[2]) << 16) >> 16
	ErrorToCallFunction(0x04001564);

_04001568:	// 4001568: <4b7e82cf>	VMADH     vec11 = ( acc+= (vec16 * vec30[3]) << 16) >> 16
	ErrorToCallFunction(0x04001568);

_0400156C:	// 400156c: <01b18822>	SUB       S1 = T5-S1
	ErrorToCallFunction(0x0400156C);

_04001570:	// 4001570: <4b9e7f0f>	VMADH     vec28 = ( acc+= (vec15 * vec30[4]) << 16) >> 16
	ErrorToCallFunction(0x04001570);

_04001574:	// 4001574: <222dffff>	ADDI      T5 = S1 + ffff
	ErrorToCallFunction(0x04001574);

_04001578:	// 4001578: <4bbe72cf>	VMADH     vec11 = ( acc+= (vec14 * vec30[5]) << 16) >> 16
	ErrorToCallFunction(0x04001578);

_0400157C:	// 400157c: <4bde6acf>	VMADH     vec11 = ( acc+= (vec13 * vec30[6]) << 16) >> 16
	ErrorToCallFunction(0x0400157C);

_04001580:	// 4001580: <4b7ff2cf>	VMADH     vec11 = ( acc+= (vec30 * vec31[3]) << 16) >> 16
	ErrorToCallFunction(0x04001580);

_04001584:	// 4001584: <01ac5806>	SRLV      T4 = T3 >> T5
	ErrorToCallFunction(0x04001584);

_04001588:	// 4001588: <4b3c369d>	VSAW $v26, $v6, $v28[[1]]
	ErrorToCallFunction(0x04001588);

_0400158C:	// 400158c: <488bb000>	MTC2      vec22 <00> = T3
	ErrorToCallFunction(0x0400158C);

_04001590:	// 4001590: <4b1c371d>	VSAW $v28, $v6, $v28[[0]]
	ErrorToCallFunction(0x04001590);

_04001594:	// 4001594: <4b0ccaa8>	VAND      vec10 = vec25 and vec12[0]
	ErrorToCallFunction(0x04001594);

_04001598:	// 4001598: <4b2cc268>	VAND      vec09 = vec24 and vec12[1]
	ErrorToCallFunction(0x04001598);

_0400159C:	// 400159c: <4b4cca28>	VAND      vec08 = vec25 and vec12[2]
	ErrorToCallFunction(0x0400159C);

_040015A0:	// 40015a0: <4b6cc1e8>	VAND      vec07 = vec24 and vec12[3]
	ErrorToCallFunction(0x040015A0);

_040015A4:	// 40015a4: <4b3fd2c6>	VMUDN     vec11 = ( acc = vec26 * vec31[1]      ) >> 16
	ErrorToCallFunction(0x040015A4);

_040015A8:	// 40015a8: <4b3fe70f>	VMADH     vec28 = ( acc+= (vec28 * vec31[1]) << 16) >> 16
	ErrorToCallFunction(0x040015A8);

_040015AC:	// 40015ac: <4b1d9ac7>	VMUDH     vec11 = ( acc = (vec19 * vec29[0]) << 16) >> 16
	ErrorToCallFunction(0x040015AC);

_040015B0:	// 40015b0: <220ffffe>	ADDI      T7 = S0 + fffe
	ErrorToCallFunction(0x040015B0);

_040015B4:	// 40015b4: <4b3d92cf>	VMADH     vec11 = ( acc+= (vec18 * vec29[1]) << 16) >> 16
	ErrorToCallFunction(0x040015B4);

_040015B8:	// 40015b8: <c9f32802>	LRV       vec19 <00> = [T7 + 0x20]
	ErrorToCallFunction(0x040015B8);

_040015BC:	// 40015bc: <4b5d8acf>	VMADH     vec11 = ( acc+= (vec17 * vec29[2]) << 16) >> 16
	ErrorToCallFunction(0x040015BC);

_040015C0:	// 40015c0: <21effffe>	ADDI      T7 = T7 + fffe
	ErrorToCallFunction(0x040015C0);

_040015C4:	// 40015c4: <4b7d82cf>	VMADH     vec11 = ( acc+= (vec16 * vec29[3]) << 16) >> 16
	ErrorToCallFunction(0x040015C4);

_040015C8:	// 40015c8: <c9f22802>	LRV       vec18 <00> = [T7 + 0x20]
	ErrorToCallFunction(0x040015C8);

_040015CC:	// 40015cc: <4b9d7acf>	VMADH     vec11 = ( acc+= (vec15 * vec29[4]) << 16) >> 16
	ErrorToCallFunction(0x040015CC);

_040015D0:	// 40015d0: <21effffe>	ADDI      T7 = T7 + fffe
	ErrorToCallFunction(0x040015D0);

_040015D4:	// 40015d4: <4bbd72cf>	VMADH     vec11 = ( acc+= (vec14 * vec29[5]) << 16) >> 16
	ErrorToCallFunction(0x040015D4);

_040015D8:	// 40015d8: <c9f12802>	LRV       vec17 <00> = [T7 + 0x20]
	ErrorToCallFunction(0x040015D8);

_040015DC:	// 40015dc: <4bdd6acf>	VMADH     vec11 = ( acc+= (vec13 * vec29[6]) << 16) >> 16
	ErrorToCallFunction(0x040015DC);

_040015E0:	// 40015e0: <21effffe>	ADDI      T7 = T7 + fffe
	ErrorToCallFunction(0x040015E0);

_040015E4:	// 40015e4: <4b7feacf>	VMADH     vec11 = ( acc+= (vec29 * vec31[3]) << 16) >> 16
	ErrorToCallFunction(0x040015E4);

_040015E8:	// 40015e8: <c9f02802>	LRV       vec16 <00> = [T7 + 0x20]
	ErrorToCallFunction(0x040015E8);

_040015EC:	// 40015ec: <4bdcaacf>	VMADH     vec11 = ( acc+= (vec21 * vec28[6]) << 16) >> 16
	ErrorToCallFunction(0x040015EC);

_040015F0:	// 40015f0: <21effffe>	ADDI      T7 = T7 + fffe
	ErrorToCallFunction(0x040015F0);

_040015F4:	// 40015f4: <4bfca2cf>	VMADH     vec11 = ( acc+= (vec20 * vec28[7]) << 16) >> 16
	ErrorToCallFunction(0x040015F4);

_040015F8:	// 40015f8: <c9ef2802>	LRV       vec15 <00> = [T7 + 0x20]
	ErrorToCallFunction(0x040015F8);

_040015FC:	// 40015fc: <4b3b369d>	VSAW $v26, $v6, $v27[[1]]
	ErrorToCallFunction(0x040015FC);

_04001600:	// 4001600: <21effffe>	ADDI      T7 = T7 + fffe
	ErrorToCallFunction(0x04001600);

_04001604:	// 4001604: <4b1b36dd>	VSAW $v27, $v6, $v27[[0]]
	ErrorToCallFunction(0x04001604);

_04001608:	// 4001608: <c9ee2802>	LRV       vec14 <00> = [T7 + 0x20]
	ErrorToCallFunction(0x04001608);

_0400160C:	// 400160c: <21effffe>	ADDI      T7 = T7 + fffe
	ErrorToCallFunction(0x0400160C);

_04001610:	// 4001610: <c9ed2802>	LRV       vec13 <00> = [T7 + 0x20]
	ErrorToCallFunction(0x04001610);

_04001614:	// 4001614: <ca152000>	LQV       vec21 <00> = [S0 + 0x00]
	ErrorToCallFunction(0x04001614);

_04001618:	// 4001618: <4b3fd2c6>	VMUDN     vec11 = ( acc = vec26 * vec31[1]      ) >> 16
	ErrorToCallFunction(0x04001618);

_0400161C:	// 400161c: <ca142001>	LQV       vec20 <00> = [S0 + 0x10]
	ErrorToCallFunction(0x0400161C);

_04001620:	// 4001620: <4b3fdecf>	VMADH     vec27 = ( acc+= (vec27 * vec31[1]) << 16) >> 16
	ErrorToCallFunction(0x04001620);

_04001624:	// 4001624: <22b5ffe0>	ADDI      S5 = S5 + ffe0
	ErrorToCallFunction(0x04001624);

_04001628:	// 4001628: <e83c2000>	SQV       [AT + 0x00] = vec28 <00>
	ErrorToCallFunction(0x04001628);

_0400162C:	// 400162c: <20210020>	ADDI      AT = AT + 0020
	ErrorToCallFunction(0x0400162C);

_04001630:	// 4001630: <1ea0ffb8>	BGTZ      (R0>0) --> 1514
	ErrorToCallFunction(0x04001630);

_04001634:	// 4001634: <e83b207f>	SQV       [AT + 0xf0] = vec27 <00>
	ErrorToCallFunction(0x04001634);

_04001638:	// 4001638: <2021ffe0>	ADDI      AT = AT + ffe0
	state.r[AT] = state.r[AT] + 0xFFFFFFE0;


_0400163C:	// 400163c: <0d00045e>	JAL	    04001178
	state.r[V0] = state.r[S4] + 0x0000;
	sp_reg_pc = 0x0400163C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001178;


_04001640:	// 4001640: <22820000>	ADDI      V0 = S4 + 0000
	state.r[V0] = state.r[S4] + 0x0000;


_04001644:	// 4001644: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_04001648:	// 4001648: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_0400164C:	// 400164c: <14a0ffff>	BNE       (R0!=A1) --> 164c
	sp_reg_pc = 0x0400164C;
	if (state.r[A1] != 0)
	{
		state.r[A1] = 0;
		goto _0400164C;
	}


_04001650:	// 4001650: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001654:	// 4001654: <0900043c>	J         040010f0
	goto _040010F0;


_04001658:	// 4001658: <40803800>	MTC0      SP semaphore = R0


_0400165C:	// 400165c: <00199e02>	SRL       S3 = T9 >> 24
	state.r[S3] = ((_u32)state.r[T9] >> 24);


_04001660:	// 4001660: <201403f0>	ADDI      S4 = R0 + 03f0
	state.r[S4] = 0 + 0x03F0;


_04001664:	// 4001664: <4a15ad6c>	VXOR      vec21 = vec21 xor vec21[<none>]
	rsp_cop2_vxor(&state.v[21], &state.v[21], &state.v[21]);


_04001668:	// 4001668: <12600002>	BEQ       (R0==S3) --> 1674
	sp_reg_pc = 0x04001668;
	if (state.r[S3] == 0)
	{
		state.r[S7] = 0 + 0x04F0;
		goto _04001674;
	}


_0400166C:	// 400166c: <201704f0>	ADDI      S7 = R0 + 04f0
	state.r[S7] = 0 + 0x04F0;


_04001670:	// 4001670: <20170660>	ADDI      S7 = R0 + 0660
	state.r[S7] = 0 + 0x0660;


_04001674:	// 4001674: <ca9c2001>	LQV       vec28 <00> = [S4 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[S4]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[28].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[28].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[28].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[28].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[28].U64[0] = state.v[28].U64[0] & ~temp1;
			state.v[28].U64[1] = state.v[28].U64[1] & ~temp2;
			state.v[28].U64[0] = state.v[28].U64[0] | value1;
			state.v[28].U64[1] = state.v[28].U64[1] | value2;
		}
	}


_04001678:	// 4001678: <4a16b5ac>	VXOR      vec22 = vec22 xor vec22[<none>]
	rsp_cop2_vxor(&state.v[22], &state.v[22], &state.v[22]);


_0400167C:	// 400167c: <489a9500>	MTC2      vec18 <10> = K0
	state.v[18].U16[2] = (_u16)state.r[K0];


_04001680:	// 4001680: <4a17bdec>	VXOR      vec23 = vec23 xor vec23[<none>]
	rsp_cop2_vxor(&state.v[23], &state.v[23], &state.v[23]);


_04001684:	// 4001684: <001ad080>	SLL       K0 = K0 << 2
	state.r[K0] = ((_u32)state.r[K0] << 2);


_04001688:	// 4001688: <4a18c62c>	VXOR      vec24 = vec24 xor vec24[<none>]
	rsp_cop2_vxor(&state.v[24], &state.v[24], &state.v[24]);


_0400168C:	// 400168c: <489aa000>	MTC2      vec20 <00> = K0
	state.v[20].U16[7] = (_u16)state.r[K0];


_04001690:	// 4001690: <4a19ce6c>	VXOR      vec25 = vec25 xor vec25[<none>]
	rsp_cop2_vxor(&state.v[25], &state.v[25], &state.v[25]);


_04001694:	// 4001694: <00191200>	SLL       V0 = T9 << 8
	state.r[V0] = ((_u32)state.r[T9] << 8);


_04001698:	// 4001698: <4a1ad6ac>	VXOR      vec26 = vec26 xor vec26[<none>]
	rsp_cop2_vxor(&state.v[26], &state.v[26], &state.v[26]);


_0400169C:	// 400169c: <00021202>	SRL       V0 = V0 >> 8
	state.r[V0] = ((_u32)state.r[V0] >> 8);


_040016A0:	// 40016a0: <4a1bdeec>	VXOR      vec27 = vec27 xor vec27[<none>]
	rsp_cop2_vxor(&state.v[27], &state.v[27], &state.v[27]);


_040016A4:	// 40016a4: <20420000>	ADDI      V0 = V0 + 0000
	state.r[V0] = state.r[V0] + 0x0000;


_040016A8:	// 40016a8: <20030007>	ADDI      V1 = R0 + 0007
	state.r[V1] = 0 + 0x0007;


_040016AC:	// 40016ac: <20130004>	ADDI      S3 = R0 + 0004
	state.r[S3] = 0 + 0x0004;


_040016B0:	// 40016b0: <48939000>	MTC2      vec18 <00> = S3
	state.v[18].U16[7] = (_u16)state.r[S3];


_040016B4:	// 40016b4: <20160170>	ADDI      S6 = R0 + 0170
	state.r[S6] = 0 + 0x0170;


_040016B8:	// 40016b8: <4b14e505>	VMUDM     vec20 = ( acc = vec28 * vec20[0] ) >> 16
	{
		_u16		s2value = state.v[20].U16[7];
		VMUDM_operation(0, state.v[20].U16[0], state.v[28].U16[0], s2value, 1, 1, 1, 1)
		VMUDM_operation(1, state.v[20].U16[1], state.v[28].U16[1], s2value, 1, 1, 1, 1)
		VMUDM_operation(2, state.v[20].U16[2], state.v[28].U16[2], s2value, 1, 1, 1, 1)
		VMUDM_operation(3, state.v[20].U16[3], state.v[28].U16[3], s2value, 1, 1, 1, 1)
		VMUDM_operation(4, state.v[20].U16[4], state.v[28].U16[4], s2value, 1, 1, 1, 1)
		VMUDM_operation(5, state.v[20].U16[5], state.v[28].U16[5], s2value, 1, 1, 1, 1)
		VMUDM_operation(6, state.v[20].U16[6], state.v[28].U16[6], s2value, 1, 1, 1, 1)
		VMUDM_operation(7, state.v[20].U16[7], state.v[28].U16[7], s2value, 1, 1, 1, 1)
	}


_040016BC:	// 40016bc: <001a9c82>	SRL       S3 = K0 >> 18
	state.r[S3] = ((_u32)state.r[K0] >> 18);


_040016C0:	// 40016c0: <32730001>	ANDI      S3 = S3 & 0001
	state.r[S3] = (state.r[S3] & 0x00000001);


_040016C4:	// 40016c4: <1e60001f>	BGTZ      (R0>0) --> 1744
	sp_reg_pc = 0x040016C4;
	if((_s32)state.r[S3] > 0)
	{
		{
			_u32    addr = (0x00000010 + state.r[S4]);
			int     shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				*(_u32 *)&pDMEM[addr+12] = state.v[20].U32[0];
				*(_u32 *)&pDMEM[addr+8 ] = state.v[20].U32[1];
				*(_u32 *)&pDMEM[addr+4 ] = state.v[20].U32[2];
				*(_u32 *)&pDMEM[addr   ] = state.v[20].U32[3];
			}
			else
			{
				_u64    value1 = Load64_DMEM(addr+8);
				_u64    value2 = Load64_DMEM(addr);
				_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & ~temp1;
				value2 = value2 & ~temp2;

				value1 |= (state.v[20].U64[0] & temp1);
				value2 |= (state.v[20].U64[1] & temp2);

				Save64_DMEM(value1, addr+8);
				Save64_DMEM(value2, addr  );
			}
		}
		goto _04001744;
	}


_040016C8:	// 40016c8: <ea942001>	SQV       [S4 + 0x10] = vec20 <00>
	{
		_u32    addr = (0x00000010 + state.r[S4]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[20].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[20].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[20].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[20].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[20].U64[0] & temp1);
			value2 |= (state.v[20].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_040016CC:	// 40016cc: <23010000>	ADDI      AT = T8 + 0000
	state.r[AT] = state.r[T8] + 0x0000;


_040016D0:	// 40016d0: <40133800>	MFC0      A3 = unknown
	state.r[S3] = 0;


_040016D4:	// 40016d4: <1660ffff>	BNE       (R0!=S3) --> 16d4
	sp_reg_pc = 0x040016D4;
	if (state.r[S3] != 0)
	{
		state.r[S3] = 0;
		goto _040016D4;
	}


_040016D8:	// 40016d8: <40133800>	MFC0      A3 = unknown
	state.r[S3] = 0;


_040016DC:	// 40016dc: <40132800>	MFC0      A1 = unknown
	state.r[S3] = 0;


_040016E0:	// 40016e0: <1660ffff>	BNE       (R0!=S3) --> 16e0
	sp_reg_pc = 0x040016E0;
	if (state.r[S3] != 0)
	{
		state.r[S3] = 0;
		goto _040016E0;
	}


_040016E4:	// 40016e4: <40132800>	MFC0      A1 = unknown
	state.r[S3] = 0;


_040016E8:	// 40016e8: <40810000>	MTC0      SP memory address = AT
	DMEM_Address = state.r[AT];


_040016EC:	// 40016ec: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_040016F0:	// 40016f0: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x040016F0;
	DMARead(state.r[V1]);


_040016F4:	// 40016f4: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_040016F8:	// 40016f8: <ca9b2802>	LRV       vec27 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[27].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_040016FC:	// 40016fc: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_04001700:	// 4001700: <ca9a2802>	LRV       vec26 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[26].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001704:	// 4001704: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_04001708:	// 4001708: <ca992802>	LRV       vec25 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[25].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_0400170C:	// 400170c: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_04001710:	// 4001710: <ca982802>	LRV       vec24 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[24].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001714:	// 4001714: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_04001718:	// 4001718: <ca972802>	LRV       vec23 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[23].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_0400171C:	// 400171c: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_04001720:	// 4001720: <ca962802>	LRV       vec22 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[22].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001724:	// 4001724: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_04001728:	// 4001728: <ca952802>	LRV       vec21 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[21].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_0400172C:	// 400172c: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001730:	// 4001730: <14a0ffff>	BNE       (R0!=A1) --> 1730
	sp_reg_pc = 0x04001730;
	if (state.r[A1] != 0)
	{
		state.r[A1] = 0;
		goto _04001730;
	}


_04001734:	// 4001734: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001738:	// 4001738: <40803800>	MTC0      SP semaphore = R0


_0400173C:	// 400173c: <090005e0>	J         04001780
	rsp_ldv_compiler((state.r[AT] & 0xFFF), 30, 0);
	goto _04001780;


_04001740:	// 4001740: <c83e1c00>	LDV       vec30 <08> = [AT + 0x00]
	rsp_ldv_compiler((state.r[AT] & 0xFFF), 30, 0);


_04001744:	// 4001744: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_04001748:	// 4001748: <4a1ef7ac>	VXOR      vec30 = vec30 xor vec30[<none>]
	rsp_cop2_vxor(&state.v[30], &state.v[30], &state.v[30]);


_0400174C:	// 400174c: <ca9b2802>	LRV       vec27 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[27].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001750:	// 4001750: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_04001754:	// 4001754: <ca9a2802>	LRV       vec26 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[26].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001758:	// 4001758: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_0400175C:	// 400175c: <ca992802>	LRV       vec25 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[25].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001760:	// 4001760: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_04001764:	// 4001764: <ca982802>	LRV       vec24 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[24].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001768:	// 4001768: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_0400176C:	// 400176c: <ca972802>	LRV       vec23 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[23].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001770:	// 4001770: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_04001774:	// 4001774: <ca962802>	LRV       vec22 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[22].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001778:	// 4001778: <2294fffe>	ADDI      S4 = S4 + fffe
	state.r[S4] = state.r[S4] + 0xFFFFFFFE;


_0400177C:	// 400177c: <ca952802>	LRV       vec21 <00> = [S4 + 0x20]
	{
		_s32		addr;
		_s32		offset;
		_u32		i, length;

		addr = (0x00000020 + state.r[S4]);
		offset = (addr & 0xf) - 1;
		length = (addr & 0xf);
		addr &= 0xff0;
		for (i=0; i<length; i++) {
			state.v[21].U8[offset - i] = pDMEM[(addr ^ 3)];
			addr++;
		}
	}


_04001780:	// 4001780: <caff2000>	LQV       vec31 <00> = [S7 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S7]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[31].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[31].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[31].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[31].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[31].U64[0] = state.v[31].U64[0] & ~temp1;
			state.v[31].U64[1] = state.v[31].U64[1] & ~temp2;
			state.v[31].U64[0] = state.v[31].U64[0] | value1;
			state.v[31].U64[1] = state.v[31].U64[1] | value2;
		}
	}


_04001784:	// 4001784: <4bfee507>	VMUDH     vec20 = ( acc = (vec28 * vec30[7]) << 16) >> 16
	{
		_u16		s2value = state.v[30].U16[0];
		VMUDH_operation(0, state.v[20].U16[0], state.v[28].U16[0], s2value, 0, 1, 0, 1)
		VMUDH_operation(1, state.v[20].U16[1], state.v[28].U16[1], s2value, 0, 1, 0, 1)
		VMUDH_operation(2, state.v[20].U16[2], state.v[28].U16[2], s2value, 0, 1, 0, 1)
		VMUDH_operation(3, state.v[20].U16[3], state.v[28].U16[3], s2value, 0, 1, 0, 1)
		VMUDH_operation(4, state.v[20].U16[4], state.v[28].U16[4], s2value, 0, 1, 0, 1)
		VMUDH_operation(5, state.v[20].U16[5], state.v[28].U16[5], s2value, 0, 1, 0, 1)
		VMUDH_operation(6, state.v[20].U16[6], state.v[28].U16[6], s2value, 0, 1, 0, 1)
		VMUDH_operation(7, state.v[20].U16[7], state.v[28].U16[7], s2value, 0, 1, 0, 1)
	}


_04001788:	// 4001788: <4b1fdd0f>	VMADH     vec20 = ( acc+= (vec27 * vec31[0]) << 16) >> 16
	{
		_u16		s2value = state.v[31].U16[7];
		VMADH_operation(0, state.v[20].U16[0], state.v[27].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[20].U16[1], state.v[27].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[20].U16[2], state.v[27].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[20].U16[3], state.v[27].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[20].U16[4], state.v[27].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[20].U16[5], state.v[27].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[20].U16[6], state.v[27].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[20].U16[7], state.v[27].U16[7], s2value, 0, 1, 0, 1)
	}


_0400178C:	// 400178c: <22d6fff0>	ADDI      S6 = S6 + fff0
	state.r[S6] = state.r[S6] + 0xFFFFFFF0;


_04001790:	// 4001790: <4b3fd50f>	VMADH     vec20 = ( acc+= (vec26 * vec31[1]) << 16) >> 16
	{
		_u16		s2value = state.v[31].U16[6];
		VMADH_operation(0, state.v[20].U16[0], state.v[26].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[20].U16[1], state.v[26].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[20].U16[2], state.v[26].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[20].U16[3], state.v[26].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[20].U16[4], state.v[26].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[20].U16[5], state.v[26].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[20].U16[6], state.v[26].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[20].U16[7], state.v[26].U16[7], s2value, 0, 1, 0, 1)
	}


_04001794:	// 4001794: <4b5fcd0f>	VMADH     vec20 = ( acc+= (vec25 * vec31[2]) << 16) >> 16
	{
		_u16		s2value = state.v[31].U16[5];
		VMADH_operation(0, state.v[20].U16[0], state.v[25].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[20].U16[1], state.v[25].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[20].U16[2], state.v[25].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[20].U16[3], state.v[25].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[20].U16[4], state.v[25].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[20].U16[5], state.v[25].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[20].U16[6], state.v[25].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[20].U16[7], state.v[25].U16[7], s2value, 0, 1, 0, 1)
	}


_04001798:	// 4001798: <eafe207f>	SQV       [S7 + 0xf0] = vec30 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[S7]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[30].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[30].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[30].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[30].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[30].U64[0] & temp1);
			value2 |= (state.v[30].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_0400179C:	// 400179c: <4b7fc50f>	VMADH     vec20 = ( acc+= (vec24 * vec31[3]) << 16) >> 16
	{
		_u16		s2value = state.v[31].U16[4];
		VMADH_operation(0, state.v[20].U16[0], state.v[24].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[20].U16[1], state.v[24].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[20].U16[2], state.v[24].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[20].U16[3], state.v[24].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[20].U16[4], state.v[24].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[20].U16[5], state.v[24].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[20].U16[6], state.v[24].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[20].U16[7], state.v[24].U16[7], s2value, 0, 1, 0, 1)
	}


_040017A0:	// 40017a0: <4b9fbf8f>	VMADH     vec30 = ( acc+= (vec23 * vec31[4]) << 16) >> 16
	{
		_u16		s2value = state.v[31].U16[3];
		VMADH_operation(0, state.v[30].U16[0], state.v[23].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[30].U16[1], state.v[23].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[30].U16[2], state.v[23].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[30].U16[3], state.v[23].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[30].U16[4], state.v[23].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[30].U16[5], state.v[23].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[30].U16[6], state.v[23].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[30].U16[7], state.v[23].U16[7], s2value, 0, 1, 0, 1)
	}


_040017A4:	// 40017a4: <4bbfb50f>	VMADH     vec20 = ( acc+= (vec22 * vec31[5]) << 16) >> 16
	{
		_u16		s2value = state.v[31].U16[2];
		VMADH_operation(0, state.v[20].U16[0], state.v[22].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[20].U16[1], state.v[22].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[20].U16[2], state.v[22].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[20].U16[3], state.v[22].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[20].U16[4], state.v[22].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[20].U16[5], state.v[22].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[20].U16[6], state.v[22].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[20].U16[7], state.v[22].U16[7], s2value, 0, 1, 0, 1)
	}


_040017A8:	// 40017a8: <4bdfad0f>	VMADH     vec20 = ( acc+= (vec21 * vec31[6]) << 16) >> 16
	{
		_u16		s2value = state.v[31].U16[1];
		VMADH_operation(0, state.v[20].U16[0], state.v[21].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[20].U16[1], state.v[21].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[20].U16[2], state.v[21].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[20].U16[3], state.v[21].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[20].U16[4], state.v[21].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[20].U16[5], state.v[21].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[20].U16[6], state.v[21].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[20].U16[7], state.v[21].U16[7], s2value, 0, 1, 0, 1)
	}


_040017AC:	// 40017ac: <4bb2fd0f>	VMADH     vec20 = ( acc+= (vec31 * vec18[5]) << 16) >> 16
	{
		_u16		s2value = state.v[18].U16[2];
		VMADH_operation(0, state.v[20].U16[0], state.v[31].U16[0], s2value, 0, 1, 0, 1)
		VMADH_operation(1, state.v[20].U16[1], state.v[31].U16[1], s2value, 0, 1, 0, 1)
		VMADH_operation(2, state.v[20].U16[2], state.v[31].U16[2], s2value, 0, 1, 0, 1)
		VMADH_operation(3, state.v[20].U16[3], state.v[31].U16[3], s2value, 0, 1, 0, 1)
		VMADH_operation(4, state.v[20].U16[4], state.v[31].U16[4], s2value, 0, 1, 0, 1)
		VMADH_operation(5, state.v[20].U16[5], state.v[31].U16[5], s2value, 0, 1, 0, 1)
		VMADH_operation(6, state.v[20].U16[6], state.v[31].U16[6], s2value, 0, 1, 0, 1)
		VMADH_operation(7, state.v[20].U16[7], state.v[31].U16[7], s2value, 0, 1, 0, 1)
	}


_040017B0:	// 40017b0: <caff2001>	LQV       vec31 <00> = [S7 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[S7]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[31].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[31].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[31].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[31].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[31].U64[0] = state.v[31].U64[0] & ~temp1;
			state.v[31].U64[1] = state.v[31].U64[1] & ~temp2;
			state.v[31].U64[0] = state.v[31].U64[0] | value1;
			state.v[31].U64[1] = state.v[31].U64[1] | value2;
		}
	}


_040017B4:	// 40017b4: <4b3e9f5d>	VSAW $v29, $v19, $v30[[1]]
	state.v[29].U16[0] = state.accum[0].U16[2];
	state.v[29].U16[1] = state.accum[1].U16[2];
	state.v[29].U16[2] = state.accum[2].U16[2];
	state.v[29].U16[3] = state.accum[3].U16[2];
	state.v[29].U16[4] = state.accum[4].U16[2];
	state.v[29].U16[5] = state.accum[5].U16[2];
	state.v[29].U16[6] = state.accum[6].U16[2];
	state.v[29].U16[7] = state.accum[7].U16[2];


_040017B8:	// 40017b8: <4b1e9f9d>	VSAW $v30, $v19, $v30[[0]]
	state.v[30].U16[0] = state.accum[0].U16[3];
	state.v[30].U16[1] = state.accum[1].U16[3];
	state.v[30].U16[2] = state.accum[2].U16[3];
	state.v[30].U16[3] = state.accum[3].U16[3];
	state.v[30].U16[4] = state.accum[4].U16[3];
	state.v[30].U16[5] = state.accum[5].U16[3];
	state.v[30].U16[6] = state.accum[6].U16[3];
	state.v[30].U16[7] = state.accum[7].U16[3];


_040017BC:	// 40017bc: <4b12ed06>	VMUDN     vec20 = ( acc = vec29 * vec18[0]      ) >> 16
	{
		_u16		s2value = state.v[18].U16[7];
		VMUDN_operation(0, state.v[20].U16[0], state.v[29].U16[0], s2value, 1, 1, 1, 1)
		VMUDN_operation(1, state.v[20].U16[1], state.v[29].U16[1], s2value, 1, 1, 1, 1)
		VMUDN_operation(2, state.v[20].U16[2], state.v[29].U16[2], s2value, 1, 1, 1, 1)
		VMUDN_operation(3, state.v[20].U16[3], state.v[29].U16[3], s2value, 1, 1, 1, 1)
		VMUDN_operation(4, state.v[20].U16[4], state.v[29].U16[4], s2value, 1, 1, 1, 1)
		VMUDN_operation(5, state.v[20].U16[5], state.v[29].U16[5], s2value, 1, 1, 1, 1)
		VMUDN_operation(6, state.v[20].U16[6], state.v[29].U16[6], s2value, 1, 1, 1, 1)
		VMUDN_operation(7, state.v[20].U16[7], state.v[29].U16[7], s2value, 1, 1, 1, 1)
	}


_040017C0:	// 40017c0: <4b12f78f>	VMADH     vec30 = ( acc+= (vec30 * vec18[0]) << 16) >> 16
	{
		_u16		s2value = state.v[18].U16[7];
		VMADH_operation(0, state.v[30].U16[0], state.v[30].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[30].U16[1], state.v[30].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[30].U16[2], state.v[30].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[30].U16[3], state.v[30].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[30].U16[4], state.v[30].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[30].U16[5], state.v[30].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[30].U16[6], state.v[30].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[30].U16[7], state.v[30].U16[7], s2value, 1, 1, 0, 1)
	}


_040017C4:	// 40017c4: <1ec0ffef>	BGTZ      (R0>0) --> 1784
	sp_reg_pc = 0x040017C4;
	if((_s32)state.r[S6] > 0)
	{
		state.r[S7] = state.r[S7] + 0x0010;
		goto _04001784;
	}


_040017C8:	// 40017c8: <22f70010>	ADDI      S7 = S7 + 0010
	state.r[S7] = state.r[S7] + 0x0010;


_040017CC:	// 40017cc: <22e1fff8>	ADDI      AT = S7 + fff8
	state.r[AT] = state.r[S7] + 0xFFFFFFF8;


_040017D0:	// 40017d0: <0d00045e>	JAL	    04001178
	{
		_u32    addr = (0xFFFFFFF0 + state.r[S7]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[30].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[30].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[30].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[30].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[30].U64[0] & temp1);
			value2 |= (state.v[30].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}
	sp_reg_pc = 0x040017D0;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001178;


_040017D4:	// 40017d4: <eafe207f>	SQV       [S7 + 0xf0] = vec30 <00>
	{
		_u32    addr = (0xFFFFFFF0 + state.r[S7]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[30].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[30].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[30].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[30].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[30].U64[0] & temp1);
			value2 |= (state.v[30].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_040017D8:	// 40017d8: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_040017DC:	// 40017dc: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_040017E0:	// 40017e0: <14a0ffff>	BNE       (R0!=A1) --> 17e0
	sp_reg_pc = 0x040017E0;
	if (state.r[A1] != 0)
	{
		state.r[A1] = 0;
		goto _040017E0;
	}


_040017E4:	// 40017e4: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_040017E8:	// 40017e8: <0900043c>	J         040010f0
	goto _040010F0;


_040017EC:	// 40017ec: <40803800>	MTC0      SP semaphore = R0


_040017F0:	// 40017f0: <001a1200>	SLL       V0 = K0 << 8
	state.r[V0] = ((_u32)state.r[K0] << 8);


_040017F4:	// 40017f4: <4a17bdec>	VXOR      vec23 = vec23 xor vec23[<none>]
	rsp_cop2_vxor(&state.v[23], &state.v[23], &state.v[23]);


_040017F8:	// 40017f8: <00021202>	SRL       V0 = V0 >> 8
	state.r[V0] = ((_u32)state.r[V0] >> 8);


_040017FC:	// 40017fc: <20420000>	ADDI      V0 = V0 + 0000
	state.r[V0] = state.r[V0] + 0x0000;


_04001800:	// 4001800: <2003000f>	ADDI      V1 = R0 + 000f
	state.r[V1] = 0 + 0x000F;


_04001804:	// 4001804: <0019af82>	SRL       S5 = T9 >> 30
	state.r[S5] = ((_u32)state.r[T9] >> 30);


_04001808:	// 4001808: <1ea00016>	BGTZ      (R0>0) --> 1864
	sp_reg_pc = 0x04001808;
	if((_s32)state.r[S5] > 0)
	{
		state.r[AT] = state.r[T8] + 0x0000;
		goto _04001864;
	}


_0400180C:	// 400180c: <23010000>	ADDI      AT = T8 + 0000
	state.r[AT] = state.r[T8] + 0x0000;


_04001810:	// 4001810: <40043800>	MFC0      A3 = SP status
	state.r[A0] = 0;


_04001814:	// 4001814: <1480ffff>	BNE       (R0!=A0) --> 1814
	sp_reg_pc = 0x04001814;
	if (state.r[A0] != 0)
	{
		state.r[A0] = 0;
		goto _04001814;
	}


_04001818:	// 4001818: <40043800>	MFC0      A3 = SP status
	state.r[A0] = 0;


_0400181C:	// 400181c: <40042800>	MFC0      A1 = SP status
	state.r[A0] = 0;


_04001820:	// 4001820: <1480ffff>	BNE       (R0!=A0) --> 1820
	sp_reg_pc = 0x04001820;
	if (state.r[A0] != 0)
	{
		state.r[A0] = 0;
		goto _04001820;
	}


_04001824:	// 4001824: <40042800>	MFC0      A1 = SP status
	state.r[A0] = 0;


_04001828:	// 4001828: <40810000>	MTC0      SP memory address = AT
	DMEM_Address = state.r[AT];


_0400182C:	// 400182c: <40820800>	MTC0      SP DRAM DMA address = V0
	RDRAM_Address = (state.r[V0] & 0xFFFFFF);


_04001830:	// 4001830: <40831000>	MTC0      SP read DMA length = V1
	sp_reg_pc = 0x04001830;
	DMARead(state.r[V1]);


_04001834:	// 4001834: <0019a082>	SRL       S4 = T9 >> 2
	state.r[S4] = ((_u32)state.r[T9] >> 2);


_04001838:	// 4001838: <32940fff>	ANDI      S4 = S4 & 0fff
	state.r[S4] = (state.r[S4] & 0x00000FFF);


_0400183C:	// 400183c: <229404e8>	ADDI      S4 = S4 + 04e8
	state.r[S4] = state.r[S4] + 0x04E8;


_04001840:	// 4001840: <c81f2004>	LQV       vec31 <00> = [R0 + 0x40]
	{
		_u32 addr = (0x00000040 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[31].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[31].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[31].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[31].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[31].U64[0] = state.v[31].U64[0] & ~temp1;
			state.v[31].U64[1] = state.v[31].U64[1] & ~temp2;
			state.v[31].U64[0] = state.v[31].U64[0] | value1;
			state.v[31].U64[1] = state.v[31].U64[1] | value2;
		}
	}


_04001844:	// 4001844: <c8192003>	LQV       vec25 <00> = [R0 + 0x30]
	{
		_u32 addr = (0x00000030 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[25].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[25].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[25].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[25].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[25].U64[0] = state.v[25].U64[0] & ~temp1;
			state.v[25].U64[1] = state.v[25].U64[1] & ~temp2;
			state.v[25].U64[0] = state.v[25].U64[0] | value1;
			state.v[25].U64[1] = state.v[25].U64[1] | value2;
		}
	}


_04001848:	// 4001848: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_0400184C:	// 400184c: <14a0ffff>	BNE       (R0!=A1) --> 184c
	sp_reg_pc = 0x0400184C;
	if (state.r[A1] != 0)
	{
		state.r[A1] = 0;
		goto _0400184C;
	}


_04001850:	// 4001850: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001854:	// 4001854: <40803800>	MTC0      SP semaphore = R0


_04001858:	// 4001858: <cb131800>	LDV       vec19 <00> = [T8 + 0x00]
	rsp_ldv_compiler((state.r[T8] & 0xFFF), 19, 8);


_0400185C:	// 400185c: <09000620>	J         04001880
	state.v[24].U16[0] = Load16_DMEM(0x00000008 + state.r[T8]);
	goto _04001880;


_04001860:	// 4001860: <cb180f04>	LSV       vec24 <14> = [T8 + 0x08]
	state.v[24].U16[0] = Load16_DMEM(0x00000008 + state.r[T8]);


_04001864:	// 4001864: <0019a082>	SRL       S4 = T9 >> 2
	state.r[S4] = ((_u32)state.r[T9] >> 2);


_04001868:	// 4001868: <32940fff>	ANDI      S4 = S4 & 0fff
	state.r[S4] = (state.r[S4] & 0x00000FFF);


_0400186C:	// 400186c: <229404e8>	ADDI      S4 = S4 + 04e8
	state.r[S4] = state.r[S4] + 0x04E8;


_04001870:	// 4001870: <c81f2004>	LQV       vec31 <00> = [R0 + 0x40]
	{
		_u32 addr = (0x00000040 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[31].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[31].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[31].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[31].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[31].U64[0] = state.v[31].U64[0] & ~temp1;
			state.v[31].U64[1] = state.v[31].U64[1] & ~temp2;
			state.v[31].U64[0] = state.v[31].U64[0] | value1;
			state.v[31].U64[1] = state.v[31].U64[1] | value2;
		}
	}


_04001874:	// 4001874: <4a139cec>	VXOR      vec19 = vec19 xor vec19[<none>]
	rsp_cop2_vxor(&state.v[19], &state.v[19], &state.v[19]);


_04001878:	// 4001878: <c8192003>	LQV       vec25 <00> = [R0 + 0x30]
	{
		_u32 addr = (0x00000030 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[25].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[25].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[25].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[25].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[25].U64[0] = state.v[25].U64[0] & ~temp1;
			state.v[25].U64[1] = state.v[25].U64[1] & ~temp2;
			state.v[25].U64[0] = state.v[25].U64[0] | value1;
			state.v[25].U64[1] = state.v[25].U64[1] | value2;
		}
	}


_0400187C:	// 400187c: <4a18c62c>	VXOR      vec24 = vec24 xor vec24[<none>]
	rsp_cop2_vxor(&state.v[24], &state.v[24], &state.v[24]);


_04001880:	// 4001880: <4894aa00>	MTC2      vec21 <04> = S4
	state.v[21].U16[5] = (_u16)state.r[S4];


_04001884:	// 4001884: <200400b0>	ADDI      A0 = R0 + 00b0
	state.r[A0] = 0 + 0x00B0;


_04001888:	// 4001888: <4884ab00>	MTC2      vec21 <06> = A0
	state.v[21].U16[4] = (_u16)state.r[A0];


_0400188C:	// 400188c: <4a1fce51>	VSUB      vec25 = vec25 - vec31[<none>]
	{
		_u16		flag0 = state.flag[0];
		VSUB_operation(0, state.v[25].U16[0], state.v[25].U16[0], state.v[31].U16[0], 1, 0, 0, 1)
		VSUB_operation(1, state.v[25].U16[1], state.v[25].U16[1], state.v[31].U16[1], 1, 0, 0, 1)
		VSUB_operation(2, state.v[25].U16[2], state.v[25].U16[2], state.v[31].U16[2], 1, 0, 0, 1)
		VSUB_operation(3, state.v[25].U16[3], state.v[25].U16[3], state.v[31].U16[3], 1, 0, 0, 1)
		VSUB_operation(4, state.v[25].U16[4], state.v[25].U16[4], state.v[31].U16[4], 1, 0, 0, 1)
		VSUB_operation(5, state.v[25].U16[5], state.v[25].U16[5], state.v[31].U16[5], 1, 0, 0, 1)
		VSUB_operation(6, state.v[25].U16[6], state.v[25].U16[6], state.v[31].U16[6], 1, 0, 0, 1)
		VSUB_operation(7, state.v[25].U16[7], state.v[25].U16[7], state.v[31].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001890:	// 4001890: <00192382>	SRL       A0 = T9 >> 14
	state.r[A0] = ((_u32)state.r[T9] >> 14);


_04001894:	// 4001894: <4884ac00>	MTC2      vec21 <08> = A0
	state.v[21].U16[3] = (_u16)state.r[A0];


_04001898:	// 4001898: <20040040>	ADDI      A0 = R0 + 0040
	state.r[A0] = 0 + 0x0040;


_0400189C:	// 400189c: <4884ad00>	MTC2      vec21 <10> = A0
	state.v[21].U16[2] = (_u16)state.r[A0];


_040018A0:	// 40018a0: <4a1fce51>	VSUB      vec25 = vec25 - vec31[<none>]
	{
		_u16		flag0 = state.flag[0];
		VSUB_operation(0, state.v[25].U16[0], state.v[25].U16[0], state.v[31].U16[0], 1, 0, 0, 1)
		VSUB_operation(1, state.v[25].U16[1], state.v[25].U16[1], state.v[31].U16[1], 1, 0, 0, 1)
		VSUB_operation(2, state.v[25].U16[2], state.v[25].U16[2], state.v[31].U16[2], 1, 0, 0, 1)
		VSUB_operation(3, state.v[25].U16[3], state.v[25].U16[3], state.v[31].U16[3], 1, 0, 0, 1)
		VSUB_operation(4, state.v[25].U16[4], state.v[25].U16[4], state.v[31].U16[4], 1, 0, 0, 1)
		VSUB_operation(5, state.v[25].U16[5], state.v[25].U16[5], state.v[31].U16[5], 1, 0, 0, 1)
		VSUB_operation(6, state.v[25].U16[6], state.v[25].U16[6], state.v[31].U16[6], 1, 0, 0, 1)
		VSUB_operation(7, state.v[25].U16[7], state.v[25].U16[7], state.v[31].U16[7], 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_040018A4:	// 40018a4: <c81e2005>	LQV       vec30 <00> = [R0 + 0x50]
	{
		_u32 addr = (0x00000050 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[30].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[30].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[30].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[30].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[30].U64[0] = state.v[30].U64[0] & ~temp1;
			state.v[30].U64[1] = state.v[30].U64[1] & ~temp2;
			state.v[30].U64[0] = state.v[30].U64[0] | value1;
			state.v[30].U64[1] = state.v[30].U64[1] | value2;
		}
	}


_040018A8:	// 40018a8: <c81d2006>	LQV       vec29 <00> = [R0 + 0x60]
	{
		_u32 addr = (0x00000060 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[29].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[29].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[29].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[29].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[29].U64[0] = state.v[29].U64[0] & ~temp1;
			state.v[29].U64[1] = state.v[29].U64[1] & ~temp2;
			state.v[29].U64[0] = state.v[29].U64[0] | value1;
			state.v[29].U64[1] = state.v[29].U64[1] | value2;
		}
	}


_040018AC:	// 40018ac: <c81c2007>	LQV       vec28 <00> = [R0 + 0x70]
	{
		_u32 addr = (0x00000070 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[28].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[28].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[28].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[28].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[28].U64[0] = state.v[28].U64[0] & ~temp1;
			state.v[28].U64[1] = state.v[28].U64[1] & ~temp2;
			state.v[28].U64[0] = state.v[28].U64[0] | value1;
			state.v[28].U64[1] = state.v[28].U64[1] | value2;
		}
	}


_040018B0:	// 40018b0: <4bf8fe05>	VMUDM     vec24 = ( acc = vec31 * vec24[7] ) >> 16
	{
		_u16		s2value = state.v[24].U16[0];
		VMUDM_operation(0, state.v[24].U16[0], state.v[31].U16[0], s2value, 0, 1, 1, 1)
		VMUDM_operation(1, state.v[24].U16[1], state.v[31].U16[1], s2value, 0, 1, 1, 1)
		VMUDM_operation(2, state.v[24].U16[2], state.v[31].U16[2], s2value, 0, 1, 1, 1)
		VMUDM_operation(3, state.v[24].U16[3], state.v[31].U16[3], s2value, 0, 1, 1, 1)
		VMUDM_operation(4, state.v[24].U16[4], state.v[31].U16[4], s2value, 0, 1, 1, 1)
		VMUDM_operation(5, state.v[24].U16[5], state.v[31].U16[5], s2value, 0, 1, 1, 1)
		VMUDM_operation(6, state.v[24].U16[6], state.v[31].U16[6], s2value, 0, 1, 1, 1)
		VMUDM_operation(7, state.v[24].U16[7], state.v[31].U16[7], s2value, 0, 1, 1, 1)
	}


_040018B4:	// 40018b4: <c81b2008>	LQV       vec27 <00> = [R0 + 0x80]
	{
		_u32 addr = (0x00000080 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
			state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
			state.v[27].U64[0] = state.v[27].U64[0] | value1;
			state.v[27].U64[1] = state.v[27].U64[1] | value2;
		}
	}


_040018B8:	// 40018b8: <4b95cdcd>	VMADM     vec23 = ( acc+= vec25 * vec21[4] ) >> 16
	{
		_u16		s2value = state.v[21].U16[3];
		VMADM_operation(0, state.v[23].U16[0], state.v[25].U16[0], s2value, 1, 1, 1, 1)
		VMADM_operation(1, state.v[23].U16[1], state.v[25].U16[1], s2value, 1, 1, 1, 1)
		VMADM_operation(2, state.v[23].U16[2], state.v[25].U16[2], s2value, 1, 1, 1, 1)
		VMADM_operation(3, state.v[23].U16[3], state.v[25].U16[3], s2value, 1, 1, 1, 1)
		VMADM_operation(4, state.v[23].U16[4], state.v[25].U16[4], s2value, 1, 1, 1, 1)
		VMADM_operation(5, state.v[23].U16[5], state.v[25].U16[5], s2value, 1, 1, 1, 1)
		VMADM_operation(6, state.v[23].U16[6], state.v[25].U16[6], s2value, 1, 1, 1, 1)
		VMADM_operation(7, state.v[23].U16[7], state.v[25].U16[7], s2value, 1, 1, 1, 1)
	}


_040018BC:	// 40018bc: <c81a2009>	LQV       vec26 <00> = [R0 + 0x90]
	{
		_u32 addr = (0x00000090 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[26].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[26].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[26].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[26].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[26].U64[0] = state.v[26].U64[0] & ~temp1;
			state.v[26].U64[1] = state.v[26].U64[1] & ~temp2;
			state.v[26].U64[0] = state.v[26].U64[0] | value1;
			state.v[26].U64[1] = state.v[26].U64[1] | value2;
		}
	}


_040018C0:	// 40018c0: <4b1efe0e>	VMADN     vec24 = ( acc+= vec31 * vec30[0] )
	{
		_u16		s2value = state.v[30].U16[7];
		VMADN_operation(0, state.v[24].U16[0], state.v[31].U16[0], s2value, 1, 0, 0, 1)
		VMADN_operation(1, state.v[24].U16[1], state.v[31].U16[1], s2value, 1, 0, 0, 1)
		VMADN_operation(2, state.v[24].U16[2], state.v[31].U16[2], s2value, 1, 0, 0, 1)
		VMADN_operation(3, state.v[24].U16[3], state.v[31].U16[3], s2value, 1, 0, 0, 1)
		VMADN_operation(4, state.v[24].U16[4], state.v[31].U16[4], s2value, 1, 0, 0, 1)
		VMADN_operation(5, state.v[24].U16[5], state.v[31].U16[5], s2value, 1, 0, 0, 1)
		VMADN_operation(6, state.v[24].U16[6], state.v[31].U16[6], s2value, 1, 0, 0, 1)
		VMADN_operation(7, state.v[24].U16[7], state.v[31].U16[7], s2value, 1, 0, 0, 1)
	}


_040018C4:	// 40018c4: <ea931800>	SDV       [S4 + 0x00] = vec19 <00>
	{
		_u32	addr = (0x00000000 + state.r[S4]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[19].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[19].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[19].U32[0x00000003];
		}
	}


_040018C8:	// 40018c8: <c8192003>	LQV       vec25 <00> = [R0 + 0x30]
	{
		_u32 addr = (0x00000030 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[25].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[25].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[25].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[25].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[25].U64[0] = state.v[25].U64[0] & ~temp1;
			state.v[25].U64[1] = state.v[25].U64[1] & ~temp2;
			state.v[25].U64[0] = state.v[25].U64[0] | value1;
			state.v[25].U64[1] = state.v[25].U64[1] | value2;
		}
	}


_040018CC:	// 40018cc: <4b55fd86>	VMUDN     vec22 = ( acc = vec31 * vec21[2]      ) >> 16
	{
		_u16		s2value = state.v[21].U16[5];
		VMUDN_operation(0, state.v[22].U16[0], state.v[31].U16[0], s2value, 0, 1, 1, 1)
		VMUDN_operation(1, state.v[22].U16[1], state.v[31].U16[1], s2value, 0, 1, 1, 1)
		VMUDN_operation(2, state.v[22].U16[2], state.v[31].U16[2], s2value, 0, 1, 1, 1)
		VMUDN_operation(3, state.v[22].U16[3], state.v[31].U16[3], s2value, 0, 1, 1, 1)
		VMUDN_operation(4, state.v[22].U16[4], state.v[31].U16[4], s2value, 0, 1, 1, 1)
		VMUDN_operation(5, state.v[22].U16[5], state.v[31].U16[5], s2value, 0, 1, 1, 1)
		VMUDN_operation(6, state.v[22].U16[6], state.v[31].U16[6], s2value, 0, 1, 1, 1)
		VMUDN_operation(7, state.v[22].U16[7], state.v[31].U16[7], s2value, 0, 1, 1, 1)
	}


_040018D0:	// 40018d0: <20160170>	ADDI      S6 = R0 + 0170
	state.r[S6] = 0 + 0x0170;


_040018D4:	// 40018d4: <4b5ebd8e>	VMADN     vec22 = ( acc+= vec23 * vec30[2] )
	{
		_u16		s2value = state.v[30].U16[5];
		VMADN_operation(0, state.v[22].U16[0], state.v[23].U16[0], s2value, 1, 0, 0, 1)
		VMADN_operation(1, state.v[22].U16[1], state.v[23].U16[1], s2value, 1, 0, 0, 1)
		VMADN_operation(2, state.v[22].U16[2], state.v[23].U16[2], s2value, 1, 0, 0, 1)
		VMADN_operation(3, state.v[22].U16[3], state.v[23].U16[3], s2value, 1, 0, 0, 1)
		VMADN_operation(4, state.v[22].U16[4], state.v[23].U16[4], s2value, 1, 0, 0, 1)
		VMADN_operation(5, state.v[22].U16[5], state.v[23].U16[5], s2value, 1, 0, 0, 1)
		VMADN_operation(6, state.v[22].U16[6], state.v[23].U16[6], s2value, 1, 0, 0, 1)
		VMADN_operation(7, state.v[22].U16[7], state.v[23].U16[7], s2value, 1, 0, 0, 1)
	}


_040018D8:	// 40018d8: <33240003>	ANDI      A0 = T9 & 0003
	state.r[A0] = (state.r[T9] & 0x00000003);


_040018DC:	// 40018dc: <4bb5c504>	VMUDL     vec20 = ( acc = (vec24 * vec21[5] >> 16)      )
	{
		_u16		s2value = state.v[21].U16[2];
		VMUDL_operation(0, state.v[20].U16[0], state.v[24].U16[0], s2value, 1, 1, 1, 1)
		VMUDL_operation(1, state.v[20].U16[1], state.v[24].U16[1], s2value, 1, 1, 1, 1)
		VMUDL_operation(2, state.v[20].U16[2], state.v[24].U16[2], s2value, 1, 1, 1, 1)
		VMUDL_operation(3, state.v[20].U16[3], state.v[24].U16[3], s2value, 1, 1, 1, 1)
		VMUDL_operation(4, state.v[20].U16[4], state.v[24].U16[4], s2value, 1, 1, 1, 1)
		VMUDL_operation(5, state.v[20].U16[5], state.v[24].U16[5], s2value, 1, 1, 1, 1)
		VMUDL_operation(6, state.v[20].U16[6], state.v[24].U16[6], s2value, 1, 1, 1, 1)
		VMUDL_operation(7, state.v[20].U16[7], state.v[24].U16[7], s2value, 1, 1, 1, 1)
	}


_040018E0:	// 40018e0: <10800002>	BEQ       (R0==A0) --> 18ec
	sp_reg_pc = 0x040018E0;
	if (state.r[A0] == 0)
	{
		state.r[S7] = 0 + 0x04F0;
		goto _040018EC;
	}


_040018E4:	// 40018e4: <201704f0>	ADDI      S7 = R0 + 04f0
	state.r[S7] = 0 + 0x04F0;


_040018E8:	// 40018e8: <20170660>	ADDI      S7 = R0 + 0660
	state.r[S7] = 0 + 0x0660;


_040018EC:	// 40018ec: <eb180b84>	SSV       [T8 + 0x08] = vec24 <07>
	Save16_DMEM(state.v[24].U16[4], (0x00000008 + state.r[T8]) & 0xfff);


_040018F0:	// 40018f0: <4b9ea506>	VMUDN     vec20 = ( acc = vec20 * vec30[4]      ) >> 16
	{
		_u16		s2value = state.v[30].U16[3];
		VMUDN_operation(0, state.v[20].U16[0], state.v[20].U16[0], s2value, 0, 1, 1, 1)
		VMUDN_operation(1, state.v[20].U16[1], state.v[20].U16[1], s2value, 0, 1, 1, 1)
		VMUDN_operation(2, state.v[20].U16[2], state.v[20].U16[2], s2value, 0, 1, 1, 1)
		VMUDN_operation(3, state.v[20].U16[3], state.v[20].U16[3], s2value, 0, 1, 1, 1)
		VMUDN_operation(4, state.v[20].U16[4], state.v[20].U16[4], s2value, 0, 1, 1, 1)
		VMUDN_operation(5, state.v[20].U16[5], state.v[20].U16[5], s2value, 0, 1, 1, 1)
		VMUDN_operation(6, state.v[20].U16[6], state.v[20].U16[6], s2value, 0, 1, 1, 1)
		VMUDN_operation(7, state.v[20].U16[7], state.v[20].U16[7], s2value, 0, 1, 1, 1)
	}


_040018F4:	// 40018f4: <e816207b>	SQV       [R0 + 0xb0] = vec22 <00>
	{
		_u32    addr = (0xFFFFFFB0 + 0);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[22].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[22].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[22].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[22].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[22].U64[0] & temp1);
			value2 |= (state.v[22].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_040018F8:	// 40018f8: <4b75fd0e>	VMADN     vec20 = ( acc+= vec31 * vec21[3] )
	{
		_u16		s2value = state.v[21].U16[4];
		VMADN_operation(0, state.v[20].U16[0], state.v[31].U16[0], s2value, 1, 0, 0, 1)
		VMADN_operation(1, state.v[20].U16[1], state.v[31].U16[1], s2value, 1, 0, 0, 1)
		VMADN_operation(2, state.v[20].U16[2], state.v[31].U16[2], s2value, 1, 0, 0, 1)
		VMADN_operation(3, state.v[20].U16[3], state.v[31].U16[3], s2value, 1, 0, 0, 1)
		VMADN_operation(4, state.v[20].U16[4], state.v[31].U16[4], s2value, 1, 0, 0, 1)
		VMADN_operation(5, state.v[20].U16[5], state.v[31].U16[5], s2value, 1, 0, 0, 1)
		VMADN_operation(6, state.v[20].U16[6], state.v[31].U16[6], s2value, 1, 0, 0, 1)
		VMADN_operation(7, state.v[20].U16[7], state.v[31].U16[7], s2value, 1, 0, 0, 1)
	}


_040018FC:	// 40018fc: <e814207c>	SQV       [R0 + 0xc0] = vec20 <00>
	{
		_u32    addr = (0xFFFFFFC0 + 0);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[20].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[20].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[20].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[20].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[20].U64[0] & temp1);
			value2 |= (state.v[20].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001900:	// 4001900: <84150fb0>	LH        S5 = [R0+0fb0]
	state.r[S5] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FB0) & 0xfff);


_04001904:	// 4001904: <840d0fc0>	LH        T5 = [R0+0fc0]
	state.r[T5] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FC0) & 0xfff);


_04001908:	// 4001908: <84110fb8>	LH        S1 = [R0+0fb8]
	state.r[S1] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FB8) & 0xfff);


_0400190C:	// 400190c: <84090fc8>	LH        T1 = [R0+0fc8]
	state.r[T1] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FC8) & 0xfff);


_04001910:	// 4001910: <84140fb2>	LH        S4 = [R0+0fb2]
	state.r[S4] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FB2) & 0xfff);


_04001914:	// 4001914: <840c0fc2>	LH        T4 = [R0+0fc2]
	state.r[T4] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FC2) & 0xfff);


_04001918:	// 4001918: <84100fba>	LH        S0 = [R0+0fba]
	state.r[S0] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FBA) & 0xfff);


_0400191C:	// 400191c: <84080fca>	LH        T0 = [R0+0fca]
	state.r[T0] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FCA) & 0xfff);


_04001920:	// 4001920: <84130fb4>	LH        S3 = [R0+0fb4]
	state.r[S3] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FB4) & 0xfff);


_04001924:	// 4001924: <840b0fc4>	LH        T3 = [R0+0fc4]
	state.r[T3] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FC4) & 0xfff);


_04001928:	// 4001928: <840f0fbc>	LH        T7 = [R0+0fbc]
	state.r[T7] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FBC) & 0xfff);


_0400192C:	// 400192c: <84070fcc>	LH        A3 = [R0+0fcc]
	state.r[A3] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FCC) & 0xfff);


_04001930:	// 4001930: <84120fb6>	LH        S2 = [R0+0fb6]
	state.r[S2] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FB6) & 0xfff);


_04001934:	// 4001934: <840a0fc6>	LH        T2 = [R0+0fc6]
	state.r[T2] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FC6) & 0xfff);


_04001938:	// 4001938: <840e0fbe>	LH        T6 = [R0+0fbe]
	state.r[T6] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FBE) & 0xfff);


_0400193C:	// 400193c: <84060fce>	LH        A2 = [R0+0fce]
	state.r[A2] = (_s32)(_s16)Load16_DMEM((0 + 0x00000FCE) & 0xfff);


_04001940:	// 4001940: <cab31800>	LDV       vec19 <00> = [S5 + 0x00]
	// In function: SmashBros193C_1A28
	//Call the function: SmashBros193C_1A28
	SmashBros193C_1A28();
	goto _04001A30;

_04001944:	// 4001944: <4bf8fe05>	VMUDM     vec24 = ( acc = vec31 * vec24[7] ) >> 16
	ErrorToCallFunction(0x04001944);

_04001948:	// 4001948: <c9b21800>	LDV       vec18 <00> = [T5 + 0x00]
	ErrorToCallFunction(0x04001948);

_0400194C:	// 400194c: <4bf7fe0f>	VMADH     vec24 = ( acc+= (vec31 * vec23[7]) << 16) >> 16
	ErrorToCallFunction(0x0400194C);

_04001950:	// 4001950: <ca331c00>	LDV       vec19 <08> = [S1 + 0x00]
	ErrorToCallFunction(0x04001950);

_04001954:	// 4001954: <4b95cdcd>	VMADM     vec23 = ( acc+= vec25 * vec21[4] ) >> 16
	ErrorToCallFunction(0x04001954);

_04001958:	// 4001958: <c9321c00>	LDV       vec18 <08> = [T1 + 0x00]
	ErrorToCallFunction(0x04001958);

_0400195C:	// 400195c: <4b1efe0e>	VMADN     vec24 = ( acc+= vec31 * vec30[0] )
	ErrorToCallFunction(0x0400195C);

_04001960:	// 4001960: <ca911800>	LDV       vec17 <00> = [S4 + 0x00]
	ErrorToCallFunction(0x04001960);

_04001964:	// 4001964: <4b55fd86>	VMUDN     vec22 = ( acc = vec31 * vec21[2]      ) >> 16
	ErrorToCallFunction(0x04001964);

_04001968:	// 4001968: <c9901800>	LDV       vec16 <00> = [T4 + 0x00]
	ErrorToCallFunction(0x04001968);

_0400196C:	// 400196c: <ca111c00>	LDV       vec17 <08> = [S0 + 0x00]
	ErrorToCallFunction(0x0400196C);

_04001970:	// 4001970: <4b5ebd8e>	VMADN     vec22 = ( acc+= vec23 * vec30[2] )
	ErrorToCallFunction(0x04001970);

_04001974:	// 4001974: <c9101c00>	LDV       vec16 <08> = [T0 + 0x00]
	ErrorToCallFunction(0x04001974);

_04001978:	// 4001978: <4bb5c504>	VMUDL     vec20 = ( acc = (vec24 * vec21[5] >> 16)      )
	ErrorToCallFunction(0x04001978);

_0400197C:	// 400197c: <ca6f1800>	LDV       vec15 <00> = [S3 + 0x00]
	ErrorToCallFunction(0x0400197C);

_04001980:	// 4001980: <c96e1800>	LDV       vec14 <00> = [T3 + 0x00]
	ErrorToCallFunction(0x04001980);

_04001984:	// 4001984: <c9ef1c00>	LDV       vec15 <08> = [T7 + 0x00]
	ErrorToCallFunction(0x04001984);

_04001988:	// 4001988: <c8ee1c00>	LDV       vec14 <08> = [A3 + 0x00]
	ErrorToCallFunction(0x04001988);

_0400198C:	// 400198c: <4b9ea506>	VMUDN     vec20 = ( acc = vec20 * vec30[4]      ) >> 16
	ErrorToCallFunction(0x0400198C);

_04001990:	// 4001990: <ca4d1800>	LDV       vec13 <00> = [S2 + 0x00]
	ErrorToCallFunction(0x04001990);

_04001994:	// 4001994: <4b75fd0e>	VMADN     vec20 = ( acc+= vec31 * vec21[3] )
	ErrorToCallFunction(0x04001994);

_04001998:	// 4001998: <c94c1800>	LDV       vec12 <00> = [T2 + 0x00]
	ErrorToCallFunction(0x04001998);

_0400199C:	// 400199c: <c9cd1c00>	LDV       vec13 <08> = [T6 + 0x00]
	ErrorToCallFunction(0x0400199C);

_040019A0:	// 40019a0: <4a129ac0>	VMULF     vec11 = ( acc = (vec19 * vec18[<none>]) << 1 ) >> 16
	ErrorToCallFunction(0x040019A0);

_040019A4:	// 40019a4: <c8cc1c00>	LDV       vec12 <08> = [A2 + 0x00]
	ErrorToCallFunction(0x040019A4);

_040019A8:	// 40019a8: <4a108a80>	VMULF     vec10 = ( acc = (vec17 * vec16[<none>]) << 1 ) >> 16
	ErrorToCallFunction(0x040019A8);

_040019AC:	// 40019ac: <e816207b>	SQV       [R0 + 0xb0] = vec22 <00>
	ErrorToCallFunction(0x040019AC);

_040019B0:	// 40019b0: <4a0e7a40>	VMULF     vec09 = ( acc = (vec15 * vec14[<none>]) << 1 ) >> 16
	ErrorToCallFunction(0x040019B0);

_040019B4:	// 40019b4: <e814207c>	SQV       [R0 + 0xc0] = vec20 <00>
	ErrorToCallFunction(0x040019B4);

_040019B8:	// 40019b8: <84150fb0>	LH        S5 = [R0+0fb0]
	ErrorToCallFunction(0x040019B8);

_040019BC:	// 40019bc: <840d0fc0>	LH        T5 = [R0+0fc0]
	ErrorToCallFunction(0x040019BC);

_040019C0:	// 40019c0: <4a0c6a00>	VMULF     vec08 = ( acc = (vec13 * vec12[<none>]) << 1 ) >> 16
	ErrorToCallFunction(0x040019C0);

_040019C4:	// 40019c4: <84110fb8>	LH        S1 = [R0+0fb8]
	ErrorToCallFunction(0x040019C4);

_040019C8:	// 40019c8: <4a6b5ad0>	VADD      vec11 = vec11 + vec11[1q]
	ErrorToCallFunction(0x040019C8);

_040019CC:	// 40019cc: <84090fc8>	LH        T1 = [R0+0fc8]
	ErrorToCallFunction(0x040019CC);

_040019D0:	// 40019d0: <4a6a5290>	VADD      vec10 = vec10 + vec10[1q]
	ErrorToCallFunction(0x040019D0);

_040019D4:	// 40019d4: <84140fb2>	LH        S4 = [R0+0fb2]
	ErrorToCallFunction(0x040019D4);

_040019D8:	// 40019d8: <4a694a50>	VADD      vec09 = vec09 + vec09[1q]
	ErrorToCallFunction(0x040019D8);

_040019DC:	// 40019dc: <840c0fc2>	LH        T4 = [R0+0fc2]
	ErrorToCallFunction(0x040019DC);

_040019E0:	// 40019e0: <4a684210>	VADD      vec08 = vec08 + vec08[1q]
	ErrorToCallFunction(0x040019E0);

_040019E4:	// 40019e4: <84100fba>	LH        S0 = [R0+0fba]
	ErrorToCallFunction(0x040019E4);

_040019E8:	// 40019e8: <4acb5ad0>	VADD      vec11 = vec11 + vec11[2h]
	ErrorToCallFunction(0x040019E8);

_040019EC:	// 40019ec: <84080fca>	LH        T0 = [R0+0fca]
	ErrorToCallFunction(0x040019EC);

_040019F0:	// 40019f0: <4aca5290>	VADD      vec10 = vec10 + vec10[2h]
	ErrorToCallFunction(0x040019F0);

_040019F4:	// 40019f4: <84130fb4>	LH        S3 = [R0+0fb4]
	ErrorToCallFunction(0x040019F4);

_040019F8:	// 40019f8: <4ac94a50>	VADD      vec09 = vec09 + vec09[2h]
	ErrorToCallFunction(0x040019F8);

_040019FC:	// 40019fc: <840b0fc4>	LH        T3 = [R0+0fc4]
	ErrorToCallFunction(0x040019FC);

_04001A00:	// 4001a00: <4ac84210>	VADD      vec08 = vec08 + vec08[2h]
	ErrorToCallFunction(0x04001A00);

_04001A04:	// 4001a04: <840f0fbc>	LH        T7 = [R0+0fbc]
	ErrorToCallFunction(0x04001A04);

_04001A08:	// 4001a08: <4a8be9c6>	VMUDN     vec07 = ( acc = vec29 * vec11[0h]      ) >> 16
	ErrorToCallFunction(0x04001A08);

_04001A0C:	// 4001a0c: <84070fcc>	LH        A3 = [R0+0fcc]
	ErrorToCallFunction(0x04001A0C);

_04001A10:	// 4001a10: <4a8ae1ce>	VMADN     vec07 = ( acc+= vec28 * vec10[0h] )
	ErrorToCallFunction(0x04001A10);

_04001A14:	// 4001a14: <84120fb6>	LH        S2 = [R0+0fb6]
	ErrorToCallFunction(0x04001A14);

_04001A18:	// 4001a18: <4a89d9ce>	VMADN     vec07 = ( acc+= vec27 * vec09[0h] )
	ErrorToCallFunction(0x04001A18);

_04001A1C:	// 4001a1c: <840a0fc6>	LH        T2 = [R0+0fc6]
	ErrorToCallFunction(0x04001A1C);

_04001A20:	// 4001a20: <4a88d1ce>	VMADN     vec07 = ( acc+= vec26 * vec08[0h] )
	ErrorToCallFunction(0x04001A20);

_04001A24:	// 4001a24: <840e0fbe>	LH        T6 = [R0+0fbe]
	ErrorToCallFunction(0x04001A24);

_04001A28:	// 4001a28: <84060fce>	LH        A2 = [R0+0fce]
	ErrorToCallFunction(0x04001A28);

_04001A2C:	// 4001a2c: <22d6fff0>	ADDI      S6 = S6 + fff0
	ErrorToCallFunction(0x04001A2C);

_04001A30:	// 4001a30: <1ac00003>	BLEZ      (R0<=0) --> 1a40
	sp_reg_pc = 0x04001A30;
	if ((_s32)state.r[S6] <= 0)
	{
		{
			_u32    addr = (0x00000000 + state.r[S7]);
			int     shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				*(_u32 *)&pDMEM[addr+12] = state.v[7].U32[0];
				*(_u32 *)&pDMEM[addr+8 ] = state.v[7].U32[1];
				*(_u32 *)&pDMEM[addr+4 ] = state.v[7].U32[2];
				*(_u32 *)&pDMEM[addr   ] = state.v[7].U32[3];
			}
			else
			{
				_u64    value1 = Load64_DMEM(addr+8);
				_u64    value2 = Load64_DMEM(addr);
				_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & ~temp1;
				value2 = value2 & ~temp2;

				value1 |= (state.v[7].U64[0] & temp1);
				value2 |= (state.v[7].U64[1] & temp2);

				Save64_DMEM(value1, addr+8);
				Save64_DMEM(value2, addr  );
			}
		}
		goto _04001A40;
	}


_04001A34:	// 4001a34: <eae72000>	SQV       [S7 + 0x00] = vec07 <00>
	{
		_u32    addr = (0x00000000 + state.r[S7]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[7].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[7].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[7].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[7].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[7].U64[0] & temp1);
			value2 |= (state.v[7].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001A38:	// 4001a38: <09000650>	J         04001940
	state.r[S7] = state.r[S7] + 0x0010;
	goto _04001940;


_04001A3C:	// 4001a3c: <22f70010>	ADDI      S7 = S7 + 0010
	state.r[S7] = state.r[S7] + 0x0010;


_04001A40:	// 4001a40: <cab31800>	LDV       vec19 <00> = [S5 + 0x00]
	rsp_ldv_compiler((state.r[S5] & 0xFFF), 19, 8);


_04001A44:	// 4001a44: <eb180804>	SSV       [T8 + 0x08] = vec24 <00>
	Save16_DMEM(state.v[24].U16[7], (0x00000008 + state.r[T8]) & 0xfff);


_04001A48:	// 4001a48: <0d00045e>	JAL	    04001178
	{
		_u32	addr = (0x00000000 + state.r[T8]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[19].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[19].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[19].U32[0x00000003];
		}
	}
	sp_reg_pc = 0x04001A48;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001178;


_04001A4C:	// 4001a4c: <eb131800>	SDV       [T8 + 0x00] = vec19 <00>
	{
		_u32	addr = (0x00000000 + state.r[T8]);

		if( addr & 3 )
		{
			Save64_DMEM(state.v[19].U64[0x00000001], addr);
		}
		else
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+4] = state.v[19].U32[0x00000002];
			*(_u32 *)&pDMEM[addr  ] = state.v[19].U32[0x00000003];
		}
	}


_04001A50:	// 4001a50: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_04001A54:	// 4001a54: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001A58:	// 4001a58: <14a0ffff>	BNE       (R0!=A1) --> 1a58
	sp_reg_pc = 0x04001A58;
	if (state.r[A1] != 0)
	{
		state.r[A1] = 0;
		goto _04001A58;
	}


_04001A5C:	// 4001a5c: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001A60:	// 4001a60: <0900043c>	J         040010f0
	goto _040010F0;


_04001A64:	// 4001a64: <40803800>	MTC0      SP semaphore = R0


_04001A68:	// 4001a68: <00191200>	SLL       V0 = T9 << 8
	state.r[V0] = ((_u32)state.r[T9] << 8);


_04001A6C:	// 4001a6c: <00021202>	SRL       V0 = V0 >> 8
	state.r[V0] = ((_u32)state.r[V0] >> 8);


_04001A70:	// 4001a70: <20420000>	ADDI      V0 = V0 + 0000
	state.r[V0] = state.r[V0] + 0x0000;


_04001A74:	// 4001a74: <c81f2004>	LQV       vec31 <00> = [R0 + 0x40]
	{
		_u32 addr = (0x00000040 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[31].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[31].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[31].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[31].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[31].U64[0] = state.v[31].U64[0] & ~temp1;
			state.v[31].U64[1] = state.v[31].U64[1] & ~temp2;
			state.v[31].U64[0] = state.v[31].U64[0] | value1;
			state.v[31].U64[1] = state.v[31].U64[1] | value2;
		}
	}


_04001A78:	// 4001a78: <c80a2005>	LQV       vec10 <00> = [R0 + 0x50]
	{
		_u32 addr = (0x00000050 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[10].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[10].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[10].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[10].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[10].U64[0] = state.v[10].U64[0] & ~temp1;
			state.v[10].U64[1] = state.v[10].U64[1] & ~temp2;
			state.v[10].U64[0] = state.v[10].U64[0] | value1;
			state.v[10].U64[1] = state.v[10].U64[1] | value2;
		}
	}


_04001A7C:	// 4001a7c: <c81e200a>	LQV       vec30 <00> = [R0 + 0xa0]
	{
		_u32 addr = (0x000000A0 + 0);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[30].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[30].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[30].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[30].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[30].U64[0] = state.v[30].U64[0] & ~temp1;
			state.v[30].U64[1] = state.v[30].U64[1] & ~temp2;
			state.v[30].U64[0] = state.v[30].U64[0] | value1;
			state.v[30].U64[1] = state.v[30].U64[1] | value2;
		}
	}


_04001A80:	// 4001a80: <4a00002c>	VXOR      vec00 = vec00 xor vec00[<none>]
	rsp_cop2_vxor(&state.v[0], &state.v[0], &state.v[0]);


_04001A84:	// 4001a84: <001a7402>	SRL       T6 = K0 >> 16
	state.r[T6] = ((_u32)state.r[K0] >> 16);


_04001A88:	// 4001a88: <31cf0001>	ANDI      T7 = T6 & 0001
	state.r[T7] = (state.r[T6] & 0x00000001);


_04001A8C:	// 4001a8c: <1de0000b>	BGTZ      (R0>0) --> 1abc
	sp_reg_pc = 0x04001A8C;
	if((_s32)state.r[T7] > 0)
	{
		state.r[AT] = state.r[T8] + 0x0000;
		goto _04001ABC;
	}


_04001A90:	// 4001a90: <23010000>	ADDI      AT = T8 + 0000
	state.r[AT] = state.r[T8] + 0x0000;


_04001A94:	// 4001a94: <0d000454>	JAL	    04001150
	state.r[V1] = 0 + 0x004F;
	sp_reg_pc = 0x04001A94;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001150;


_04001A98:	// 4001a98: <2003004f>	ADDI      V1 = R0 + 004f
	state.r[V1] = 0 + 0x004F;


_04001A9C:	// 4001a9c: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001AA0:	// 4001aa0: <14a0ffff>	BNE       (R0!=A1) --> 1aa0
	sp_reg_pc = 0x04001AA0;
	if (state.r[A1] != 0)
	{
		state.r[A1] = 0;
		goto _04001AA0;
	}


_04001AA4:	// 4001aa4: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001AA8:	// 4001aa8: <40803800>	MTC0      SP semaphore = R0


_04001AAC:	// 4001aac: <cb142000>	LQV       vec20 <00> = [T8 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[T8]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[20].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[20].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[20].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[20].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[20].U64[0] = state.v[20].U64[0] & ~temp1;
			state.v[20].U64[1] = state.v[20].U64[1] & ~temp2;
			state.v[20].U64[0] = state.v[20].U64[0] | value1;
			state.v[20].U64[1] = state.v[20].U64[1] | value2;
		}
	}


_04001AB0:	// 4001ab0: <cb152001>	LQV       vec21 <00> = [T8 + 0x10]
	{
		_u32 addr = (0x00000010 + state.r[T8]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[21].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[21].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[21].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[21].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[21].U64[0] = state.v[21].U64[0] & ~temp1;
			state.v[21].U64[1] = state.v[21].U64[1] & ~temp2;
			state.v[21].U64[0] = state.v[21].U64[0] | value1;
			state.v[21].U64[1] = state.v[21].U64[1] | value2;
		}
	}


_04001AB4:	// 4001ab4: <cb122002>	LQV       vec18 <00> = [T8 + 0x20]
	{
		_u32 addr = (0x00000020 + state.r[T8]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[18].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[18].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[18].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[18].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[18].U64[0] = state.v[18].U64[0] & ~temp1;
			state.v[18].U64[1] = state.v[18].U64[1] & ~temp2;
			state.v[18].U64[0] = state.v[18].U64[0] | value1;
			state.v[18].U64[1] = state.v[18].U64[1] | value2;
		}
	}


_04001AB8:	// 4001ab8: <cb132003>	LQV       vec19 <00> = [T8 + 0x30]
	{
		_u32 addr = (0x00000030 + state.r[T8]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[19].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[19].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[19].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[19].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[19].U64[0] = state.v[19].U64[0] & ~temp1;
			state.v[19].U64[1] = state.v[19].U64[1] & ~temp2;
			state.v[19].U64[0] = state.v[19].U64[0] | value1;
			state.v[19].U64[1] = state.v[19].U64[1] | value2;
		}
	}


_04001ABC:	// 4001abc: <cb182004>	LQV       vec24 <00> = [T8 + 0x40]
	{
		_u32 addr = (0x00000040 + state.r[T8]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[24].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[24].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[24].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[24].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[24].U64[0] = state.v[24].U64[0] & ~temp1;
			state.v[24].U64[1] = state.v[24].U64[1] & ~temp2;
			state.v[24].U64[0] = state.v[24].U64[0] | value1;
			state.v[24].U64[1] = state.v[24].U64[1] | value2;
		}
	}


_04001AC0:	// 4001ac0: <201004f0>	ADDI      S0 = R0 + 04f0
	state.r[S0] = 0 + 0x04F0;


_04001AC4:	// 4001ac4: <201509d0>	ADDI      S5 = R0 + 09d0
	state.r[S5] = 0 + 0x09D0;


_04001AC8:	// 4001ac8: <20140b40>	ADDI      S4 = R0 + 0b40
	state.r[S4] = 0 + 0x0B40;


_04001ACC:	// 4001acc: <20130cb0>	ADDI      S3 = R0 + 0cb0
	state.r[S3] = 0 + 0x0CB0;


_04001AD0:	// 4001ad0: <20120e20>	ADDI      S2 = R0 + 0e20
	state.r[S2] = 0 + 0x0E20;


_04001AD4:	// 4001ad4: <20110170>	ADDI      S1 = R0 + 0170
	state.r[S1] = 0 + 0x0170;


_04001AD8:	// 4001ad8: <4816c400>	MFC2      S6 = vec24 <08>
	state.r[S6] = (_s32)state.v[24].S16[3];


_04001ADC:	// 4001adc: <11e00033>	BEQ       (R0==T7) --> 1bac
	sp_reg_pc = 0x04001ADC;
	if (state.r[T7] == 0)
	{
		state.r[S7] = (_s32)state.v[24].S16[6];
		goto _04001BAC;
	}


_04001AE0:	// 4001ae0: <4817c100>	MFC2      S7 = vec24 <02>
	state.r[S7] = (_s32)state.v[24].S16[6];


_04001AE4:	// 4001ae4: <2003004f>	ADDI      V1 = R0 + 004f
	state.r[V1] = 0 + 0x004F;


_04001AE8:	// 4001ae8: <4a14a52c>	VXOR      vec20 = vec20 xor vec20[<none>]
	rsp_cop2_vxor(&state.v[20], &state.v[20], &state.v[20]);


_04001AEC:	// 4001aec: <cb140f28>	LSV       vec20 <14> = [T8 + 0x10]
	state.v[20].U16[0] = Load16_DMEM(0x00000050 + state.r[T8]);


_04001AF0:	// 4001af0: <4a15ad6c>	VXOR      vec21 = vec21 xor vec21[<none>]
	rsp_cop2_vxor(&state.v[21], &state.v[21], &state.v[21]);


_04001AF4:	// 4001af4: <ca112000>	LQV       vec17 <00> = [S0 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S0]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[17].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[17].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[17].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[17].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[17].U64[0] = state.v[17].U64[0] & ~temp1;
			state.v[17].U64[1] = state.v[17].U64[1] & ~temp2;
			state.v[17].U64[0] = state.v[17].U64[0] | value1;
			state.v[17].U64[1] = state.v[17].U64[1] | value2;
		}
	}


_04001AF8:	// 4001af8: <4a1294ac>	VXOR      vec18 = vec18 xor vec18[<none>]
	rsp_cop2_vxor(&state.v[18], &state.v[18], &state.v[18]);


_04001AFC:	// 4001afc: <489a9700>	MTC2      vec18 <14> = K0
	state.v[18].U16[0] = (_u16)state.r[K0];


_04001B00:	// 4001b00: <4b58f5c4>	VMUDL     vec23 = ( acc = (vec30 * vec24[2] >> 16)      )
	{
		_u16		s2value = state.v[24].U16[5];
		VMUDL_operation(0, state.v[23].U16[0], state.v[30].U16[0], s2value, 0, 1, 1, 1)
		VMUDL_operation(1, state.v[23].U16[1], state.v[30].U16[1], s2value, 0, 1, 1, 1)
		VMUDL_operation(2, state.v[23].U16[2], state.v[30].U16[2], s2value, 0, 1, 1, 1)
		VMUDL_operation(3, state.v[23].U16[3], state.v[30].U16[3], s2value, 0, 1, 1, 1)
		VMUDL_operation(4, state.v[23].U16[4], state.v[30].U16[4], s2value, 0, 1, 1, 1)
		VMUDL_operation(5, state.v[23].U16[5], state.v[30].U16[5], s2value, 0, 1, 1, 1)
		VMUDL_operation(6, state.v[23].U16[6], state.v[30].U16[6], s2value, 0, 1, 1, 1)
		VMUDL_operation(7, state.v[23].U16[7], state.v[30].U16[7], s2value, 0, 1, 1, 1)
	}


_04001B04:	// 4001b04: <cabd2000>	LQV       vec29 <00> = [S5 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S5]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[29].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[29].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[29].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[29].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[29].U64[0] = state.v[29].U64[0] & ~temp1;
			state.v[29].U64[1] = state.v[29].U64[1] & ~temp2;
			state.v[29].U64[0] = state.v[29].U64[0] | value1;
			state.v[29].U64[1] = state.v[29].U64[1] | value2;
		}
	}


_04001B08:	// 4001b08: <4b38f5ce>	VMADN     vec23 = ( acc+= vec30 * vec24[1] )
	{
		_u16		s2value = state.v[24].U16[6];
		VMADN_operation(0, state.v[23].U16[0], state.v[30].U16[0], s2value, 1, 1, 1, 1)
		VMADN_operation(1, state.v[23].U16[1], state.v[30].U16[1], s2value, 1, 1, 1, 1)
		VMADN_operation(2, state.v[23].U16[2], state.v[30].U16[2], s2value, 1, 1, 1, 1)
		VMADN_operation(3, state.v[23].U16[3], state.v[30].U16[3], s2value, 1, 1, 1, 1)
		VMADN_operation(4, state.v[23].U16[4], state.v[30].U16[4], s2value, 1, 1, 1, 1)
		VMADN_operation(5, state.v[23].U16[5], state.v[30].U16[5], s2value, 1, 1, 1, 1)
		VMADN_operation(6, state.v[23].U16[6], state.v[30].U16[6], s2value, 1, 1, 1, 1)
		VMADN_operation(7, state.v[23].U16[7], state.v[30].U16[7], s2value, 1, 1, 1, 1)
	}


_04001B0C:	// 4001b0c: <ca7b2000>	LQV       vec27 <00> = [S3 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S3]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
			state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
			state.v[27].U64[0] = state.v[27].U64[0] | value1;
			state.v[27].U64[1] = state.v[27].U64[1] | value2;
		}
	}


_04001B10:	// 4001b10: <4bf4fd0f>	VMADH     vec20 = ( acc+= (vec31 * vec20[7]) << 16) >> 16
	{
		_u16		s2value = state.v[20].U16[0];
		VMADH_operation(0, state.v[20].U16[0], state.v[31].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[20].U16[1], state.v[31].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[20].U16[2], state.v[31].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[20].U16[3], state.v[31].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[20].U16[4], state.v[31].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[20].U16[5], state.v[31].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[20].U16[6], state.v[31].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[20].U16[7], state.v[31].U16[7], s2value, 1, 1, 0, 1)
	}


_04001B14:	// 4001b14: <ca9c2000>	LQV       vec28 <00> = [S4 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S4]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[28].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[28].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[28].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[28].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[28].U64[0] = state.v[28].U64[0] & ~temp1;
			state.v[28].U64[1] = state.v[28].U64[1] & ~temp2;
			state.v[28].U64[0] = state.v[28].U64[0] | value1;
			state.v[28].U64[1] = state.v[28].U64[1] | value2;
		}
	}


_04001B18:	// 4001b18: <4b00fd4e>	VMADN     vec21 = ( acc+= vec31 * vec00[0] )
	{
		_u16		s2value = state.v[0].U16[7];
		VMADN_operation(0, state.v[21].U16[0], state.v[31].U16[0], s2value, 1, 1, 1, 1)
		VMADN_operation(1, state.v[21].U16[1], state.v[31].U16[1], s2value, 1, 1, 1, 1)
		VMADN_operation(2, state.v[21].U16[2], state.v[31].U16[2], s2value, 1, 1, 1, 1)
		VMADN_operation(3, state.v[21].U16[3], state.v[31].U16[3], s2value, 1, 1, 1, 1)
		VMADN_operation(4, state.v[21].U16[4], state.v[31].U16[4], s2value, 1, 1, 1, 1)
		VMADN_operation(5, state.v[21].U16[5], state.v[31].U16[5], s2value, 1, 1, 1, 1)
		VMADN_operation(6, state.v[21].U16[6], state.v[31].U16[6], s2value, 1, 1, 1, 1)
		VMADN_operation(7, state.v[21].U16[7], state.v[31].U16[7], s2value, 1, 1, 1, 1)
	}


_04001B1C:	// 4001b1c: <06e10003>	BGEZ ?-?
	sp_reg_pc = 0x04001B1C;
	if (state.r[S7] >= 0)
	{
		rsp_cop2_vxor(&state.v[19], &state.v[19], &state.v[19]);
		goto _04001B2C;
	}


_04001B20:	// 4001b20: <4a139cec>	VXOR      vec19 = vec19 xor vec19[<none>]
	rsp_cop2_vxor(&state.v[19], &state.v[19], &state.v[19]);


_04001B24:	// 4001b24: <090006cc>	J         04001b30
	rsp_cop2_vge_element(&state.v[20], &state.v[20], &state.v[24].U16[7]);
	goto _04001B30;


_04001B28:	// 4001b28: <4b18a523>	VGE       vec20 = (vec20 >= vec24[0])
	rsp_cop2_vge_element(&state.v[20], &state.v[20], &state.v[24].U16[7]);


_04001B2C:	// 4001b2c: <4b18a520>	VLT ?-?
	rsp_cop2_vlt_element(&state.v[20], &state.v[20], &state.v[24].U16[7]);


_04001B30:	// 4001b30: <4bb8f5c4>	VMUDL     vec23 = ( acc = (vec30 * vec24[5] >> 16)      )
	{
		_u16		s2value = state.v[24].U16[2];
		VMUDL_operation(0, state.v[23].U16[0], state.v[30].U16[0], s2value, 0, 1, 1, 1)
		VMUDL_operation(1, state.v[23].U16[1], state.v[30].U16[1], s2value, 0, 1, 1, 1)
		VMUDL_operation(2, state.v[23].U16[2], state.v[30].U16[2], s2value, 0, 1, 1, 1)
		VMUDL_operation(3, state.v[23].U16[3], state.v[30].U16[3], s2value, 0, 1, 1, 1)
		VMUDL_operation(4, state.v[23].U16[4], state.v[30].U16[4], s2value, 0, 1, 1, 1)
		VMUDL_operation(5, state.v[23].U16[5], state.v[30].U16[5], s2value, 0, 1, 1, 1)
		VMUDL_operation(6, state.v[23].U16[6], state.v[30].U16[6], s2value, 0, 1, 1, 1)
		VMUDL_operation(7, state.v[23].U16[7], state.v[30].U16[7], s2value, 0, 1, 1, 1)
	}


_04001B34:	// 4001b34: <ca5a2000>	LQV       vec26 <00> = [S2 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S2]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[26].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[26].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[26].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[26].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[26].U64[0] = state.v[26].U64[0] & ~temp1;
			state.v[26].U64[1] = state.v[26].U64[1] & ~temp2;
			state.v[26].U64[0] = state.v[26].U64[0] | value1;
			state.v[26].U64[1] = state.v[26].U64[1] | value2;
		}
	}


_04001B38:	// 4001b38: <4b98f5ce>	VMADN     vec23 = ( acc+= vec30 * vec24[4] )
	{
		_u16		s2value = state.v[24].U16[3];
		VMADN_operation(0, state.v[23].U16[0], state.v[30].U16[0], s2value, 1, 1, 1, 1)
		VMADN_operation(1, state.v[23].U16[1], state.v[30].U16[1], s2value, 1, 1, 1, 1)
		VMADN_operation(2, state.v[23].U16[2], state.v[30].U16[2], s2value, 1, 1, 1, 1)
		VMADN_operation(3, state.v[23].U16[3], state.v[30].U16[3], s2value, 1, 1, 1, 1)
		VMADN_operation(4, state.v[23].U16[4], state.v[30].U16[4], s2value, 1, 1, 1, 1)
		VMADN_operation(5, state.v[23].U16[5], state.v[30].U16[5], s2value, 1, 1, 1, 1)
		VMADN_operation(6, state.v[23].U16[6], state.v[30].U16[6], s2value, 1, 1, 1, 1)
		VMADN_operation(7, state.v[23].U16[7], state.v[30].U16[7], s2value, 1, 1, 1, 1)
	}


_04001B3C:	// 4001b3c: <2231fff0>	ADDI      S1 = S1 + fff0
	state.r[S1] = state.r[S1] + 0xFFFFFFF0;


_04001B40:	// 4001b40: <4bf2fc8f>	VMADH     vec18 = ( acc+= (vec31 * vec18[7]) << 16) >> 16
	{
		_u16		s2value = state.v[18].U16[0];
		VMADH_operation(0, state.v[18].U16[0], state.v[31].U16[0], s2value, 1, 1, 0, 1)
		VMADH_operation(1, state.v[18].U16[1], state.v[31].U16[1], s2value, 1, 1, 0, 1)
		VMADH_operation(2, state.v[18].U16[2], state.v[31].U16[2], s2value, 1, 1, 0, 1)
		VMADH_operation(3, state.v[18].U16[3], state.v[31].U16[3], s2value, 1, 1, 0, 1)
		VMADH_operation(4, state.v[18].U16[4], state.v[31].U16[4], s2value, 1, 1, 0, 1)
		VMADH_operation(5, state.v[18].U16[5], state.v[31].U16[5], s2value, 1, 1, 0, 1)
		VMADH_operation(6, state.v[18].U16[6], state.v[31].U16[6], s2value, 1, 1, 0, 1)
		VMADH_operation(7, state.v[18].U16[7], state.v[31].U16[7], s2value, 1, 1, 0, 1)
	}


_04001B44:	// 4001b44: <22100010>	ADDI      S0 = S0 + 0010
	state.r[S0] = state.r[S0] + 0x0010;


_04001B48:	// 4001b48: <4b00fcce>	VMADN     vec19 = ( acc+= vec31 * vec00[0] )
	{
		_u16		s2value = state.v[0].U16[7];
		VMADN_operation(0, state.v[19].U16[0], state.v[31].U16[0], s2value, 1, 0, 0, 1)
		VMADN_operation(1, state.v[19].U16[1], state.v[31].U16[1], s2value, 1, 0, 0, 1)
		VMADN_operation(2, state.v[19].U16[2], state.v[31].U16[2], s2value, 1, 0, 0, 1)
		VMADN_operation(3, state.v[19].U16[3], state.v[31].U16[3], s2value, 1, 0, 0, 1)
		VMADN_operation(4, state.v[19].U16[4], state.v[31].U16[4], s2value, 1, 0, 0, 1)
		VMADN_operation(5, state.v[19].U16[5], state.v[31].U16[5], s2value, 1, 0, 0, 1)
		VMADN_operation(6, state.v[19].U16[6], state.v[31].U16[6], s2value, 1, 0, 0, 1)
		VMADN_operation(7, state.v[19].U16[7], state.v[31].U16[7], s2value, 1, 0, 0, 1)
	}


_04001B4C:	// 4001b4c: <4bd8a400>	VMULF     vec16 = ( acc = (vec20 * vec24[6]) << 1 ) >> 16
	{
		_u16		s2value = state.v[24].U16[1];
		VMULF_operation(0, state.v[16].U16[0], state.v[20].U16[0], s2value, 1, 1, 1, 1)
		VMULF_operation(1, state.v[16].U16[1], state.v[20].U16[1], s2value, 1, 1, 1, 1)
		VMULF_operation(2, state.v[16].U16[2], state.v[20].U16[2], s2value, 1, 1, 1, 1)
		VMULF_operation(3, state.v[16].U16[3], state.v[20].U16[3], s2value, 1, 1, 1, 1)
		VMULF_operation(4, state.v[16].U16[4], state.v[20].U16[4], s2value, 1, 1, 1, 1)
		VMULF_operation(5, state.v[16].U16[5], state.v[20].U16[5], s2value, 1, 1, 1, 1)
		VMULF_operation(6, state.v[16].U16[6], state.v[20].U16[6], s2value, 1, 1, 1, 1)
		VMULF_operation(7, state.v[16].U16[7], state.v[20].U16[7], s2value, 1, 1, 1, 1)
	}


_04001B50:	// 4001b50: <06c10003>	BGEZ ?-?
	sp_reg_pc = 0x04001B50;
	if (state.r[S6] >= 0)
	{
		{
			_u16		s2value = state.v[24].U16[0];
			VMULF_operation(0, state.v[15].U16[0], state.v[20].U16[0], s2value, 1, 1, 1, 1)
			VMULF_operation(1, state.v[15].U16[1], state.v[20].U16[1], s2value, 1, 1, 1, 1)
			VMULF_operation(2, state.v[15].U16[2], state.v[20].U16[2], s2value, 1, 1, 1, 1)
			VMULF_operation(3, state.v[15].U16[3], state.v[20].U16[3], s2value, 1, 1, 1, 1)
			VMULF_operation(4, state.v[15].U16[4], state.v[20].U16[4], s2value, 1, 1, 1, 1)
			VMULF_operation(5, state.v[15].U16[5], state.v[20].U16[5], s2value, 1, 1, 1, 1)
			VMULF_operation(6, state.v[15].U16[6], state.v[20].U16[6], s2value, 1, 1, 1, 1)
			VMULF_operation(7, state.v[15].U16[7], state.v[20].U16[7], s2value, 1, 1, 1, 1)
		}
		goto _04001B60;
	}


_04001B54:	// 4001b54: <4bf8a3c0>	VMULF     vec15 = ( acc = (vec20 * vec24[7]) << 1 ) >> 16
	{
		_u16		s2value = state.v[24].U16[0];
		VMULF_operation(0, state.v[15].U16[0], state.v[20].U16[0], s2value, 1, 1, 1, 1)
		VMULF_operation(1, state.v[15].U16[1], state.v[20].U16[1], s2value, 1, 1, 1, 1)
		VMULF_operation(2, state.v[15].U16[2], state.v[20].U16[2], s2value, 1, 1, 1, 1)
		VMULF_operation(3, state.v[15].U16[3], state.v[20].U16[3], s2value, 1, 1, 1, 1)
		VMULF_operation(4, state.v[15].U16[4], state.v[20].U16[4], s2value, 1, 1, 1, 1)
		VMULF_operation(5, state.v[15].U16[5], state.v[20].U16[5], s2value, 1, 1, 1, 1)
		VMULF_operation(6, state.v[15].U16[6], state.v[20].U16[6], s2value, 1, 1, 1, 1)
		VMULF_operation(7, state.v[15].U16[7], state.v[20].U16[7], s2value, 1, 1, 1, 1)
	}


_04001B58:	// 4001b58: <090006d9>	J         04001b64
	rsp_cop2_vge_element(&state.v[18], &state.v[18], &state.v[24].U16[4]);
	goto _04001B64;


_04001B5C:	// 4001b5c: <4b7894a3>	VGE       vec18 = (vec18 >= vec24[3])
	rsp_cop2_vge_element(&state.v[18], &state.v[18], &state.v[24].U16[4]);


_04001B60:	// 4001b60: <4b7894a0>	VLT ?-?
	rsp_cop2_vlt_element(&state.v[18], &state.v[18], &state.v[24].U16[4]);


_04001B64:	// 4001b64: <4baaef40>	VMULF     vec29 = ( acc = (vec29 * vec10[5]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[2];
		VMULF_operation(0, state.v[29].U16[0], state.v[29].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[29].U16[1], state.v[29].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[29].U16[2], state.v[29].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[29].U16[3], state.v[29].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[29].U16[4], state.v[29].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[29].U16[5], state.v[29].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[29].U16[6], state.v[29].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[29].U16[7], state.v[29].U16[7], s2value, 0, 1, 1, 1)
	}


_04001B68:	// 4001b68: <4a108f48>	VMACF     vec29 = ( acc += (vec17 * vec16[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[29].U16[0], state.v[17].U16[0], state.v[16].U16[0], 1, 0, 0, 1)
		VMACF_operation(1, state.v[29].U16[1], state.v[17].U16[1], state.v[16].U16[1], 1, 0, 0, 1)
		VMACF_operation(2, state.v[29].U16[2], state.v[17].U16[2], state.v[16].U16[2], 1, 0, 0, 1)
		VMACF_operation(3, state.v[29].U16[3], state.v[17].U16[3], state.v[16].U16[3], 1, 0, 0, 1)
		VMACF_operation(4, state.v[29].U16[4], state.v[17].U16[4], state.v[16].U16[4], 1, 0, 0, 1)
		VMACF_operation(5, state.v[29].U16[5], state.v[17].U16[5], state.v[16].U16[5], 1, 0, 0, 1)
		VMACF_operation(6, state.v[29].U16[6], state.v[17].U16[6], state.v[16].U16[6], 1, 0, 0, 1)
		VMACF_operation(7, state.v[29].U16[7], state.v[17].U16[7], state.v[16].U16[7], 1, 0, 0, 1)
	}


_04001B6C:	// 4001b6c: <4baadec0>	VMULF     vec27 = ( acc = (vec27 * vec10[5]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[2];
		VMULF_operation(0, state.v[27].U16[0], state.v[27].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[27].U16[1], state.v[27].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[27].U16[2], state.v[27].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[27].U16[3], state.v[27].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[27].U16[4], state.v[27].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[27].U16[5], state.v[27].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[27].U16[6], state.v[27].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[27].U16[7], state.v[27].U16[7], s2value, 0, 1, 1, 1)
	}


_04001B70:	// 4001b70: <4a0f8ec8>	VMACF     vec27 = ( acc += (vec17 * vec15[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[27].U16[0], state.v[17].U16[0], state.v[15].U16[0], 1, 0, 0, 1)
		VMACF_operation(1, state.v[27].U16[1], state.v[17].U16[1], state.v[15].U16[1], 1, 0, 0, 1)
		VMACF_operation(2, state.v[27].U16[2], state.v[17].U16[2], state.v[15].U16[2], 1, 0, 0, 1)
		VMACF_operation(3, state.v[27].U16[3], state.v[17].U16[3], state.v[15].U16[3], 1, 0, 0, 1)
		VMACF_operation(4, state.v[27].U16[4], state.v[17].U16[4], state.v[15].U16[4], 1, 0, 0, 1)
		VMACF_operation(5, state.v[27].U16[5], state.v[17].U16[5], state.v[15].U16[5], 1, 0, 0, 1)
		VMACF_operation(6, state.v[27].U16[6], state.v[17].U16[6], state.v[15].U16[6], 1, 0, 0, 1)
		VMACF_operation(7, state.v[27].U16[7], state.v[17].U16[7], state.v[15].U16[7], 1, 0, 0, 1)
	}


_04001B74:	// 4001b74: <4bd89400>	VMULF     vec16 = ( acc = (vec18 * vec24[6]) << 1 ) >> 16
	{
		_u16		s2value = state.v[24].U16[1];
		VMULF_operation(0, state.v[16].U16[0], state.v[18].U16[0], s2value, 1, 0, 0, 1)
		VMULF_operation(1, state.v[16].U16[1], state.v[18].U16[1], s2value, 1, 0, 0, 1)
		VMULF_operation(2, state.v[16].U16[2], state.v[18].U16[2], s2value, 1, 0, 0, 1)
		VMULF_operation(3, state.v[16].U16[3], state.v[18].U16[3], s2value, 1, 0, 0, 1)
		VMULF_operation(4, state.v[16].U16[4], state.v[18].U16[4], s2value, 1, 0, 0, 1)
		VMULF_operation(5, state.v[16].U16[5], state.v[18].U16[5], s2value, 1, 0, 0, 1)
		VMULF_operation(6, state.v[16].U16[6], state.v[18].U16[6], s2value, 1, 0, 0, 1)
		VMULF_operation(7, state.v[16].U16[7], state.v[18].U16[7], s2value, 1, 0, 0, 1)
	}


_04001B78:	// 4001b78: <4bf893c0>	VMULF     vec15 = ( acc = (vec18 * vec24[7]) << 1 ) >> 16
	{
		_u16		s2value = state.v[24].U16[0];
		VMULF_operation(0, state.v[15].U16[0], state.v[18].U16[0], s2value, 1, 0, 0, 1)
		VMULF_operation(1, state.v[15].U16[1], state.v[18].U16[1], s2value, 1, 0, 0, 1)
		VMULF_operation(2, state.v[15].U16[2], state.v[18].U16[2], s2value, 1, 0, 0, 1)
		VMULF_operation(3, state.v[15].U16[3], state.v[18].U16[3], s2value, 1, 0, 0, 1)
		VMULF_operation(4, state.v[15].U16[4], state.v[18].U16[4], s2value, 1, 0, 0, 1)
		VMULF_operation(5, state.v[15].U16[5], state.v[18].U16[5], s2value, 1, 0, 0, 1)
		VMULF_operation(6, state.v[15].U16[6], state.v[18].U16[6], s2value, 1, 0, 0, 1)
		VMULF_operation(7, state.v[15].U16[7], state.v[18].U16[7], s2value, 1, 0, 0, 1)
	}


_04001B7C:	// 4001b7c: <eabd2000>	SQV       [S5 + 0x00] = vec29 <00>
	{
		_u32    addr = (0x00000000 + state.r[S5]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[29].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[29].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[29].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[29].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[29].U64[0] & temp1);
			value2 |= (state.v[29].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001B80:	// 4001b80: <4baae700>	VMULF     vec28 = ( acc = (vec28 * vec10[5]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[2];
		VMULF_operation(0, state.v[28].U16[0], state.v[28].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[28].U16[1], state.v[28].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[28].U16[2], state.v[28].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[28].U16[3], state.v[28].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[28].U16[4], state.v[28].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[28].U16[5], state.v[28].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[28].U16[6], state.v[28].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[28].U16[7], state.v[28].U16[7], s2value, 0, 1, 1, 1)
	}


_04001B84:	// 4001b84: <22b50010>	ADDI      S5 = S5 + 0010
	state.r[S5] = state.r[S5] + 0x0010;


_04001B88:	// 4001b88: <4a108f08>	VMACF     vec28 = ( acc += (vec17 * vec16[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[28].U16[0], state.v[17].U16[0], state.v[16].U16[0], 1, 0, 0, 1)
		VMACF_operation(1, state.v[28].U16[1], state.v[17].U16[1], state.v[16].U16[1], 1, 0, 0, 1)
		VMACF_operation(2, state.v[28].U16[2], state.v[17].U16[2], state.v[16].U16[2], 1, 0, 0, 1)
		VMACF_operation(3, state.v[28].U16[3], state.v[17].U16[3], state.v[16].U16[3], 1, 0, 0, 1)
		VMACF_operation(4, state.v[28].U16[4], state.v[17].U16[4], state.v[16].U16[4], 1, 0, 0, 1)
		VMACF_operation(5, state.v[28].U16[5], state.v[17].U16[5], state.v[16].U16[5], 1, 0, 0, 1)
		VMACF_operation(6, state.v[28].U16[6], state.v[17].U16[6], state.v[16].U16[6], 1, 0, 0, 1)
		VMACF_operation(7, state.v[28].U16[7], state.v[17].U16[7], state.v[16].U16[7], 1, 0, 0, 1)
	}


_04001B8C:	// 4001b8c: <ea7b2000>	SQV       [S3 + 0x00] = vec27 <00>
	{
		_u32    addr = (0x00000000 + state.r[S3]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[27].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[27].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[27].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[27].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[27].U64[0] & temp1);
			value2 |= (state.v[27].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001B90:	// 4001b90: <4baad680>	VMULF     vec26 = ( acc = (vec26 * vec10[5]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[2];
		VMULF_operation(0, state.v[26].U16[0], state.v[26].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[26].U16[1], state.v[26].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[26].U16[2], state.v[26].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[26].U16[3], state.v[26].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[26].U16[4], state.v[26].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[26].U16[5], state.v[26].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[26].U16[6], state.v[26].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[26].U16[7], state.v[26].U16[7], s2value, 0, 1, 1, 1)
	}


_04001B94:	// 4001b94: <22730010>	ADDI      S3 = S3 + 0010
	state.r[S3] = state.r[S3] + 0x0010;


_04001B98:	// 4001b98: <4a0f8e88>	VMACF     vec26 = ( acc += (vec17 * vec15[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[26].U16[0], state.v[17].U16[0], state.v[15].U16[0], 1, 1, 1, 1)
		VMACF_operation(1, state.v[26].U16[1], state.v[17].U16[1], state.v[15].U16[1], 1, 1, 1, 1)
		VMACF_operation(2, state.v[26].U16[2], state.v[17].U16[2], state.v[15].U16[2], 1, 1, 1, 1)
		VMACF_operation(3, state.v[26].U16[3], state.v[17].U16[3], state.v[15].U16[3], 1, 1, 1, 1)
		VMACF_operation(4, state.v[26].U16[4], state.v[17].U16[4], state.v[15].U16[4], 1, 1, 1, 1)
		VMACF_operation(5, state.v[26].U16[5], state.v[17].U16[5], state.v[15].U16[5], 1, 1, 1, 1)
		VMACF_operation(6, state.v[26].U16[6], state.v[17].U16[6], state.v[15].U16[6], 1, 1, 1, 1)
		VMACF_operation(7, state.v[26].U16[7], state.v[17].U16[7], state.v[15].U16[7], 1, 1, 1, 1)
	}


_04001B9C:	// 4001b9c: <ea9c2000>	SQV       [S4 + 0x00] = vec28 <00>
	{
		_u32    addr = (0x00000000 + state.r[S4]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[28].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[28].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[28].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[28].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[28].U64[0] & temp1);
			value2 |= (state.v[28].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001BA0:	// 4001ba0: <22940010>	ADDI      S4 = S4 + 0010
	state.r[S4] = state.r[S4] + 0x0010;


_04001BA4:	// 4001ba4: <ea5a2000>	SQV       [S2 + 0x00] = vec26 <00>
	{
		_u32    addr = (0x00000000 + state.r[S2]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[26].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[26].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[26].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[26].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[26].U64[0] & temp1);
			value2 |= (state.v[26].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001BA8:	// 4001ba8: <22520010>	ADDI      S2 = S2 + 0010
	state.r[S2] = state.r[S2] + 0x0010;


_04001BAC:	// 4001bac: <4b58ad54>	VADDC	vec21 = vec21 + vec24[2]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[24].U16[5];
		VADDC_operation(0, state.v[21].U16[0], state.v[21].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[21].U16[1], state.v[21].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[21].U16[2], state.v[21].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[21].U16[3], state.v[21].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[21].U16[4], state.v[21].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[21].U16[5], state.v[21].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[21].U16[6], state.v[21].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[21].U16[7], state.v[21].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_04001BB0:	// 4001bb0: <4b38a510>	VADD      vec20 = vec20 + vec24[1]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[24].U16[6];
		VADD_operation(0, state.v[20].U16[0], state.v[20].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[20].U16[1], state.v[20].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[20].U16[2], state.v[20].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[20].U16[3], state.v[20].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[20].U16[4], state.v[20].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[20].U16[5], state.v[20].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[20].U16[6], state.v[20].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[20].U16[7], state.v[20].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001BB4:	// 4001bb4: <cabd2000>	LQV       vec29 <00> = [S5 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S5]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[29].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[29].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[29].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[29].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[29].U64[0] = state.v[29].U64[0] & ~temp1;
			state.v[29].U64[1] = state.v[29].U64[1] & ~temp2;
			state.v[29].U64[0] = state.v[29].U64[0] | value1;
			state.v[29].U64[1] = state.v[29].U64[1] | value2;
		}
	}


_04001BB8:	// 4001bb8: <4bb89cd4>	VADDC	vec19 = vec19 + vec24[5]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[24].U16[2];
		VADDC_operation(0, state.v[19].U16[0], state.v[19].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[19].U16[1], state.v[19].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[19].U16[2], state.v[19].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[19].U16[3], state.v[19].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[19].U16[4], state.v[19].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[19].U16[5], state.v[19].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[19].U16[6], state.v[19].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[19].U16[7], state.v[19].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


_04001BBC:	// 4001bbc: <ca112000>	LQV       vec17 <00> = [S0 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S0]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[17].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[17].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[17].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[17].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[17].U64[0] = state.v[17].U64[0] & ~temp1;
			state.v[17].U64[1] = state.v[17].U64[1] & ~temp2;
			state.v[17].U64[0] = state.v[17].U64[0] | value1;
			state.v[17].U64[1] = state.v[17].U64[1] | value2;
		}
	}


_04001BC0:	// 4001bc0: <06e10003>	BGEZ ?-?
	sp_reg_pc = 0x04001BC0;
	if (state.r[S7] >= 0)
	{
		{
			_u16		flag0 = state.flag[0];
			_u16		s2value = state.v[24].U16[3];
			VADD_operation(0, state.v[18].U16[0], state.v[18].U16[0], s2value, 1, 1, 1, 1)
			VADD_operation(1, state.v[18].U16[1], state.v[18].U16[1], s2value, 1, 1, 1, 1)
			VADD_operation(2, state.v[18].U16[2], state.v[18].U16[2], s2value, 1, 1, 1, 1)
			VADD_operation(3, state.v[18].U16[3], state.v[18].U16[3], s2value, 1, 1, 1, 1)
			VADD_operation(4, state.v[18].U16[4], state.v[18].U16[4], s2value, 1, 1, 1, 1)
			VADD_operation(5, state.v[18].U16[5], state.v[18].U16[5], s2value, 1, 1, 1, 1)
			VADD_operation(6, state.v[18].U16[6], state.v[18].U16[6], s2value, 1, 1, 1, 1)
			VADD_operation(7, state.v[18].U16[7], state.v[18].U16[7], s2value, 1, 1, 1, 1)
			state.flag[0] = 0x0000;
		}
		goto _04001BD0;
	}


_04001BC4:	// 4001bc4: <4b989490>	VADD      vec18 = vec18 + vec24[4]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[24].U16[3];
		VADD_operation(0, state.v[18].U16[0], state.v[18].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[18].U16[1], state.v[18].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[18].U16[2], state.v[18].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[18].U16[3], state.v[18].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[18].U16[4], state.v[18].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[18].U16[5], state.v[18].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[18].U16[6], state.v[18].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[18].U16[7], state.v[18].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


_04001BC8:	// 4001bc8: <090006f5>	J         04001bd4
	rsp_cop2_vge_element(&state.v[20], &state.v[20], &state.v[24].U16[7]);
	goto _04001BD4;


_04001BCC:	// 4001bcc: <4b18a523>	VGE       vec20 = (vec20 >= vec24[0])
	rsp_cop2_vge_element(&state.v[20], &state.v[20], &state.v[24].U16[7]);


_04001BD0:	// 4001bd0: <4b18a520>	VLT ?-?
	rsp_cop2_vlt_element(&state.v[20], &state.v[20], &state.v[24].U16[7]);


_04001BD4:	// 4001bd4: <06c10003>	BGEZ ?-?
	sp_reg_pc = 0x04001BD4;
	if (state.r[S6] >= 0)
	{
		{
			_u32 addr = (0x00000000 + state.r[S3]);
			int shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
				state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
				state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
				state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
			}
			else
			{
				_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
				_u64		value1 = Load64_DMEM(addr+8);
				_u64		value2 = Load64_DMEM(addr);
				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & temp1;
				value2 = value2 & temp2;

				state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
				state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
				state.v[27].U64[0] = state.v[27].U64[0] | value1;
				state.v[27].U64[1] = state.v[27].U64[1] | value2;
			}
		}
		goto _04001BE4;
	}


_04001BD8:	// 4001bd8: <ca7b2000>	LQV       vec27 <00> = [S3 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S3]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[27].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[27].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[27].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[27].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[27].U64[0] = state.v[27].U64[0] & ~temp1;
			state.v[27].U64[1] = state.v[27].U64[1] & ~temp2;
			state.v[27].U64[0] = state.v[27].U64[0] | value1;
			state.v[27].U64[1] = state.v[27].U64[1] | value2;
		}
	}


_04001BDC:	// 4001bdc: <090006fa>	J         04001be8
	rsp_cop2_vge_element(&state.v[18], &state.v[18], &state.v[24].U16[4]);
	goto _04001BE8;


_04001BE0:	// 4001be0: <4b7894a3>	VGE       vec18 = (vec18 >= vec24[3])
	rsp_cop2_vge_element(&state.v[18], &state.v[18], &state.v[24].U16[4]);


_04001BE4:	// 4001be4: <4b7894a0>	VLT ?-?
	rsp_cop2_vlt_element(&state.v[18], &state.v[18], &state.v[24].U16[4]);


_04001BE8:	// 4001be8: <4bd8a400>	VMULF     vec16 = ( acc = (vec20 * vec24[6]) << 1 ) >> 16

	// [start function: Banjo1BE8_1C4C]

	Banjo1BE8_1C4C();
	goto _04001C50;

_04001BEC:	// 4001bec: <eb142000>	SQV       [T8 + 0x00] = vec20 <00>

_04001BF0:	// 4001bf0: <4bf8a3c0>	VMULF     vec15 = ( acc = (vec20 * vec24[7]) << 1 ) >> 16

_04001BF4:	// 4001bf4: <eb152001>	SQV       [T8 + 0x10] = vec21 <00>

_04001BF8:	// 4001bf8: <4baaef40>	VMULF     vec29 = ( acc = (vec29 * vec10[5]) << 1 ) >> 16

_04001BFC:	// 4001bfc: <4a108f48>	VMACF     vec29 = ( acc += (vec17 * vec16[<none>]) << 1 ) >> 16

_04001C00:	// 4001c00: <ca9c2000>	LQV       vec28 <00> = [S4 + 0x00]

_04001C04:	// 4001c04: <4baadec0>	VMULF     vec27 = ( acc = (vec27 * vec10[5]) << 1 ) >> 16

_04001C08:	// 4001c08: <ca5a2000>	LQV       vec26 <00> = [S2 + 0x00]

_04001C0C:	// 4001c0c: <4a0f8ec8>	VMACF     vec27 = ( acc += (vec17 * vec15[<none>]) << 1 ) >> 16

_04001C10:	// 4001c10: <2231fff0>	ADDI      S1 = S1 + fff0

_04001C14:	// 4001c14: <4b58ad54>	VADDC	vec21 = vec21 + vec24[2]

_04001C18:	// 4001c18: <22100010>	ADDI      S0 = S0 + 0010

_04001C1C:	// 4001c1c: <4b38a510>	VADD      vec20 = vec20 + vec24[1]

_04001C20:	// 4001c20: <eabd2000>	SQV       [S5 + 0x00] = vec29 <00>

_04001C24:	// 4001c24: <4bd89400>	VMULF     vec16 = ( acc = (vec18 * vec24[6]) << 1 ) >> 16

_04001C28:	// 4001c28: <22b50010>	ADDI      S5 = S5 + 0010

_04001C2C:	// 4001c2c: <4bf893c0>	VMULF     vec15 = ( acc = (vec18 * vec24[7]) << 1 ) >> 16

_04001C30:	// 4001c30: <ea7b2000>	SQV       [S3 + 0x00] = vec27 <00>

_04001C34:	// 4001c34: <4baae700>	VMULF     vec28 = ( acc = (vec28 * vec10[5]) << 1 ) >> 16

_04001C38:	// 4001c38: <22730010>	ADDI      S3 = S3 + 0010

_04001C3C:	// 4001c3c: <4a108f08>	VMACF     vec28 = ( acc += (vec17 * vec16[<none>]) << 1 ) >> 16

_04001C40:	// 4001c40: <4baad680>	VMULF     vec26 = ( acc = (vec26 * vec10[5]) << 1 ) >> 16

_04001C44:	// 4001c44: <4a0f8e88>	VMACF     vec26 = ( acc += (vec17 * vec15[<none>]) << 1 ) >> 16

_04001C48:	// 4001c48: <ea9c2000>	SQV       [S4 + 0x00] = vec28 <00>

_04001C4C:	// 4001c4c: <22940010>	ADDI      S4 = S4 + 0010
	ErrorToCallFunction(0x04001C4C);

	// [end of function: Banjo1BE8_1C4C]

_04001C50:	// 4001c50: <1a200003>	BLEZ      (R0<=0) --> 1c60
	sp_reg_pc = 0x04001C50;
	if ((_s32)state.r[S1] <= 0)
	{
		{
			_u32    addr = (0x00000000 + state.r[S2]);
			int     shifter = ((addr & 0xf) << 3);

			if (shifter == 0 && (addr&3) == 0 )
			{
				addr &= 0xfff;
				*(_u32 *)&pDMEM[addr+12] = state.v[26].U32[0];
				*(_u32 *)&pDMEM[addr+8 ] = state.v[26].U32[1];
				*(_u32 *)&pDMEM[addr+4 ] = state.v[26].U32[2];
				*(_u32 *)&pDMEM[addr   ] = state.v[26].U32[3];
			}
			else
			{
				_u64    value1 = Load64_DMEM(addr+8);
				_u64    value2 = Load64_DMEM(addr);
				_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
				_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

				if (shifter > 0x40)
				{
					temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
					temp1 = 0;
				} else {
					temp1 = ((temp1 >> shifter) << shifter);
				}
				value1 = value1 & ~temp1;
				value2 = value2 & ~temp2;

				value1 |= (state.v[26].U64[0] & temp1);
				value2 |= (state.v[26].U64[1] & temp2);

				Save64_DMEM(value1, addr+8);
				Save64_DMEM(value2, addr  );
			}
		}
		goto _04001C60;
	}


_04001C54:	// 4001c54: <ea5a2000>	SQV       [S2 + 0x00] = vec26 <00>
	{
		_u32    addr = (0x00000000 + state.r[S2]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[26].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[26].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[26].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[26].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[26].U64[0] & temp1);
			value2 |= (state.v[26].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001C58:	// 4001c58: <090006ed>	J         04001bb4
	state.r[S2] = state.r[S2] + 0x0010;
	goto _04001BB4;


_04001C5C:	// 4001c5c: <22520010>	ADDI      S2 = S2 + 0010
	state.r[S2] = state.r[S2] + 0x0010;


_04001C60:	// 4001c60: <eb122002>	SQV       [T8 + 0x20] = vec18 <00>
	{
		_u32    addr = (0x00000020 + state.r[T8]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[18].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[18].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[18].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[18].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[18].U64[0] & temp1);
			value2 |= (state.v[18].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001C64:	// 4001c64: <eb132003>	SQV       [T8 + 0x30] = vec19 <00>
	{
		_u32    addr = (0x00000030 + state.r[T8]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[19].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[19].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[19].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[19].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[19].U64[0] & temp1);
			value2 |= (state.v[19].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001C68:	// 4001c68: <0d00045e>	JAL	    04001178
	{
		_u32    addr = (0x00000040 + state.r[T8]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[24].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[24].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[24].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[24].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[24].U64[0] & temp1);
			value2 |= (state.v[24].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}
	sp_reg_pc = 0x04001C68;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001178;


_04001C6C:	// 4001c6c: <eb182004>	SQV       [T8 + 0x40] = vec24 <00>
	{
		_u32    addr = (0x00000040 + state.r[T8]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[24].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[24].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[24].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[24].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[24].U64[0] & temp1);
			value2 |= (state.v[24].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


_04001C70:	// 4001c70: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001C74:	// 4001c74: <14a0ffff>	BNE       (R0!=A1) --> 1c74
	sp_reg_pc = 0x04001C74;
	if (state.r[A1] != 0)
	{
		state.r[A1] = 0;
		goto _04001C74;
	}


_04001C78:	// 4001c78: <40053000>	MFC0      A2 = SP DMA full
	state.r[A1] = 0;


_04001C7C:	// 4001c7c: <40803800>	MTC0      SP semaphore = R0


_04001C80:	// 4001c80: <0900043c>	J         040010f0
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;
	goto _040010F0;


_04001C84:	// 4001c84: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_04001C88:	// 4001c88: <c81f2005>	LQV       vec31 <00> = [R0 + 0x50]
	// In function: SmashBros1C84_1CC8
	//Call the function: SmashBros1C84_1CC8
	SmashBros1C84_1CC8();
	goto _04001CD0;

_04001C8C:	// 4001c8c: <3336ffff>	ANDI      S6 = T9 & ffff
	ErrorToCallFunction(0x04001C8C);

_04001C90:	// 4001c90: <22d604f0>	ADDI      S6 = S6 + 04f0
	ErrorToCallFunction(0x04001C90);

_04001C94:	// 4001c94: <cadc2000>	LQV       vec28 <00> = [S6 + 0x00]
	ErrorToCallFunction(0x04001C94);

_04001C98:	// 4001c98: <0019bc02>	SRL       S7 = T9 >> 16
	ErrorToCallFunction(0x04001C98);

_04001C9C:	// 4001c9c: <22f704f0>	ADDI      S7 = S7 + 04f0
	ErrorToCallFunction(0x04001C9C);

_04001CA0:	// 4001ca0: <cafd2000>	LQV       vec29 <00> = [S7 + 0x00]
	ErrorToCallFunction(0x04001CA0);

_04001CA4:	// 4001ca4: <489af000>	MTC2      vec30 <00> = K0
	ErrorToCallFunction(0x04001CA4);

_04001CA8:	// 4001ca8: <20150170>	ADDI      S5 = R0 + 0170
	ErrorToCallFunction(0x04001CA8);

_04001CAC:	// 4001cac: <4bbfe6c0>	VMULF     vec27 = ( acc = (vec28 * vec31[5]) << 1 ) >> 16
	ErrorToCallFunction(0x04001CAC);

_04001CB0:	// 4001cb0: <22b5fff0>	ADDI      S5 = S5 + fff0
	ErrorToCallFunction(0x04001CB0);

_04001CB4:	// 4001cb4: <22f70010>	ADDI      S7 = S7 + 0010
	ErrorToCallFunction(0x04001CB4);

_04001CB8:	// 4001cb8: <22d60010>	ADDI      S6 = S6 + 0010
	ErrorToCallFunction(0x04001CB8);

_04001CBC:	// 4001cbc: <4b1eeec8>	VMACF     vec27 = ( acc += (vec29 * vec30[0]) << 1 ) >> 16
	ErrorToCallFunction(0x04001CBC);

_04001CC0:	// 4001cc0: <cadc2000>	LQV       vec28 <00> = [S6 + 0x00]
	ErrorToCallFunction(0x04001CC0);

_04001CC4:	// 4001cc4: <cafd2000>	LQV       vec29 <00> = [S7 + 0x00]
	ErrorToCallFunction(0x04001CC4);

_04001CC8:	// 4001cc8: <1ea0fff8>	BGTZ      (R0>0) --> 1cac
	ErrorToCallFunction(0x04001CC8);

_04001CCC:	// 4001ccc: <eadb207f>	SQV       [S6 + 0xf0] = vec27 <00>
	ErrorToCallFunction(0x04001CCC);

_04001CD0:	// 4001cd0: <0900043c>	J         040010f0
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;
	goto _040010F0;


_04001CD4:	// 4001cd4: <23defff8>	ADDI      S8 = S8 + fff8
	state.r[S8] = state.r[S8] + 0xFFFFFFF8;


_04001CD8:	// 4001cd8: <00000000>	NOP       


_04001CDC:	// 4001cdc: <00000000>	NOP       


_04001CE0:	// 4001ce0: <090005ce>	J         04001738
	state.r[SP] = 0 + 0x0110;
	goto _04001738;


_04001CE4:	// 4001ce4: <201d0110>	ADDI      SP = R0 + 0110
	state.r[SP] = 0 + 0x0110;


_04001CE8:	// 4001ce8: <0d0007f5>	JAL	    04001fd4
	state.r[S4] = (0 + state.r[S6]);
	sp_reg_pc = 0x04001CE8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001FD4;


_04001CEC:	// 4001cec: <0016a020>	ADD       S4 = R0+S6
	state.r[S4] = (0 + state.r[S6]);


_04001CF0:	// 4001cf0: <842200b8>	LH        V0 = [AT+00b8]
	state.r[V0] = (_s32)(_s16)Load16_DMEM((state.r[AT] + 0x000000B8) & 0xfff);


_04001CF4:	// 4001cf4: <00400008>	JR        V0
	{
		_u32	temp = ((state.r[V0] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		state.r[V0] = ((_u32)state.r[T9] >> 23);
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001CF8:	// 4001cf8: <001915c2>	SRL       V0 = T9 >> 23
	state.r[V0] = ((_u32)state.r[T9] >> 23);


_04001CFC:	// 4001cfc: <40022000>	MFC0      A0 = SP read DMA length
	state.r[V0] = 0;


_04001D00:	// 4001d00: <30420080>	ANDI      V0 = V0 & 0080
	state.r[V0] = (state.r[V0] & 0x00000080);


_04001D04:	// 4001d04: <14400006>	BNE       (R0!=V0) --> 1d20
	sp_reg_pc = 0x04001D04;
	if (state.r[V0] != 0)
	{
		state.r[S5] = (_s32)(_s16)Load16_DMEM((0 + 0x00000026) & 0xfff);
		goto _04001D20;
	}


_04001D08:	// 4001d08: <84150026>	LH        S5 = [R0+0026]
	state.r[S5] = (_s32)(_s16)Load16_DMEM((0 + 0x00000026) & 0xfff);


_04001D0C:	// 4001d0c: <179bffed>	BNE       (K1!=GP) --> 1cc4
	sp_reg_pc = 0x04001D0C;
	if (state.r[GP] != state.r[K1])
	{
		state.r[T9] = (_s32)Load32_DMEM((state.r[K1] + 0x00000000) & 0xfff);
		goto _04001CC4;
	}


_04001D10:	// 4001d10: <8f790000>	LW        T9 = [K1+0000]
	state.r[T9] = (_s32)Load32_DMEM((state.r[K1] + 0x00000000) & 0xfff);


_04001D14:	// 4001d14: <09000432>	J         040010c8
	state.r[RA] = (_s32)(_s16)Load16_DMEM((0 + 0x00000104) & 0xfff);
	goto _040010C8;


_04001D18:	// 4001d18: <841f0104>	LH        RA = [R0+0104]
	state.r[RA] = (_s32)(_s16)Load16_DMEM((0 + 0x00000104) & 0xfff);


_04001D1C:	// 4001d1c: <841500b6>	LH        S5 = [R0+00b6]
	state.r[S5] = (_s32)(_s16)Load16_DMEM((0 + 0x000000B6) & 0xfff);


_04001D20:	// 4001d20: <0900043c>	J         040010f0
	state.r[S8] = (0 | 0x00000020);
	goto _040010F0;


_04001D24:	// 4001d24: <341e0020>	ORI       S8 = R0 | 0x0020
	state.r[S8] = (0 | 0x00000020);


_04001D28:	// 4001d28: <201c0ae0>	ADDI      GP = R0 + 0ae0
	state.r[GP] = 0 + 0x0AE0;


_04001D2C:	// 4001d2c: <001fa820>	ADD       S5 = R0+RA
	state.r[S5] = (0 + state.r[RA]);


_04001D30:	// 4001d30: <201409a0>	ADDI      S4 = R0 + 09a0
	state.r[S4] = 0 + 0x09A0;


_04001D34:	// 4001d34: <001a9820>	ADD       S3 = R0+K0
	state.r[S3] = (0 + state.r[K0]);


_04001D38:	// 4001d38: <235a0140>	ADDI      K0 = K0 + 0140
	state.r[K0] = state.r[K0] + 0x0140;


_04001D3C:	// 4001d3c: <0d0007f5>	JAL	    04001fd4
	state.r[S2] = 0 + 0x013F;
	sp_reg_pc = 0x04001D3C;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001FD4;


_04001D40:	// 4001d40: <2012013f>	ADDI      S2 = R0 + 013f
	state.r[S2] = 0 + 0x013F;


_04001D44:	// 4001d44: <02a00008>	JR        S5
	{
		_u32	temp = ((state.r[S5] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		state.r[K1] = 0 + 0x09A0;
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001D48:	// 4001d48: <201b09a0>	ADDI      K1 = R0 + 09a0
	state.r[K1] = 0 + 0x09A0;


_04001D4C:	// 4001d4c: <001fa820>	ADD       S5 = R0+RA
	state.r[S5] = (0 + state.r[RA]);


_04001D50:	// 4001d50: <8fd30000>	LW        S3 = [S8+0000]
	state.r[S3] = (_s32)Load32_DMEM((state.r[S8] + 0x00000000) & 0xfff);


_04001D54:	// 4001d54: <87d20004>	LH        S2 = [S8+0004]
	state.r[S2] = (_s32)(_s16)Load16_DMEM((state.r[S8] + 0x00000004) & 0xfff);


_04001D58:	// 4001d58: <0d0007f5>	JAL	    04001fd4
	state.r[S4] = (_s32)(_s16)Load16_DMEM((state.r[S8] + 0x00000006) & 0xfff);
	sp_reg_pc = 0x04001D58;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001FD4;


_04001D5C:	// 4001d5c: <87d40006>	LH        S4 = [S8+0006]
	state.r[S4] = (_s32)(_s16)Load16_DMEM((state.r[S8] + 0x00000006) & 0xfff);


_04001D60:	// 4001d60: <0d0007f1>	JAL	    04001fc4
	sp_reg_pc = 0x04001D60;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001FC4;


_04001D64:	// 4001d64: <00000000>	NOP       


_04001D68:	// 4001d68: <02a00008>	JR        S5
	{
		_u32	temp = ((state.r[S5] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		state.r[T4] = ((_u32)state.r[S3] >> 22);
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001D6C:	// 4001d6c: <00136582>	SRL       T4 = S3 >> 22
	state.r[T4] = ((_u32)state.r[S3] >> 22);


_04001D70:	// 4001d70: <318c003c>	ANDI      T4 = T4 & 003c
	state.r[T4] = (state.r[T4] & 0x0000003C);


_04001D74:	// 4001d74: <8d8c0160>	LW        T4 = [T4+0160]
	state.r[T4] = (_s32)Load32_DMEM((state.r[T4] + 0x00000160) & 0xfff);


_04001D78:	// 4001d78: <00139a00>	SLL       S3 = S3 << 8
	state.r[S3] = ((_u32)state.r[S3] << 8);


_04001D7C:	// 4001d7c: <00139a02>	SRL       S3 = S3 >> 8
	state.r[S3] = ((_u32)state.r[S3] >> 8);


_04001D80:	// 4001d80: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		state.r[S3] = (state.r[S3] + state.r[T4]);
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001D84:	// 4001d84: <026c9820>	ADD       S3 = S3+T4
	state.r[S3] = (state.r[S3] + state.r[T4]);


_04001D88:	// 4001d88: <001fa820>	ADD       S5 = R0+RA
	state.r[S5] = (0 + state.r[RA]);


_04001D8C:	// 4001d8c: <8fb30018>	LW        S3 = [SP+0018]
	state.r[S3] = (_s32)Load32_DMEM((state.r[SP] + 0x00000018) & 0xfff);


_04001D90:	// 4001d90: <22f2f320>	ADDI      S2 = S7 + f320
	state.r[S2] = state.r[S7] + 0xFFFFF320;


_04001D94:	// 4001d94: <8fb70044>	LW        S7 = [SP+0044]
	state.r[S7] = (_s32)Load32_DMEM((state.r[SP] + 0x00000044) & 0xfff);


_04001D98:	// 4001d98: <1a40001a>	BLEZ      (R0<=0) --> 1e04
	sp_reg_pc = 0x04001D98;
	if ((_s32)state.r[S2] <= 0)
	{
		state.r[S4] = (state.r[S3] + state.r[S2]);
		goto _04001E04;
	}


_04001D9C:	// 4001d9c: <0272a020>	ADD       S4 = S3+S2
	state.r[S4] = (state.r[S3] + state.r[S2]);


_04001DA0:	// 4001da0: <02f4a022>	SUB       S4 = S7-S4
	state.r[S4] = (state.r[S7] - state.r[S4]);


_04001DA4:	// 4001da4: <06810008>	BGEZ ?-?
	sp_reg_pc = 0x04001DA4;
	if (state.r[S4] >= 0)
	{
		state.r[S4] = 0;
		goto _04001DC8;
	}


_04001DA8:	// 4001da8: <40145800>	MFC0      T3 = unknown
	state.r[S4] = 0;


_04001DAC:	// 4001dac: <32940400>	ANDI      S4 = S4 & 0400
	state.r[S4] = (state.r[S4] & 0x00000400);


_04001DB0:	// 4001db0: <1680fffd>	BNE       (R0!=S4) --> 1da8
	sp_reg_pc = 0x04001DB0;
	if (state.r[S4] != 0)
	{
		state.r[S7] = 0;
		goto _04001DA8;
	}


_04001DB4:	// 4001db4: <40175000>	MFC0      T2 = unknown
	state.r[S7] = 0;


_04001DB8:	// 4001db8: <8fb30040>	LW        S3 = [SP+0040]
	state.r[S3] = (_s32)Load32_DMEM((state.r[SP] + 0x00000040) & 0xfff);


_04001DBC:	// 4001dbc: <12f3fffd>	BEQ       (S3==S7) --> 1db4
	sp_reg_pc = 0x04001DBC;
	if (state.r[S7] == state.r[S3])
	{
		goto _04001DB4;
	}


_04001DC0:	// 4001dc0: <00000000>	NOP       


_04001DC4:	// 4001dc4: <40934000>	MTC0      DP CMD DMA start = S3


_04001DC8:	// 4001dc8: <40175000>	MFC0      T2 = unknown
	state.r[S7] = 0;


_04001DCC:	// 4001dcc: <0277a022>	SUB       S4 = S3-S7
	state.r[S4] = (state.r[S3] - state.r[S7]);


_04001DD0:	// 4001dd0: <06810004>	BGEZ ?-?
	sp_reg_pc = 0x04001DD0;
	if (state.r[S4] >= 0)
	{
		state.r[S4] = (state.r[S3] + state.r[S2]);
		goto _04001DE4;
	}


_04001DD4:	// 4001dd4: <0272a020>	ADD       S4 = S3+S2
	state.r[S4] = (state.r[S3] + state.r[S2]);


_04001DD8:	// 4001dd8: <0297a022>	SUB       S4 = S4-S7
	state.r[S4] = (state.r[S4] - state.r[S7]);


_04001DDC:	// 4001ddc: <0681fffa>	BGEZ ?-?
	sp_reg_pc = 0x04001DDC;
	if (state.r[S4] >= 0)
	{
		goto _04001DC8;
	}


_04001DE0:	// 4001de0: <00000000>	NOP       


_04001DE4:	// 4001de4: <0272b820>	ADD       S7 = S3+S2
	state.r[S7] = (state.r[S3] + state.r[S2]);


_04001DE8:	// 4001de8: <2252ffff>	ADDI      S2 = S2 + ffff
	state.r[S2] = state.r[S2] + 0xFFFFFFFF;


_04001DEC:	// 4001dec: <20140ce0>	ADDI      S4 = R0 + 0ce0
	state.r[S4] = 0 + 0x0CE0;


_04001DF0:	// 4001df0: <0d0007f6>	JAL	    04001fd8
	state.r[S1] = 0 + 0x0001;
	sp_reg_pc = 0x04001DF0;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001FD8;


_04001DF4:	// 4001df4: <20110001>	ADDI      S1 = R0 + 0001
	state.r[S1] = 0 + 0x0001;


_04001DF8:	// 4001df8: <0d0007f1>	JAL	    04001fc4
	Save32_DMEM((_u32)state.r[S7], (state.r[SP] + 0x00000018) & 0xfff);
	sp_reg_pc = 0x04001DF8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001FC4;


_04001DFC:	// 4001dfc: <afb70018>	SW        [SP+0018] = S7
	Save32_DMEM((_u32)state.r[S7], (state.r[SP] + 0x00000018) & 0xfff);


_04001E00:	// 4001e00: <40974800>	MTC0      DP CMD DMA end = S7


_04001E04:	// 4001e04: <02a00008>	JR        S5
	{
		_u32	temp = ((state.r[S5] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		state.r[S7] = 0 + 0x0CE0;
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001E08:	// 4001e08: <20170ce0>	ADDI      S7 = R0 + 0ce0
	state.r[S7] = 0 + 0x0CE0;


_04001E0C:	// 4001e0c: <304200fe>	ANDI      V0 = V0 & 00fe
	state.r[V0] = (state.r[V0] & 0x000000FE);


_04001E10:	// 4001e10: <84420076>	LH        V0 = [V0+0076]
	state.r[V0] = (_s32)(_s16)Load16_DMEM((state.r[V0] + 0x00000076) & 0xfff);


_04001E14:	// 4001e14: <00400008>	JR        V0
	{
		_u32	temp = ((state.r[V0] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		state.r[AT] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFFF) & 0xfff) ^ 3];
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001E18:	// 4001e18: <9361ffff>	LBU       AT = [K1+ffff]
	state.r[AT] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFFF) & 0xfff) ^ 3];


_04001E1C:	// 4001e1c: <841800ba>	LH        T8 = [R0+00ba]
	state.r[T8] = (_s32)(_s16)Load16_DMEM((0 + 0x000000BA) & 0xfff);


_04001E20:	// 4001e20: <841f0396>	LH        RA = [R0+0396]
	state.r[RA] = (_s32)(_s16)Load16_DMEM((0 + 0x00000396) & 0xfff);


_04001E24:	// 4001e24: <9361fffd>	LBU       AT = [K1+fffd]
	state.r[AT] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFFD) & 0xfff) ^ 3];


_04001E28:	// 4001e28: <9362fffe>	LBU       V0 = [K1+fffe]
	state.r[V0] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFFE) & 0xfff) ^ 3];


_04001E2C:	// 4001e2c: <9363ffff>	LBU       V1 = [K1+ffff]
	state.r[V1] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFFF) & 0xfff) ^ 3];


_04001E30:	// 4001e30: <9421031e>	LHU       AT = [AT+031e]
	state.r[AT] = (_s32)(_u16)Load16_DMEM((state.r[AT] + 0x0000031E) & 0xfff);


_04001E34:	// 4001e34: <9442031e>	LHU       V0 = [V0+031e]
	state.r[V0] = (_s32)(_u16)Load16_DMEM((state.r[V0] + 0x0000031E) & 0xfff);


_04001E38:	// 4001e38: <9463031e>	LHU       V1 = [V1+031e]
	state.r[V1] = (_s32)(_u16)Load16_DMEM((state.r[V1] + 0x0000031E) & 0xfff);


_04001E3C:	// 4001e3c: <03e00008>	JR        RA
	{
		_u32	temp = ((state.r[RA] & 0x0FFF) >> 2);
		_u32	tempAddr = JumpTable[temp];
		state.r[A0] = state.r[AT] + 0x0000;
		__asm mov eax, tempAddr;
		__asm jmp eax;
	}


_04001E40:	// 4001e40: <20240000>	ADDI      A0 = AT + 0000
	state.r[A0] = state.r[AT] + 0x0000;


_04001E44:	// 4001e44: <0d000470>	JAL	    040011c0
	state.r[T8] = state.r[RA] + 0x0000;
	sp_reg_pc = 0x04001E44;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _040011C0;


_04001E48:	// 4001e48: <23f80000>	ADDI      T8 = RA + 0000
	state.r[T8] = state.r[RA] + 0x0000;


_04001E4C:	// 4001e4c: <9361fff9>	LBU       AT = [K1+fff9]
	state.r[AT] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFF9) & 0xfff) ^ 3];


_04001E50:	// 4001e50: <9362fffa>	LBU       V0 = [K1+fffa]
	state.r[V0] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFFA) & 0xfff) ^ 3];


_04001E54:	// 4001e54: <9363fffb>	LBU       V1 = [K1+fffb]
	state.r[V1] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFFB) & 0xfff) ^ 3];


_04001E58:	// 4001e58: <841f0396>	LH        RA = [R0+0396]
	state.r[RA] = (_s32)(_s16)Load16_DMEM((0 + 0x00000396) & 0xfff);


_04001E5C:	// 4001e5c: <09000474>	J         040011d0
	state.r[T8] = (_s32)(_s16)Load16_DMEM((0 + 0x000000BA) & 0xfff);
	goto _040011D0;


_04001E60:	// 4001e60: <841800ba>	LH        T8 = [R0+00ba]
	state.r[T8] = (_s32)(_s16)Load16_DMEM((0 + 0x000000BA) & 0xfff);


_04001E64:	// 4001e64: <ebbf031c>	SBV
	Save8_DMEM(state.v[31].U8[9], (0x0000001C + state.r[SP]) & 0xfff);


_04001E68:	// 4001e68: <8fb30024>	LW        S3 = [SP+0024]
	state.r[S3] = (_s32)Load32_DMEM((state.r[SP] + 0x00000024) & 0xfff);


_04001E6C:	// 4001e6c: <8c030fe0>	LW        V1 = [R0+0fe0]
	state.r[V1] = (_s32)Load32_DMEM((0 + 0x00000FE0) & 0xfff);


_04001E70:	// 4001e70: <201403e0>	ADDI      S4 = R0 + 03e0
	state.r[S4] = 0 + 0x03E0;


_04001E74:	// 4001e74: <00731822>	SUB       V1 = V1-S3
	state.r[V1] = (state.r[V1] - state.r[S3]);


_04001E78:	// 4001e78: <0461ffa0>	BGEZ ?-?
	sp_reg_pc = 0x04001E78;
	if (state.r[V1] >= 0)
	{
		state.r[S3] = state.r[S3] + 0xFFFFFFC0;
		goto _04001CFC;
	}


_04001E7C:	// 4001e7c: <2273ffc0>	ADDI      S3 = S3 + ffc0
	state.r[S3] = state.r[S3] + 0xFFFFFFC0;


_04001E80:	// 4001e80: <0d0007f5>	JAL	    04001fd4
	state.r[S2] = 0 + 0x003F;
	sp_reg_pc = 0x04001E80;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001FD4;


_04001E84:	// 4001e84: <2012003f>	ADDI      S2 = R0 + 003f
	state.r[S2] = 0 + 0x003F;


_04001E88:	// 4001e88: <0d0007f1>	JAL	    04001fc4
	state.r[V1] = 0 + 0x0460;
	sp_reg_pc = 0x04001E88;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001FC4;


_04001E8C:	// 4001e8c: <20030460>	ADDI      V1 = R0 + 0460
	state.r[V1] = 0 + 0x0460;


_04001E90:	// 4001e90: <0900056f>	J         040015bc
	Save32_DMEM((_u32)state.r[S3], (state.r[SP] + 0x00000024) & 0xfff);
	goto _040015BC;


_04001E94:	// 4001e94: <afb30024>	SW        [SP+0024] = S3
	Save32_DMEM((_u32)state.r[S3], (state.r[SP] + 0x00000024) & 0xfff);


_04001E98:	// 4001e98: <9361fffb>	LBU       AT = [K1+fffb]
	state.r[AT] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFFB) & 0xfff) ^ 3];


_04001E9C:	// 4001e9c: <9762fff9>	LHU       V0 = [K1+fff9]
	state.r[V0] = (_s32)(_u16)Load16_DMEM((state.r[K1] + 0xFFFFFFF9) & 0xfff);


_04001EA0:	// 4001ea0: <8425030e>	LH        A1 = [AT+030e]
	state.r[A1] = (_s32)(_s16)Load16_DMEM((state.r[AT] + 0x0000030E) & 0xfff);


_04001EA4:	// 4001ea4: <00a22820>	ADD       A1 = A1+V0
	state.r[A1] = (state.r[A1] + state.r[V0]);


_04001EA8:	// 4001ea8: <09000427>	J         0400109c
	Save32_DMEM((_u32)state.r[T8], (state.r[A1] + 0x00000000) & 0xfff);
	goto _0400109C;


_04001EAC:	// 4001eac: <acb80000>	SW        [A1+0000] = T8
	Save32_DMEM((_u32)state.r[T8], (state.r[A1] + 0x00000000) & 0xfff);


_04001EB0:	// 4001eb0: <afb90010>	SW        [SP+0010] = T9
	Save32_DMEM((_u32)state.r[T9], (state.r[SP] + 0x00000010) & 0xfff);


_04001EB4:	// 4001eb4: <afb80014>	SW        [SP+0014] = T8
	Save32_DMEM((_u32)state.r[T8], (state.r[SP] + 0x00000014) & 0xfff);


_04001EB8:	// 4001eb8: <87a20006>	LH        V0 = [SP+0006]
	state.r[V0] = (_s32)(_s16)Load16_DMEM((state.r[SP] + 0x00000006) & 0xfff);


_04001EBC:	// 4001ebc: <3042fffd>	ANDI      V0 = V0 & fffd
	state.r[V0] = (state.r[V0] & 0x0000FFFD);


_04001EC0:	// 4001ec0: <33230001>	ANDI      V1 = T9 & 0001
	state.r[V1] = (state.r[T9] & 0x00000001);


_04001EC4:	// 4001ec4: <00031840>	SLL       V1 = V1 << 1
	state.r[V1] = ((_u32)state.r[V1] << 1);


_04001EC8:	// 4001ec8: <00431025>	OR        V0 = V0 | V1
	state.r[V0] = (state.r[V0] | state.r[V1]);


_04001ECC:	// 4001ecc: <09000427>	J         0400109c
	Save16_DMEM((_u16)state.r[V0], (state.r[SP] + 0x00000006) & 0xfff);
	goto _0400109C;


_04001ED0:	// 4001ed0: <a7a20006>	SH        [SP+0006] = V0
	Save16_DMEM((_u16)state.r[V0], (state.r[SP] + 0x00000006) & 0xfff);


_04001ED4:	// 4001ed4: <090004a0>	J         04001280
	state.r[A3] = state.r[SP] + 0x0008;
	goto _04001280;


_04001ED8:	// 4001ed8: <23a70008>	ADDI      A3 = SP + 0008
	state.r[A3] = state.r[SP] + 0x0008;


_04001EDC:	// 4001edc: <23a7000c>	ADDI      A3 = SP + 000c
	state.r[A3] = state.r[SP] + 0x000C;


_04001EE0:	// 4001ee0: <8ce30000>	LW        V1 = [A3+0000]
	state.r[V1] = (_s32)Load32_DMEM((state.r[A3] + 0x00000000) & 0xfff);


_04001EE4:	// 4001ee4: <9365fffb>	LBU       A1 = [K1+fffb]
	state.r[A1] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFFB) & 0xfff) ^ 3];


_04001EE8:	// 4001ee8: <9366fffa>	LBU       A2 = [K1+fffa]
	state.r[A2] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFFA) & 0xfff) ^ 3];


_04001EEC:	// 4001eec: <20020001>	ADDI      V0 = R0 + 0001
	state.r[V0] = 0 + 0x0001;


_04001EF0:	// 4001ef0: <00a21004>	SLLV      V0 = V0 << A1
	state.r[V0] = (state.r[V0] << (state.r[A1] & 0x1F));


_04001EF4:	// 4001ef4: <2042ffff>	ADDI      V0 = V0 + ffff
	state.r[V0] = state.r[V0] + 0xFFFFFFFF;


_04001EF8:	// 4001ef8: <00c21004>	SLLV      V0 = V0 << A2
	state.r[V0] = (state.r[V0] << (state.r[A2] & 0x1F));


_04001EFC:	// 4001efc: <00401027>	NOR       V0 = V0 nor R0
	state.r[V0] = ~(state.r[V0] | 0);


_04001F00:	// 4001f00: <00431024>	AND       V0 = V0 & V1
	state.r[V0] = (state.r[V0] & state.r[V1]);


_04001F04:	// 4001f04: <00581825>	OR        V1 = V0 | T8
	state.r[V1] = (state.r[V0] | state.r[T8]);


_04001F08:	// 4001f08: <ace30000>	SW        [A3+0000] = V1
	Save32_DMEM((_u32)state.r[V1], (state.r[A3] + 0x00000000) & 0xfff);


_04001F0C:	// 4001f0c: <8fb90008>	LW        T9 = [SP+0008]
	state.r[T9] = (_s32)Load32_DMEM((state.r[SP] + 0x00000008) & 0xfff);


_04001F10:	// 4001f10: <090004dd>	J         04001374
	state.r[T8] = (_s32)Load32_DMEM((state.r[SP] + 0x0000000C) & 0xfff);
	goto _04001374;


_04001F14:	// 4001f14: <8fb8000c>	LW        T8 = [SP+000c]
	state.r[T8] = (_s32)Load32_DMEM((state.r[SP] + 0x0000000C) & 0xfff);


_04001F18:	// 4001f18: <9739031e>	LHU       T9 = [T9+031e]
	state.r[T9] = (_s32)(_u16)Load16_DMEM((state.r[T9] + 0x0000031E) & 0xfff);


_04001F1C:	// 4001f1c: <9718031e>	LHU       T8 = [T8+031e]
	state.r[T8] = (_s32)(_u16)Load16_DMEM((state.r[T8] + 0x0000031E) & 0xfff);


_04001F20:	// 4001f20: <34027070>	ORI       V0 = R0 | 0x7070
	state.r[V0] = (0 | 0x00007070);


_04001F24:	// 4001f24: <87230024>	LH        V1 = [T9+0024]
	state.r[V1] = (_s32)(_s16)Load16_DMEM((state.r[T9] + 0x00000024) & 0xfff);


_04001F28:	// 4001f28: <00431024>	AND       V0 = V0 & V1
	state.r[V0] = (state.r[V0] & state.r[V1]);


_04001F2C:	// 4001f2c: <1738fffd>	BNE       (T8!=T9) --> 1f24
	sp_reg_pc = 0x04001F2C;
	if (state.r[T9] != state.r[T8])
	{
		state.r[T9] = state.r[T9] + 0x0028;
		goto _04001F24;
	}


_04001F30:	// 4001f30: <23390028>	ADDI      T9 = T9 + 0028
	state.r[T9] = state.r[T9] + 0x0028;


_04001F34:	// 4001f34: <1040ff71>	BEQ       (R0==V0) --> 1cfc
	sp_reg_pc = 0x04001F34;
	if (state.r[V0] == 0)
	{
		state.r[V0] = (_s32)(_s8)pDMEM[((state.r[SP] + 0x00000038) & 0xfff) ^ 3];
		goto _04001CFC;
	}


_04001F38:	// 4001f38: <83a20038>	LB        V0 = [SP+0038]
	state.r[V0] = (_s32)(_s8)pDMEM[((state.r[SP] + 0x00000038) & 0xfff) ^ 3];


_04001F3C:	// 4001f3c: <2042fffc>	ADDI      V0 = V0 + fffc
	state.r[V0] = state.r[V0] + 0xFFFFFFFC;


_04001F40:	// 4001f40: <0440ff76>	BLTZ ?-?
	sp_reg_pc = 0x04001F40;
	if (state.r[V0] < 0)
	{
		state.r[V1] = state.r[V0] + 0x0398;
		goto _04001D1C;
	}


_04001F44:	// 4001f44: <20430398>	ADDI      V1 = V0 + 0398
	state.r[V1] = state.r[V0] + 0x0398;


_04001F48:	// 4001f48: <8c7a0000>	LW        K0 = [V1+0000]
	state.r[K0] = (_s32)Load32_DMEM((state.r[V1] + 0x00000000) & 0xfff);


_04001F4C:	// 4001f4c: <a3a20038>	SB        [SP+0038] = V0
	Save8_DMEM((_u8)state.r[V0], (state.r[SP] + 0x00000038) & 0xfff);


_04001F50:	// 4001f50: <09000427>	J         0400109c
	state.r[GP] = state.r[K1] + 0x0000;
	goto _0400109C;


_04001F54:	// 4001f54: <237c0000>	ADDI      GP = K1 + 0000
	state.r[GP] = state.r[K1] + 0x0000;


_04001F58:	// 4001f58: <9739031e>	LHU       T9 = [T9+031e]
	state.r[T9] = (_s32)(_u16)Load16_DMEM((state.r[T9] + 0x0000031E) & 0xfff);


_04001F5C:	// 4001f5c: <8f39001c>	LW        T9 = [T9+001c]
	state.r[T9] = (_s32)Load32_DMEM((state.r[T9] + 0x0000001C) & 0xfff);


_04001F60:	// 4001f60: <0338c822>	SUB       T9 = T9-T8
	state.r[T9] = (state.r[T9] - state.r[T8]);


_04001F64:	// 4001f64: <1f20ff65>	BGTZ      (R0>0) --> 1cfc
	sp_reg_pc = 0x04001F64;
	if((_s32)state.r[T9] > 0)
	{
		state.r[T8] = (_s32)Load32_DMEM((state.r[SP] + 0xFFFFFFFC) & 0xfff);
		goto _04001CFC;
	}


_04001F68:	// 4001f68: <8fb8fffc>	LW        T8 = [SP+fffc]
	state.r[T8] = (_s32)Load32_DMEM((state.r[SP] + 0xFFFFFFFC) & 0xfff);


_04001F6C:	// 4001f6c: <090005c2>	J         04001708
	state.r[V0] = (_s32)Load32_DMEM((state.r[SP] + 0x00000004) & 0xfff);
	goto _04001708;


_04001F70:	// 4001f70: <8fa20004>	LW        V0 = [SP+0004]
	state.r[V0] = (_s32)Load32_DMEM((state.r[SP] + 0x00000004) & 0xfff);


_04001F74:	// 4001f74: <00581025>	OR        V0 = V0 | T8
	state.r[V0] = (state.r[V0] | state.r[T8]);


_04001F78:	// 4001f78: <09000427>	J         0400109c
	Save32_DMEM((_u32)state.r[V0], (state.r[SP] + 0x00000004) & 0xfff);
	goto _0400109C;


_04001F7C:	// 4001f7c: <afa20004>	SW        [SP+0004] = V0
	Save32_DMEM((_u32)state.r[V0], (state.r[SP] + 0x00000004) & 0xfff);


_04001F80:	// 4001f80: <8fa20004>	LW        V0 = [SP+0004]
	state.r[V0] = (_s32)Load32_DMEM((state.r[SP] + 0x00000004) & 0xfff);


_04001F84:	// 4001f84: <03001827>	NOR       V1 = T8 nor R0
	state.r[V1] = ~(state.r[T8] | 0);


_04001F88:	// 4001f88: <00431024>	AND       V0 = V0 & V1
	state.r[V0] = (state.r[V0] & state.r[V1]);


_04001F8C:	// 4001f8c: <09000427>	J         0400109c
	Save32_DMEM((_u32)state.r[V0], (state.r[SP] + 0x00000004) & 0xfff);
	goto _0400109C;


_04001F90:	// 4001f90: <afa20004>	SW        [SP+0004] = V0
	Save32_DMEM((_u32)state.r[V0], (state.r[SP] + 0x00000004) & 0xfff);


_04001F94:	// 4001f94: <9362fff9>	LBU       V0 = [K1+fff9]
	state.r[V0] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFF9) & 0xfff) ^ 3];


_04001F98:	// 4001f98: <9723031e>	LHU       V1 = [T9+031e]
	state.r[V1] = (_s32)(_u16)Load16_DMEM((state.r[T9] + 0x0000031E) & 0xfff);


_04001F9C:	// 4001f9c: <00621820>	ADD       V1 = V1+V0
	state.r[V1] = (state.r[V1] + state.r[V0]);


_04001FA0:	// 4001fa0: <09000427>	J         0400109c
	Save32_DMEM((_u32)state.r[T8], (state.r[V1] + 0x00000000) & 0xfff);
	goto _0400109C;


_04001FA4:	// 4001fa4: <ac780000>	SW        [V1+0000] = T8
	Save32_DMEM((_u32)state.r[T8], (state.r[V1] + 0x00000000) & 0xfff);


_04001FA8:	// 4001fa8: <0900042b>	J         040010ac
	Save32_DMEM((_u32)state.r[T8], (state.r[SP] + 0xFFFFFFFC) & 0xfff);
	goto _040010AC;


_04001FAC:	// 4001fac: <afb8fffc>	SW        [SP+fffc] = T8
	Save32_DMEM((_u32)state.r[T8], (state.r[SP] + 0xFFFFFFFC) & 0xfff);


_04001FB0:	// 4001fb0: <090004dd>	J         04001374
	state.r[T9] = (_s32)Load32_DMEM((state.r[SP] + 0xFFFFFFFC) & 0xfff);
	goto _04001374;


_04001FB4:	// 4001fb4: <8fb9fffc>	LW        T9 = [SP+fffc]
	state.r[T9] = (_s32)Load32_DMEM((state.r[SP] + 0xFFFFFFFC) & 0xfff);


_04001FB8:	// 4001fb8: <00191603>	SRA       V0 = T9 >> 24
	state.r[V0] = ((_s32)state.r[T9] >> 24);


_04001FBC:	// 4001fbc: <20420003>	ADDI      V0 = V0 + 0003
	state.r[V0] = state.r[V0] + 0x0003;


_04001FC0:	// 4001fc0: <04400004>	BLTZ ?-?
	sp_reg_pc = 0x04001FC0;
	if (state.r[V0] < 0)
	{
		state.r[V0] = state.r[V0] + 0x0018;
		goto _04001FD4;
	}


_04001FC4:	// 4001fc4: <20420018>	ADDI      V0 = V0 + 0018
	state.r[V0] = state.r[V0] + 0x0018;


_04001FC8:	// 4001fc8: <0d000443>	JAL	    0400110c
	state.r[S3] = (state.r[T8] + 0);
	sp_reg_pc = 0x04001FC8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _0400110C;


_04001FCC:	// 4001fcc: <03009820>	ADD       S3 = T8+R0
	state.r[S3] = (state.r[T8] + 0);


_04001FD0:	// 4001fd0: <0260c020>	ADD       T8 = S3+R0
	state.r[T8] = (state.r[S3] + 0);


_04001FD4:	// 4001fd4: <aef90000>	SW        [S7+0000] = T9
	Save32_DMEM((_u32)state.r[T9], (state.r[S7] + 0x00000000) & 0xfff);


_04001FD8:	// 4001fd8: <aef80004>	SW        [S7+0004] = T8
	Save32_DMEM((_u32)state.r[T8], (state.r[S7] + 0x00000004) & 0xfff);


_04001FDC:	// 4001fdc: <0d00044a>	JAL	    04001128
	state.r[S7] = state.r[S7] + 0x0008;
	sp_reg_pc = 0x04001FDC;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001128;


_04001FE0:	// 4001fe0: <22f70008>	ADDI      S7 = S7 + 0008
	state.r[S7] = state.r[S7] + 0x0008;


_04001FE4:	// 4001fe4: <1c40ff45>	BGTZ      (R0>0) --> 1cfc
	sp_reg_pc = 0x04001FE4;
	if((_s32)state.r[V0] > 0)
	{
		goto _04001CFC;
	}


_04001FE8:	// 4001fe8: <00000000>	NOP       


_04001FEC:	// 4001fec: <0900042b>	J         040010ac
	state.r[V0] = (state.r[V0] & 0x000001FE);
	goto _040010AC;


_04001FF0:	// 4001ff0: <304201fe>	ANDI      V0 = V0 & 01fe
	state.r[V0] = (state.r[V0] & 0x000001FE);


_04001FF4:	// 4001ff4: <844200c0>	LH        V0 = [V0+00c0]
	state.r[V0] = (_s32)(_s16)Load16_DMEM((state.r[V0] + 0x000000C0) & 0xfff);


_04001FF8:	// 4001ff8: <0d0007f1>	JAL	    04001fc4
	state.r[AT] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFF9) & 0xfff) ^ 3];
	sp_reg_pc = 0x04001FF8;
	state.r[RA] = (sp_reg_pc + 8) & 0x1fff;
	goto _04001FC4;


_04001FFC:	// 4001ffc: <9361fff9>	LBU       AT = [K1+fff9]
	state.r[AT] = (_s32)(_u8)pDMEM[((state.r[K1] + 0xFFFFFFF9) & 0xfff) ^ 3];

	state.halt = 1;
	return;

	_BuildJumpTable:
	#include "jumptable.h"
	goto _Label;
}

void Banjo1BE8_1C4C(void)
{

	// 4001be8: <4bd8a400>	VMULF     vec16 = ( acc = (vec20 * vec24[6]) << 1 ) >> 16
	{
		_u16		s2value = state.v[24].U16[1];
		VMULF_operation(0, state.v[16].U16[0], state.v[20].U16[0], s2value, 1, 0, 0, 1)
		VMULF_operation(1, state.v[16].U16[1], state.v[20].U16[1], s2value, 1, 0, 0, 1)
		VMULF_operation(2, state.v[16].U16[2], state.v[20].U16[2], s2value, 1, 0, 0, 1)
		VMULF_operation(3, state.v[16].U16[3], state.v[20].U16[3], s2value, 1, 0, 0, 1)
		VMULF_operation(4, state.v[16].U16[4], state.v[20].U16[4], s2value, 1, 0, 0, 1)
		VMULF_operation(5, state.v[16].U16[5], state.v[20].U16[5], s2value, 1, 0, 0, 1)
		VMULF_operation(6, state.v[16].U16[6], state.v[20].U16[6], s2value, 1, 0, 0, 1)
		VMULF_operation(7, state.v[16].U16[7], state.v[20].U16[7], s2value, 1, 0, 0, 1)
	}


	// 4001bec: <eb142000>	SQV       [T8 + 0x00] = vec20 <00>
	{
		_u32    addr = (0x00000000 + state.r[T8]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[20].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[20].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[20].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[20].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[20].U64[0] & temp1);
			value2 |= (state.v[20].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


	// 4001bf0: <4bf8a3c0>	VMULF     vec15 = ( acc = (vec20 * vec24[7]) << 1 ) >> 16
	{
		_u16		s2value = state.v[24].U16[0];
		VMULF_operation(0, state.v[15].U16[0], state.v[20].U16[0], s2value, 1, 0, 0, 1)
		VMULF_operation(1, state.v[15].U16[1], state.v[20].U16[1], s2value, 1, 0, 0, 1)
		VMULF_operation(2, state.v[15].U16[2], state.v[20].U16[2], s2value, 1, 0, 0, 1)
		VMULF_operation(3, state.v[15].U16[3], state.v[20].U16[3], s2value, 1, 0, 0, 1)
		VMULF_operation(4, state.v[15].U16[4], state.v[20].U16[4], s2value, 1, 0, 0, 1)
		VMULF_operation(5, state.v[15].U16[5], state.v[20].U16[5], s2value, 1, 0, 0, 1)
		VMULF_operation(6, state.v[15].U16[6], state.v[20].U16[6], s2value, 1, 0, 0, 1)
		VMULF_operation(7, state.v[15].U16[7], state.v[20].U16[7], s2value, 1, 0, 0, 1)
	}


	// 4001bf4: <eb152001>	SQV       [T8 + 0x10] = vec21 <00>
	{
		_u32    addr = (0x00000010 + state.r[T8]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[21].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[21].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[21].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[21].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[21].U64[0] & temp1);
			value2 |= (state.v[21].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


	// 4001bf8: <4baaef40>	VMULF     vec29 = ( acc = (vec29 * vec10[5]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[2];
		VMULF_operation(0, state.v[29].U16[0], state.v[29].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[29].U16[1], state.v[29].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[29].U16[2], state.v[29].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[29].U16[3], state.v[29].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[29].U16[4], state.v[29].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[29].U16[5], state.v[29].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[29].U16[6], state.v[29].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[29].U16[7], state.v[29].U16[7], s2value, 0, 1, 1, 1)
	}


	// 4001bfc: <4a108f48>	VMACF     vec29 = ( acc += (vec17 * vec16[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[29].U16[0], state.v[17].U16[0], state.v[16].U16[0], 1, 0, 0, 1)
		VMACF_operation(1, state.v[29].U16[1], state.v[17].U16[1], state.v[16].U16[1], 1, 0, 0, 1)
		VMACF_operation(2, state.v[29].U16[2], state.v[17].U16[2], state.v[16].U16[2], 1, 0, 0, 1)
		VMACF_operation(3, state.v[29].U16[3], state.v[17].U16[3], state.v[16].U16[3], 1, 0, 0, 1)
		VMACF_operation(4, state.v[29].U16[4], state.v[17].U16[4], state.v[16].U16[4], 1, 0, 0, 1)
		VMACF_operation(5, state.v[29].U16[5], state.v[17].U16[5], state.v[16].U16[5], 1, 0, 0, 1)
		VMACF_operation(6, state.v[29].U16[6], state.v[17].U16[6], state.v[16].U16[6], 1, 0, 0, 1)
		VMACF_operation(7, state.v[29].U16[7], state.v[17].U16[7], state.v[16].U16[7], 1, 0, 0, 1)
	}


	// 4001c00: <ca9c2000>	LQV       vec28 <00> = [S4 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S4]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[28].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[28].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[28].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[28].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[28].U64[0] = state.v[28].U64[0] & ~temp1;
			state.v[28].U64[1] = state.v[28].U64[1] & ~temp2;
			state.v[28].U64[0] = state.v[28].U64[0] | value1;
			state.v[28].U64[1] = state.v[28].U64[1] | value2;
		}
	}


	// 4001c04: <4baadec0>	VMULF     vec27 = ( acc = (vec27 * vec10[5]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[2];
		VMULF_operation(0, state.v[27].U16[0], state.v[27].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[27].U16[1], state.v[27].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[27].U16[2], state.v[27].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[27].U16[3], state.v[27].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[27].U16[4], state.v[27].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[27].U16[5], state.v[27].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[27].U16[6], state.v[27].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[27].U16[7], state.v[27].U16[7], s2value, 0, 1, 1, 1)
	}


	// 4001c08: <ca5a2000>	LQV       vec26 <00> = [S2 + 0x00]
	{
		_u32 addr = (0x00000000 + state.r[S2]);
		int shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			state.v[26].U32[0] = *(_u32 *)&pDMEM[addr+12];
			state.v[26].U32[1] = *(_u32 *)&pDMEM[addr+8];
			state.v[26].U32[2] = *(_u32 *)&pDMEM[addr+4];
			state.v[26].U32[3] = *(_u32 *)&pDMEM[addr];
		}
		else
		{
			_u64		temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64		temp2 = 0xFFFFFFFFFFFFFFFF;
			_u64		value1 = Load64_DMEM(addr+8);
			_u64		value2 = Load64_DMEM(addr);
			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & temp1;
			value2 = value2 & temp2;

			state.v[26].U64[0] = state.v[26].U64[0] & ~temp1;
			state.v[26].U64[1] = state.v[26].U64[1] & ~temp2;
			state.v[26].U64[0] = state.v[26].U64[0] | value1;
			state.v[26].U64[1] = state.v[26].U64[1] | value2;
		}
	}


	// 4001c0c: <4a0f8ec8>	VMACF     vec27 = ( acc += (vec17 * vec15[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[27].U16[0], state.v[17].U16[0], state.v[15].U16[0], 1, 0, 0, 1)
		VMACF_operation(1, state.v[27].U16[1], state.v[17].U16[1], state.v[15].U16[1], 1, 0, 0, 1)
		VMACF_operation(2, state.v[27].U16[2], state.v[17].U16[2], state.v[15].U16[2], 1, 0, 0, 1)
		VMACF_operation(3, state.v[27].U16[3], state.v[17].U16[3], state.v[15].U16[3], 1, 0, 0, 1)
		VMACF_operation(4, state.v[27].U16[4], state.v[17].U16[4], state.v[15].U16[4], 1, 0, 0, 1)
		VMACF_operation(5, state.v[27].U16[5], state.v[17].U16[5], state.v[15].U16[5], 1, 0, 0, 1)
		VMACF_operation(6, state.v[27].U16[6], state.v[17].U16[6], state.v[15].U16[6], 1, 0, 0, 1)
		VMACF_operation(7, state.v[27].U16[7], state.v[17].U16[7], state.v[15].U16[7], 1, 0, 0, 1)
	}


	// 4001c10: <2231fff0>	ADDI      S1 = S1 + fff0
	state.r[S1] = state.r[S1] + 0xFFFFFFF0;


	// 4001c14: <4b58ad54>	VADDC	vec21 = vec21 + vec24[2]
	{
		_u16		flag0 = 0;
		_u16		s2value = state.v[24].U16[5];
		VADDC_operation(0, state.v[21].U16[0], state.v[21].U16[0], s2value, 1, 0, 0, 1)
		VADDC_operation(1, state.v[21].U16[1], state.v[21].U16[1], s2value, 1, 0, 0, 1)
		VADDC_operation(2, state.v[21].U16[2], state.v[21].U16[2], s2value, 1, 0, 0, 1)
		VADDC_operation(3, state.v[21].U16[3], state.v[21].U16[3], s2value, 1, 0, 0, 1)
		VADDC_operation(4, state.v[21].U16[4], state.v[21].U16[4], s2value, 1, 0, 0, 1)
		VADDC_operation(5, state.v[21].U16[5], state.v[21].U16[5], s2value, 1, 0, 0, 1)
		VADDC_operation(6, state.v[21].U16[6], state.v[21].U16[6], s2value, 1, 0, 0, 1)
		VADDC_operation(7, state.v[21].U16[7], state.v[21].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = flag0;
	}


	// 4001c18: <22100010>	ADDI      S0 = S0 + 0010
	state.r[S0] = state.r[S0] + 0x0010;


	// 4001c1c: <4b38a510>	VADD      vec20 = vec20 + vec24[1]
	{
		_u16		flag0 = state.flag[0];
		_u16		s2value = state.v[24].U16[6];
		VADD_operation(0, state.v[20].U16[0], state.v[20].U16[0], s2value, 1, 0, 0, 1)
		VADD_operation(1, state.v[20].U16[1], state.v[20].U16[1], s2value, 1, 0, 0, 1)
		VADD_operation(2, state.v[20].U16[2], state.v[20].U16[2], s2value, 1, 0, 0, 1)
		VADD_operation(3, state.v[20].U16[3], state.v[20].U16[3], s2value, 1, 0, 0, 1)
		VADD_operation(4, state.v[20].U16[4], state.v[20].U16[4], s2value, 1, 0, 0, 1)
		VADD_operation(5, state.v[20].U16[5], state.v[20].U16[5], s2value, 1, 0, 0, 1)
		VADD_operation(6, state.v[20].U16[6], state.v[20].U16[6], s2value, 1, 0, 0, 1)
		VADD_operation(7, state.v[20].U16[7], state.v[20].U16[7], s2value, 1, 0, 0, 1)
		state.flag[0] = 0x0000;
	}


	// 4001c20: <eabd2000>	SQV       [S5 + 0x00] = vec29 <00>
	{
		_u32    addr = (0x00000000 + state.r[S5]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[29].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[29].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[29].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[29].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[29].U64[0] & temp1);
			value2 |= (state.v[29].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


	// 4001c24: <4bd89400>	VMULF     vec16 = ( acc = (vec18 * vec24[6]) << 1 ) >> 16
	{
		_u16		s2value = state.v[24].U16[1];
		VMULF_operation(0, state.v[16].U16[0], state.v[18].U16[0], s2value, 1, 0, 0, 1)
		VMULF_operation(1, state.v[16].U16[1], state.v[18].U16[1], s2value, 1, 0, 0, 1)
		VMULF_operation(2, state.v[16].U16[2], state.v[18].U16[2], s2value, 1, 0, 0, 1)
		VMULF_operation(3, state.v[16].U16[3], state.v[18].U16[3], s2value, 1, 0, 0, 1)
		VMULF_operation(4, state.v[16].U16[4], state.v[18].U16[4], s2value, 1, 0, 0, 1)
		VMULF_operation(5, state.v[16].U16[5], state.v[18].U16[5], s2value, 1, 0, 0, 1)
		VMULF_operation(6, state.v[16].U16[6], state.v[18].U16[6], s2value, 1, 0, 0, 1)
		VMULF_operation(7, state.v[16].U16[7], state.v[18].U16[7], s2value, 1, 0, 0, 1)
	}


	// 4001c28: <22b50010>	ADDI      S5 = S5 + 0010
	state.r[S5] = state.r[S5] + 0x0010;


	// 4001c2c: <4bf893c0>	VMULF     vec15 = ( acc = (vec18 * vec24[7]) << 1 ) >> 16
	{
		_u16		s2value = state.v[24].U16[0];
		VMULF_operation(0, state.v[15].U16[0], state.v[18].U16[0], s2value, 1, 0, 0, 1)
		VMULF_operation(1, state.v[15].U16[1], state.v[18].U16[1], s2value, 1, 0, 0, 1)
		VMULF_operation(2, state.v[15].U16[2], state.v[18].U16[2], s2value, 1, 0, 0, 1)
		VMULF_operation(3, state.v[15].U16[3], state.v[18].U16[3], s2value, 1, 0, 0, 1)
		VMULF_operation(4, state.v[15].U16[4], state.v[18].U16[4], s2value, 1, 0, 0, 1)
		VMULF_operation(5, state.v[15].U16[5], state.v[18].U16[5], s2value, 1, 0, 0, 1)
		VMULF_operation(6, state.v[15].U16[6], state.v[18].U16[6], s2value, 1, 0, 0, 1)
		VMULF_operation(7, state.v[15].U16[7], state.v[18].U16[7], s2value, 1, 0, 0, 1)
	}


	// 4001c30: <ea7b2000>	SQV       [S3 + 0x00] = vec27 <00>
	{
		_u32    addr = (0x00000000 + state.r[S3]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[27].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[27].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[27].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[27].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[27].U64[0] & temp1);
			value2 |= (state.v[27].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


	// 4001c34: <4baae700>	VMULF     vec28 = ( acc = (vec28 * vec10[5]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[2];
		VMULF_operation(0, state.v[28].U16[0], state.v[28].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[28].U16[1], state.v[28].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[28].U16[2], state.v[28].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[28].U16[3], state.v[28].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[28].U16[4], state.v[28].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[28].U16[5], state.v[28].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[28].U16[6], state.v[28].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[28].U16[7], state.v[28].U16[7], s2value, 0, 1, 1, 1)
	}


	// 4001c38: <22730010>	ADDI      S3 = S3 + 0010
	state.r[S3] = state.r[S3] + 0x0010;


	// 4001c3c: <4a108f08>	VMACF     vec28 = ( acc += (vec17 * vec16[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[28].U16[0], state.v[17].U16[0], state.v[16].U16[0], 1, 0, 0, 1)
		VMACF_operation(1, state.v[28].U16[1], state.v[17].U16[1], state.v[16].U16[1], 1, 0, 0, 1)
		VMACF_operation(2, state.v[28].U16[2], state.v[17].U16[2], state.v[16].U16[2], 1, 0, 0, 1)
		VMACF_operation(3, state.v[28].U16[3], state.v[17].U16[3], state.v[16].U16[3], 1, 0, 0, 1)
		VMACF_operation(4, state.v[28].U16[4], state.v[17].U16[4], state.v[16].U16[4], 1, 0, 0, 1)
		VMACF_operation(5, state.v[28].U16[5], state.v[17].U16[5], state.v[16].U16[5], 1, 0, 0, 1)
		VMACF_operation(6, state.v[28].U16[6], state.v[17].U16[6], state.v[16].U16[6], 1, 0, 0, 1)
		VMACF_operation(7, state.v[28].U16[7], state.v[17].U16[7], state.v[16].U16[7], 1, 0, 0, 1)
	}


	// 4001c40: <4baad680>	VMULF     vec26 = ( acc = (vec26 * vec10[5]) << 1 ) >> 16
	{
		_u16		s2value = state.v[10].U16[2];
		VMULF_operation(0, state.v[26].U16[0], state.v[26].U16[0], s2value, 0, 1, 1, 1)
		VMULF_operation(1, state.v[26].U16[1], state.v[26].U16[1], s2value, 0, 1, 1, 1)
		VMULF_operation(2, state.v[26].U16[2], state.v[26].U16[2], s2value, 0, 1, 1, 1)
		VMULF_operation(3, state.v[26].U16[3], state.v[26].U16[3], s2value, 0, 1, 1, 1)
		VMULF_operation(4, state.v[26].U16[4], state.v[26].U16[4], s2value, 0, 1, 1, 1)
		VMULF_operation(5, state.v[26].U16[5], state.v[26].U16[5], s2value, 0, 1, 1, 1)
		VMULF_operation(6, state.v[26].U16[6], state.v[26].U16[6], s2value, 0, 1, 1, 1)
		VMULF_operation(7, state.v[26].U16[7], state.v[26].U16[7], s2value, 0, 1, 1, 1)
	}


	// 4001c44: <4a0f8e88>	VMACF     vec26 = ( acc += (vec17 * vec15[<none>]) << 1 ) >> 16
	{
		VMACF_operation(0, state.v[26].U16[0], state.v[17].U16[0], state.v[15].U16[0], 1, 1, 1, 1)
		VMACF_operation(1, state.v[26].U16[1], state.v[17].U16[1], state.v[15].U16[1], 1, 1, 1, 1)
		VMACF_operation(2, state.v[26].U16[2], state.v[17].U16[2], state.v[15].U16[2], 1, 1, 1, 1)
		VMACF_operation(3, state.v[26].U16[3], state.v[17].U16[3], state.v[15].U16[3], 1, 1, 1, 1)
		VMACF_operation(4, state.v[26].U16[4], state.v[17].U16[4], state.v[15].U16[4], 1, 1, 1, 1)
		VMACF_operation(5, state.v[26].U16[5], state.v[17].U16[5], state.v[15].U16[5], 1, 1, 1, 1)
		VMACF_operation(6, state.v[26].U16[6], state.v[17].U16[6], state.v[15].U16[6], 1, 1, 1, 1)
		VMACF_operation(7, state.v[26].U16[7], state.v[17].U16[7], state.v[15].U16[7], 1, 1, 1, 1)
	}


	// 4001c48: <ea9c2000>	SQV       [S4 + 0x00] = vec28 <00>
	{
		_u32    addr = (0x00000000 + state.r[S4]);
		int     shifter = ((addr & 0xf) << 3);

		if (shifter == 0 && (addr&3) == 0 )
		{
			addr &= 0xfff;
			*(_u32 *)&pDMEM[addr+12] = state.v[28].U32[0];
			*(_u32 *)&pDMEM[addr+8 ] = state.v[28].U32[1];
			*(_u32 *)&pDMEM[addr+4 ] = state.v[28].U32[2];
			*(_u32 *)&pDMEM[addr   ] = state.v[28].U32[3];
		}
		else
		{
			_u64    value1 = Load64_DMEM(addr+8);
			_u64    value2 = Load64_DMEM(addr);
			_u64    temp1 = 0xFFFFFFFFFFFFFFFF;
			_u64    temp2 = 0xFFFFFFFFFFFFFFFF;

			if (shifter > 0x40)
			{
				temp2 = ((temp2 >> (shifter-0x40)) << (shifter-0x40));
				temp1 = 0;
			} else {
				temp1 = ((temp1 >> shifter) << shifter);
			}
			value1 = value1 & ~temp1;
			value2 = value2 & ~temp2;

			value1 |= (state.v[28].U64[0] & temp1);
			value2 |= (state.v[28].U64[1] & temp2);

			Save64_DMEM(value1, addr+8);
			Save64_DMEM(value2, addr  );
		}
	}


	// 4001c4c: <22940010>	ADDI      S4 = S4 + 0010
	state.r[S4] = state.r[S4] + 0x0010;

_04001C50:
	;
}
